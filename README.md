# 📚 기초부터 공부하는 Python
- [📚 기초부터 공부하는 Python](#-기초부터-공부하는-python)
- [📘 파이썬 완전 기초](#-파이썬-완전-기초)
  - [📄 Print 사용법](#-print-사용법)
        - [파이썬에서 데이터를 화면에 출력하기 위해 print() 함수를 사용. 🖨️ 이 함수는 매우 다양하고 유연한 출력 옵션을 제공하고. 이를 통해 데이터를 명확하고 이해하기 쉬운 형태로 표시할 수 있음.](#파이썬에서-데이터를-화면에-출력하기-위해-print-함수를-사용-️-이-함수는-매우-다양하고-유연한-출력-옵션을-제공하고-이를-통해-데이터를-명확하고-이해하기-쉬운-형태로-표시할-수-있음)
  - [📝 기본 출력](#-기본-출력)
      - [문자열은 작은따옴표(') 또는 큰따옴표(")로 둘러싸서 표현.](#문자열은-작은따옴표-또는-큰따옴표로-둘러싸서-표현)
  - [🔐 Escape 코드](#-escape-코드)
  - [🔗 separator 옵션 사용](#-separator-옵션-사용)
  - [➡️ end 옵션 사용](#️-end-옵션-사용)
  - [📤 file 옵션 사용](#-file-옵션-사용)
  - [🖊️ 문자열 포맷팅](#️-문자열-포맷팅)
    - [% 연산자를 이용한 포맷팅](#-연산자를-이용한-포맷팅)
  - [🧩 format() 메소드를 이용한 포맷팅](#-format-메소드를-이용한-포맷팅)
  - [📐 숫자 포맷팅](#-숫자-포맷팅)
      - [이렇게 print() 함수를 활용하여 파이썬에서 데이터를 다양하고 유연한 방식으로 표현할 수 있다. 코드를 작성하며 결과를 확인하고, 데이터를 가공하는 과정에서 이러한 기법을 활용해 보자. 🚀🌟](#이렇게-print-함수를-활용하여-파이썬에서-데이터를-다양하고-유연한-방식으로-표현할-수-있다-코드를-작성하며-결과를-확인하고-데이터를-가공하는-과정에서-이러한-기법을-활용해-보자-)
- [🌟 파이썬 기초 다지기](#-파이썬-기초-다지기)
  - [🖨️ Print 사용법 깊게 알아보기](#️-print-사용법-깊게-알아보기)
      - [파이썬에서는 데이터를 화면에 표시하는 여러 방법을 제공. 이번 세션에서는 문자열을 출력하는 세 가지 주요 방법을 살펴보며, 각 방법이 어떻게 다른지, 어떤 상황에 어느 방법을 사용하면 좋을지 알아보자. 🌈](#파이썬에서는-데이터를-화면에-표시하는-여러-방법을-제공-이번-세션에서는-문자열을-출력하는-세-가지-주요-방법을-살펴보며-각-방법이-어떻게-다른지-어떤-상황에-어느-방법을-사용하면-좋을지-알아보자-)
    - [먼저, 문자열 포맷팅에 사용될 변수들을 정의해 보자.](#먼저-문자열-포맷팅에-사용될-변수들을-정의해-보자)
  - [📖 문자열 포맷팅 방법](#-문자열-포맷팅-방법)
    - [출력1: % 연산자](#출력1--연산자)
      - [이 방법은 C언어 스타일의 포맷팅 방법으로, 문자열 내에 특정 값들을 삽입할 때 사용.](#이-방법은-c언어-스타일의-포맷팅-방법으로-문자열-내에-특정-값들을-삽입할-때-사용)
      - [%s는 문자열을, %d는 정수를 나타냄. n, text, 그리고 x + y의 결과가 각 위치에 삽입되어 문자열이 완성된다.](#s는-문자열을-d는-정수를-나타냄-n-text-그리고-x--y의-결과가-각-위치에-삽입되어-문자열이-완성된다)
    - [출력2: .format() 메소드](#출력2-format-메소드)
      - [.format() 메소드는 % 연산자보다 더 유연하고 직관적인 방법을 제공.](#format-메소드는--연산자보다-더-유연하고-직관적인-방법을-제공)
      - [{}는 변수의 값을 삽입할 위치를 나타내며, .format() 메소드의 인자를 통해 실제 값들이 전달됨.](#는-변수의-값을-삽입할-위치를-나타내며-format-메소드의-인자를-통해-실제-값들이-전달됨)
    - [출력3: f-스트링 (f-strings)](#출력3-f-스트링-f-strings)
      - [f-스트링은 Python 3.6 이상에서 사용할 수 있는 가장 최신의 포맷팅 기법. 가독성과 편의성이 뛰어남.](#f-스트링은-python-36-이상에서-사용할-수-있는-가장-최신의-포맷팅-기법-가독성과-편의성이-뛰어남)
      - [문자열 앞에 f를 붙이고, {} 안에 직접 변수명이나 수식을 넣어 값을 삽입.](#문자열-앞에-f를-붙이고--안에-직접-변수명이나-수식을-넣어-값을-삽입)
    - [출력4: 다양한 f-스트링 활용법](#출력4-다양한-f-스트링-활용법)
      - [진수 변환, 구분자 사용, 정렬, 그리고 채우기와 같은 다양한 포맷팅을 f-스트링으로 쉽게 할 수 있다.](#진수-변환-구분자-사용-정렬-그리고-채우기와-같은-다양한-포맷팅을-f-스트링으로-쉽게-할-수-있다)
      - [위 예시들처럼 `print()` 함수와 문자열 포맷팅을 활용하면, 복잡한 데이터도 이해하기 쉽고 깔끔한 형태로 출력할 수 있다.](#위-예시들처럼-print-함수와-문자열-포맷팅을-활용하면-복잡한-데이터도-이해하기-쉽고-깔끔한-형태로-출력할-수-있다)
- [📘 파이썬 기초 다지기 II](#-파이썬-기초-다지기-ii)
  - [🚀 파이썬 변수 기본](#-파이썬-변수-기본)
      - [변수는 파이썬에서 데이터를 저장하는 컨테이너. 내가 작성한 프로그램에서 다양한 데이터를 다룰 때 변수를 사용하여 이를 저장하고 참조할 수 있다.](#변수는-파이썬에서-데이터를-저장하는-컨테이너-내가-작성한-프로그램에서-다양한-데이터를-다룰-때-변수를-사용하여-이를-저장하고-참조할-수-있다)
  - [📝 기본 선언](#-기본-선언)
    - [🖨️ 출력](#️-출력)
  - [🔗 동시 선언](#-동시-선언)
    - [🖨️ 출력](#️-출력-1)
  - [🔄 재선언과 타입 변경](#-재선언과-타입-변경)
  - [🌐 객체 참조와 변수의 아이덴티티](#-객체-참조와-변수의-아이덴티티)
      - [파이썬에서 변수를 할당할 때는 실제로 메모리에 객체를 생성하고, 변수는 그 객체를 참조하게 됨.](#파이썬에서-변수를-할당할-때는-실제로-메모리에-객체를-생성하고-변수는-그-객체를-참조하게-됨)
  - [🧐 객체 참조](#-객체-참조)
  - [🔍 id(identity)확인: 객체의 고유값 확인](#-ididentity확인-객체의-고유값-확인)
  - [🎨 다양한 변수 선언 방식](#-다양한-변수-선언-방식)
  - [✅ 허용하는 변수 선언 법](#-허용하는-변수-선언-법)
    - [❗ 예약어는 변수명으로 사용할 수 없음.](#-예약어는-변수명으로-사용할-수-없음)
      - [파이썬에서 이미 문법적인 용도로 사용되고 있는 단어들(예: if, for, class 등)은 변수 이름으로 사용할 수 없다. 이러한 단어들은 파이썬의 기능을 수행하기 위해 예약되어 있기 때문](#파이썬에서-이미-문법적인-용도로-사용되고-있는-단어들예-if-for-class-등은-변수-이름으로-사용할-수-없다-이러한-단어들은-파이썬의-기능을-수행하기-위해-예약되어-있기-때문)
- [📘 파이썬 완전 기초: 숫자형 다루기](#-파이썬-완전-기초-숫자형-다루기)
    - [파이썬에서 숫자를 다루는 것은 프로그래밍의 기본. 숫자형은 계산, 데이터 분석, 알고리즘 구현 등 다양한 영역에서 활용. 여기서는 파이썬이 지원하는 숫자형과 기본적인 수학 연산에 대해 알아보자. 🚀](#파이썬에서-숫자를-다루는-것은-프로그래밍의-기본-숫자형은-계산-데이터-분석-알고리즘-구현-등-다양한-영역에서-활용-여기서는-파이썬이-지원하는-숫자형과-기본적인-수학-연산에-대해-알아보자-)
  - [📚 파이썬 지원 자료형](#-파이썬-지원-자료형)
      - [파이썬에서 사용할 수 있는 기본적인 숫자형은 다음과 같다:](#파이썬에서-사용할-수-있는-기본적인-숫자형은-다음과-같다)
      - [또한, 숫자형 이외에도 여러가지 타입이 있어, 데이터를 다양한 형태로 표현할 수 있다:](#또한-숫자형-이외에도-여러가지-타입이-있어-데이터를-다양한-형태로-표현할-수-있다)
  - [🧮 숫자형 연산자](#-숫자형-연산자)
      - [파이썬에서 숫자를 다루기 위한 기본 연산자는 아래와 같다:](#파이썬에서-숫자를-다루기-위한-기본-연산자는-아래와-같다)
  - [💡 숫자형 예제와 연산 실습](#-숫자형-예제와-연산-실습)
      - [기본 숫자형 사용](#기본-숫자형-사용)
      - [간단한 수학 연산](#간단한-수학-연산)
  - [🔄 형 변환 실습](#-형-변환-실습)
      - [형 변환은 한 타입의 데이터를 다른 타입으로 변경하는 것을 말함. 숫자형에서 자주 사용:](#형-변환은-한-타입의-데이터를-다른-타입으로-변경하는-것을-말함-숫자형에서-자주-사용)
  - [🧑‍🔬 수치 연산 함수](#-수치-연산-함수)
      - [파이썬에는 숫자를 다루는 데 유용한 내장 함수들이 있다:](#파이썬에는-숫자를-다루는-데-유용한-내장-함수들이-있다)
  - [📚 외부 모듈 사용하기: math 모듈](#-외부-모듈-사용하기-math-모듈)
      - [파이썬은 수학 연산을 위한 `math` 모듈을 제공. 이 모듈을 사용하면 복잡한 수학 연산을 쉽게 수행할 수 있다:](#파이썬은-수학-연산을-위한-math-모듈을-제공-이-모듈을-사용하면-복잡한-수학-연산을-쉽게-수행할-수-있다)
      - [숫자형과 이를 다루는 기본 연산자, 수치 연산 함수를 이해하고 사용할 줄 알면, 파이썬 프로그래밍의 기초를 탄탄히 다질 수 있다. 이러한 지식은 나아가 데이터 분석, 과학 계산 등 보다 고급 주제를 학습하는 데 큰 도움이 될 것! 🌟📈](#숫자형과-이를-다루는-기본-연산자-수치-연산-함수를-이해하고-사용할-줄-알면-파이썬-프로그래밍의-기초를-탄탄히-다질-수-있다-이러한-지식은-나아가-데이터-분석-과학-계산-등-보다-고급-주제를-학습하는-데-큰-도움이-될-것-)
- [📘 파이썬 완전 기초: 문자형 이해하기](#-파이썬-완전-기초-문자형-이해하기)
  - [문자형은 파이썬에서 매우 중요한 데이터 유형. 문자열을 저장하고 처리하는 방법을 배우면, 프로그래밍의 많은 영역에서 활용할 수 있다.](#문자형은-파이썬에서-매우-중요한-데이터-유형-문자열을-저장하고-처리하는-방법을-배우면-프로그래밍의-많은-영역에서-활용할-수-있다)
  - [📝 문자열 생성하기](#-문자열-생성하기)
      - [파이썬에서 문자열을 만드는 방법은 간단. 다양한 방법으로 문자열을 생성해 볼 수 있다:](#파이썬에서-문자열을-만드는-방법은-간단-다양한-방법으로-문자열을-생성해-볼-수-있다)
    - [🖨️ 문자열 출력 및 타입 확인](#️-문자열-출력-및-타입-확인)
      - [문자열의 타입을 확인하고, 문자열의 길이를 알아보자:](#문자열의-타입을-확인하고-문자열의-길이를-알아보자)
  - [🚀 빈 문자열 생성](#-빈-문자열-생성)
      - [빈 문자열도 문자열의 한 형태. 다음과 같이 생성할 수 있다:](#빈-문자열도-문자열의-한-형태-다음과-같이-생성할-수-있다)
  - [✨ 이스케이프 문자 사용하기](#-이스케이프-문자-사용하기)
      - [특수 문자를 문자열 안에 포함시키고 싶을 때, 이스케이프 문자를 사용:](#특수-문자를-문자열-안에-포함시키고-싶을-때-이스케이프-문자를-사용)
  - [🌈 탭과 줄바꿈](#-탭과-줄바꿈)
      - [탭(\\t)과 줄바꿈(\\n)을 사용하여 문자열을 보기 좋게 구성할 수 있다:](#탭t과-줄바꿈n을-사용하여-문자열을-보기-좋게-구성할-수-있다)
  - [📂 Raw String 활용하기](#-raw-string-활용하기)
      - [파일 경로 등에서 백슬래시()를 그대로 사용하고 싶을 때 Raw String을 사용:](#파일-경로-등에서-백슬래시를-그대로-사용하고-싶을-때-raw-string을-사용)
  - [📜 멀티라인 문자열](#-멀티라인-문자열)
      - [여러 줄에 걸쳐 문자열을 작성하고 싶을 때 사용:](#여러-줄에-걸쳐-문자열을-작성하고-싶을-때-사용)
  - [🎭 문자열 연산](#-문자열-연산)
      - [문자열을 더하거나 반복하는 등의 연산을 할 수 있다:](#문자열을-더하거나-반복하는-등의-연산을-할-수-있다)
  - [🔄 문자열 형 변환](#-문자열-형-변환)
      - [다른 데이터 타입을 문자열로 변환할 수 있다:](#다른-데이터-타입을-문자열로-변환할-수-있다)
  - [🛠️ 문자열 메서드 활용하기](#️-문자열-메서드-활용하기)
      - [문자열을 대문자로 변환하거나, 특정 문자로 시작하는지 확인하고, 문자열을 분리하는 등 여러 메서드를 사용할 수 있다:](#문자열을-대문자로-변환하거나-특정-문자로-시작하는지-확인하고-문자열을-분리하는-등-여러-메서드를-사용할-수-있다)
  - [🔍 반복문을 사용한 문자 출력](#-반복문을-사용한-문자-출력)
      - [문자열도 반복 가능한 객체이므로, for문을 사용하여 문자열의 각 문자를 출력할 수 있다:](#문자열도-반복-가능한-객체이므로-for문을-사용하여-문자열의-각-문자를-출력할-수-있다)
  - [🔎 슬라이싱으로 문자열 부분 선택하기](#-슬라이싱으로-문자열-부분-선택하기)
      - [문자열에서 원하는 부분만 추출할 수 있다:](#문자열에서-원하는-부분만-추출할-수-있다)
  - [📚 아스키코드와 문자 변환](#-아스키코드와-문자-변환)
      - [문자와 이에 해당하는 아스키 코드를 상호 변환할 수 있다:](#문자와-이에-해당하는-아스키-코드를-상호-변환할-수-있다)
      - [이러한 문자형 데이터와 다양한 작업들을 통해, 파이썬에서 문자열을 더 효과적으로 다룰 수 있다. 문자열은 프로그래밍에서 매우 자주 사용되므로 이러한 기본적인 내용들을 잘 이해! 🌟](#이러한-문자형-데이터와-다양한-작업들을-통해-파이썬에서-문자열을-더-효과적으로-다룰-수-있다-문자열은-프로그래밍에서-매우-자주-사용되므로-이러한-기본적인-내용들을-잘-이해-)
- [📘 파이썬 리스트](#-파이썬-리스트)
    - [리스트는 파이썬에서 가장 자주 사용되는 자료구조 중 하나. 순서가 있고, 중복을 허용하며, 수정과 삭제가 가능 (파이썬 배열 제공X).](#리스트는-파이썬에서-가장-자주-사용되는-자료구조-중-하나-순서가-있고-중복을-허용하며-수정과-삭제가-가능-파이썬-배열-제공x)
  - [📝 리스트 선언](#-리스트-선언)
      - [파이썬에서 리스트를 만드는 여러 가지 방법.](#파이썬에서-리스트를-만드는-여러-가지-방법)
  - [🔍 인덱싱 (원하는 데이터를 꺼내오는 과정)](#-인덱싱-원하는-데이터를-꺼내오는-과정)
      - [리스트 내 특정 요소에 접근하는 방법.](#리스트-내-특정-요소에-접근하는-방법)
  - [🍽️ 슬라이싱](#️-슬라이싱)
      - [리스트의 부분적인 요소들을 추출하는 방법.](#리스트의-부분적인-요소들을-추출하는-방법)
  - [➕ 리스트 연산](#-리스트-연산)
      - [리스트를 이용한 연산 예시.](#리스트를-이용한-연산-예시)
    - [리스트 값 비교 예제](#리스트-값-비교-예제)
    - [리스트 id 비교 예제](#리스트-id-비교-예제)
  - [🔄 리스트 수정, 삭제](#-리스트-수정-삭제)
      - [리스트의 요소를 수정하거나 삭제하는 방법.](#리스트의-요소를-수정하거나-삭제하는-방법)
  - [🛠️ 리스트 함수](#️-리스트-함수)
      - [리스트를 다루는 다양한 함수들.](#리스트를-다루는-다양한-함수들)
- [삭제 remove, pop, del 🗑️](#삭제-remove-pop-del-️)
    - [`remove` 메서드 사용](#remove-메서드-사용)
      - [🔍 사용 예: a 리스트에서 값이 2인 첫 번째 요소를 제거.](#-사용-예-a-리스트에서-값이-2인-첫-번째-요소를-제거)
    - [`pop` 메서드 사용](#pop-메서드-사용)
      - [pop은 리스트의 마지막 요소를 제거하고, 그 값을 반환.](#pop은-리스트의-마지막-요소를-제거하고-그-값을-반환)
        - [인덱스를 지정하여 해당 위치의 요소를 제거하고 반환할 수도 있다.](#인덱스를-지정하여-해당-위치의-요소를-제거하고-반환할-수도-있다)
        - [🔍 사용 예: a 리스트의 마지막 요소를 제거하고, 그 값을 `last_element` 변수에 저장.](#-사용-예-a-리스트의-마지막-요소를-제거하고-그-값을-last_element-변수에-저장)
    - [del 키워드 사용](#del-키워드-사용)
      - [del은 리스트의 특정 인덱스에 있는 요소를 제거.](#del은-리스트의-특정-인덱스에-있는-요소를-제거)
        - [슬라이싱과 함께 사용하여 여러 요소를 한 번에 제거할 수도 있다.](#슬라이싱과-함께-사용하여-여러-요소를-한-번에-제거할-수도-있다)
          - [🔍 사용 예: a 리스트의 첫 번째 요소를 제거, 인덱스 2부터 4까지의 요소들을 제거.](#-사용-예-a-리스트의-첫-번째-요소를-제거-인덱스-2부터-4까지의-요소들을-제거)
      - [`remove`는 값을 기준으로 첫 번째 일치하는 요소를 제거할 때 사용. 🎯](#remove는-값을-기준으로-첫-번째-일치하는-요소를-제거할-때-사용-)
      - [`pop`은 주로 리스트의 마지막 요소를 제거할 때 사용되며, 필요에 따라 제거된 요소의 값을 활용할 수 있다. 🔚](#pop은-주로-리스트의-마지막-요소를-제거할-때-사용되며-필요에-따라-제거된-요소의-값을-활용할-수-있다-)
      - [del은 인덱스를 기준으로 요소를 제거할 때 사용되며, 슬라이싱을 통해 범위를 지정하여 여러 요소를 동시에 제거할 수 있다. 🔢](#del은-인덱스를-기준으로-요소를-제거할-때-사용되며-슬라이싱을-통해-범위를-지정하여-여러-요소를-동시에-제거할-수-있다-)
  - [🔁 반복문과 리스트 맛보기](#-반복문과-리스트-맛보기)
      - [리스트를 반복문과 함께 사용하는 예시.](#리스트를-반복문과-함께-사용하는-예시)
      - [리스트 `a`에서 반복문을 사용하여 모든 요소를 하나씩 제거하고, 각 요소가 특정 값(예: `2`)과 동일한지 확인하는 방법을 살펴보자.](#리스트-a에서-반복문을-사용하여-모든-요소를-하나씩-제거하고-각-요소가-특정-값예-2과-동일한지-확인하는-방법을-살펴보자)
  - [🔍 분석:](#-분석)
- [📘 파이썬 튜플](#-파이썬-튜플)
    - [튜플은 리스트와 유사하지만 한 번 생성되면 내용을 변경할 수 없는 파이썬의 자료형. 순서가 있고 중복을 허용하지만 수정과 삭제는 할 수 없다 (리스트와 비교 중요).](#튜플은-리스트와-유사하지만-한-번-생성되면-내용을-변경할-수-없는-파이썬의-자료형-순서가-있고-중복을-허용하지만-수정과-삭제는-할-수-없다-리스트와-비교-중요)
  - [📝 튜플 선언](#-튜플-선언)
  - [🔍 인덱싱](#-인덱싱)
      - [튜플 내의 특정 요소에 접근.](#튜플-내의-특정-요소에-접근)
    - [🔍 해설:](#-해설)
  - [❌ 수정 X](#-수정-x)
      - [튜플은 생성 후 요소의 수정이 불가능.](#튜플은-생성-후-요소의-수정이-불가능)
  - [🍽️ 슬라이싱](#️-슬라이싱-1)
      - [튜플의 일부분을 가져옴.](#튜플의-일부분을-가져옴)
      - [이 코드는 중첩된 튜플 `e`에서 슬라이싱을 사용하여 특정 요소들을 선택하는 방법을 보여줌.](#이-코드는-중첩된-튜플-e에서-슬라이싱을-사용하여-특정-요소들을-선택하는-방법을-보여줌)
    - [🔍 분석:](#-분석-1)
  - [➕ 튜플 연산](#-튜플-연산)
      - [튜플의 결합과 반복.](#튜플의-결합과-반복)
  - [🛠️ 튜플 함수](#️-튜플-함수)
      - [튜플의 유용한 메서드 사용 예시.](#튜플의-유용한-메서드-사용-예시)
  - [📦 팩킹 \& 언팩킹](#-팩킹--언팩킹)
      - [튜플의 팩킹과 언팩킹을 이용한 변수 할당.](#튜플의-팩킹과-언팩킹을-이용한-변수-할당)
    - [튜플은 불변성(`immutable`)으로 인해 수정할 수 없으므로, 데이터가 변경되지 않아야 할 때 유용하게 사용된다. 예를 들어, 함수에서 여러 값을 안전하게 반환할 때 튜플을 사용할 수 있다.](#튜플은-불변성immutable으로-인해-수정할-수-없으므로-데이터가-변경되지-않아야-할-때-유용하게-사용된다-예를-들어-함수에서-여러-값을-안전하게-반환할-때-튜플을-사용할-수-있다)
- [📚 파이썬 딕셔너리](#-파이썬-딕셔너리)
      - [딕셔너리는 키-값 쌍으로 데이터를 저장하는 파이썬의 자료구조입니다. 리스트와는 달리, 순서를 보장하지 않지만 키를 통해 빠르게 값을 검색할 수 있다(범용적으로 가장 많이 사용, 딕셔너리 자료형(순서X, 키 중복X, 수정O, 삭제O)](#딕셔너리는-키-값-쌍으로-데이터를-저장하는-파이썬의-자료구조입니다-리스트와는-달리-순서를-보장하지-않지만-키를-통해-빠르게-값을-검색할-수-있다범용적으로-가장-많이-사용-딕셔너리-자료형순서x-키-중복x-수정o-삭제o)
  - [🗂️ 딕셔너리 선언](#️-딕셔너리-선언)
  - [🔍 딕셔너리 접근](#-딕셔너리-접근)
      - [딕셔너리 내의 값에 접근하는 방법.](#딕셔너리-내의-값에-접근하는-방법)
  - [➕ 딕셔너리 추가](#-딕셔너리-추가)
  - [📏 딕셔너리 길이](#-딕셔너리-길이)
  - [🔑 딕셔너리의 키, 값, 키-값 쌍 접근](#-딕셔너리의-키-값-키-값-쌍-접근)
    - [.keys(), .values(), .items() 메소드는 딕셔너리의 키, 값, 키-값 쌍을 반복 가능한 객체로 반환.](#keys-values-items-메소드는-딕셔너리의-키-값-키-값-쌍을-반복-가능한-객체로-반환)
  - [🚮 딕셔너리 요소 삭제](#-딕셔너리-요소-삭제)
    - [.pop() 메소드는 지정된 키의 값을 반환하고, 해당 키-값 쌍을 딕셔너리에서 삭제. 키가 딕셔너리에 없으면 오류가 발생.](#pop-메소드는-지정된-키의-값을-반환하고-해당-키-값-쌍을-딕셔너리에서-삭제-키가-딕셔너리에-없으면-오류가-발생)
  - [🔄 수정](#-수정)
      - [딕셔너리의 수정](#딕셔너리의-수정)
      - [.update() 메소드는 다른 딕셔너리 객체의 키-값 쌍으로 현재 딕셔너리를 업데이트.](#update-메소드는-다른-딕셔너리-객체의-키-값-쌍으로-현재-딕셔너리를-업데이트)
      - [딕셔너리는 키를 통해 빠르게 데이터에 접근할 수 있어 파이썬에서 널리 사용되는 자료형.](#딕셔너리는-키를-통해-빠르게-데이터에-접근할-수-있어-파이썬에서-널리-사용되는-자료형)
- [📚 파이썬 집합(Sets) 기본](#-파이썬-집합sets-기본)
      - [집합(Sets)의 특징 🌟](#집합sets의-특징-)
  - [📦 집합 선언하기](#-집합-선언하기)
- [🔢 집합 출력하기](#-집합-출력하기)
- [🔄 집합을 튜플과 리스트로 변환하기](#-집합을-튜플과-리스트로-변환하기)
- [📦 튜플 변환](#-튜플-변환)
- [📝 리스트 변환](#-리스트-변환)
- [📏 길이](#-길이)
  - [집합 자료형 활용하기 🛠️](#집합-자료형-활용하기-️)
    - [교집합 찾기 🤝](#교집합-찾기-)
    - [합집합 구하기 🌐](#합집합-구하기-)
    - [차집합 계산하기 ➖](#차집합-계산하기-)
    - [중복 원소 확인하기 ❓](#중복-원소-확인하기-)
    - [부분 집합 확인하기 🔍](#부분-집합-확인하기-)
    - [집합의 추가와 제거 작업 🛠️](#집합의-추가와-제거-작업-️)
      - [위의 코드는 집합에서 특정 요소를 추가하거나 제거하는 방법을 보여준다. 집합은 .add() 메서드로 요소를 추가할 수 있고, .remove()로 요소를 제거할 수 있으나, 제거하려는 요소가 존재하지 않으면 에러가 발생한다. 반면, .discard() 메서드는 제거하려는 요소가 없어도 에러를 발생시키지 않아, 보다 안전하게 요소를 제거할 수 있게 한다. .clear() 메서드는 집합 내 모든 요소를 제거하여 빈 집합을 만들 때 사용된다. 🌈](#위의-코드는-집합에서-특정-요소를-추가하거나-제거하는-방법을-보여준다-집합은-add-메서드로-요소를-추가할-수-있고-remove로-요소를-제거할-수-있으나-제거하려는-요소가-존재하지-않으면-에러가-발생한다-반면-discard-메서드는-제거하려는-요소가-없어도-에러를-발생시키지-않아-보다-안전하게-요소를-제거할-수-있게-한다-clear-메서드는-집합-내-모든-요소를-제거하여-빈-집합을-만들-때-사용된다-)
- [파이썬 제어문 - IF문 기본 형식 📘](#파이썬-제어문---if문-기본-형식-)
      - [참(True)와 거짓(False)을 나타내는 여러 가지 경우들:](#참true와-거짓false을-나타내는-여러-가지-경우들)
      - [참(True)의 경우: 0이 아닌 숫자, 비어 있지 않은 문자열("abc"), 비어 있지 않은 리스트(\[1, 2, 3\]), 비어 있지 않은 튜플((1, 2, 3)), 등](#참true의-경우-0이-아닌-숫자-비어-있지-않은-문자열abc-비어-있지-않은-리스트1-2-3-비어-있지-않은-튜플1-2-3-등)
      - [거짓(False)의 경우: 0, 빈 문자열(""), 빈 리스트(\[\]), 빈 튜플(()), 빈 딕셔너리({}), None 등](#거짓false의-경우-0-빈-문자열-빈-리스트-빈-튜플-빈-딕셔너리-none-등)
  - [들여쓰기(Indent)의 중요성 🛠](#들여쓰기indent의-중요성-)
      - [파이썬에서는 코드의 구조를 나타내기 위해 들여쓰기를 사용.](#파이썬에서는-코드의-구조를-나타내기-위해-들여쓰기를-사용)
      - [이는 파이썬의 가독성을 높이는 중요한 요소 중 하나.](#이는-파이썬의-가독성을-높이는-중요한-요소-중-하나)
    - [예제: if문 사용 시 들여쓰기](#예제-if문-사용-시-들여쓰기)
    - [들여쓰기가 없는 경우](#들여쓰기가-없는-경우)
      - [들여쓰기는 일반적으로 공백 4개 또는 탭 1개를 사용.](#들여쓰기는-일반적으로-공백-4개-또는-탭-1개를-사용)
      - [파이썬 개발자들 사이에서는 공백 4개를 사용하는 것이 일반적인 규칙으로 받아들여짐.](#파이썬-개발자들-사이에서는-공백-4개를-사용하는-것이-일반적인-규칙으로-받아들여짐)
      - [들여쓰기는 블록을 나타내기 위해 사용.](#들여쓰기는-블록을-나타내기-위해-사용)
    - [예제 1: True는 항상 "Good"을 출력.](#예제-1-true는-항상-good을-출력)
      - [False는 실행되지 않으므로 "Bad"는 출력되지 않는다.](#false는-실행되지-않으므로-bad는-출력되지-않는다)
    - [예제 2: if-else 구문 사용하기](#예제-2-if-else-구문-사용하기)
  - [관계연산자란? 🤔](#관계연산자란-)
      - [파이썬에서 관계연산자는 두 값을 비교하는 데 사용.](#파이썬에서-관계연산자는-두-값을-비교하는-데-사용)
      - [비교의 결과는 항상 불리언 값(True 또는 False)으로 반환.](#비교의-결과는-항상-불리언-값true-또는-false으로-반환)
    - [다음은 파이썬의 관계연산자 종류:](#다음은-파이썬의-관계연산자-종류)
          - [\>  크다](#--크다)
          - [\>= 크거나 같다](#-크거나-같다)
          - [\<  작다](#--작다)
          - [\<= 작거나 같다](#-작거나-같다)
          - [== 같다](#-같다)
          - [!= 다르다](#-다르다)
    - [관계연산자 사용하기](#관계연산자-사용하기)
  - [참과 거짓 판별 in Python 🤖](#참과-거짓-판별-in-python-)
      - [파이썬에서는 값이 존재하거나`(True)` 또는 존재하지 않거나`(False)`를 기반으로 참과 거짓을 판별.](#파이썬에서는-값이-존재하거나true-또는-존재하지-않거나false를-기반으로-참과-거짓을-판별)
  - [참과 거짓 판별하기 🕵️‍♂️](#참과-거짓-판별하기-️️)
- [논리연산자 in Python 📘](#논리연산자-in-python-)
      - [논리연산자는 두 가지 이상의 조건을 비교할 때 사용. Python에서는 `and`, `or`, `not` 세 가지 논리연산자를 제공.](#논리연산자는-두-가지-이상의-조건을-비교할-때-사용-python에서는-and-or-not-세-가지-논리연산자를-제공)
    - [and 연산자 🤝](#and-연산자-)
- [- 모든 조건이 True일 때 True를 반환.](#--모든-조건이-true일-때-true를-반환)
- [예시:](#예시)
    - [or 연산자 🤷‍♂️](#or-연산자-️)
- [- 조건 중 하나라도 True라면 True를 반환.](#--조건-중-하나라도-true라면-true를-반환)
- [예시:](#예시-1)
    - [not 연산자 ❗](#not-연산자-)
- [- True를 False로, False를 True로 바꾼다.](#--true를-false로-false를-true로-바꾼다)
- [예시:](#예시-2)
  - [논리연산자 예시:](#논리연산자-예시)
        - [논리연산자는 프로그램의 조건문에서 복잡한 조건을 표현하는 데 매우 유용. 🛠️](#논리연산자는-프로그램의-조건문에서-복잡한-조건을-표현하는-데-매우-유용-️)
    - [논리연산자 사용하기 🧠](#논리연산자-사용하기-)
    - [연산자 우선순위 in Python 🚀](#연산자-우선순위-in-python-)
        - [Python에서 연산자의 우선순위는 매우 중요한 개념.](#python에서-연산자의-우선순위는-매우-중요한-개념)
      - [연산자의 우선순위는 산술연산자 ➡️ 관계연산자 ➡️ 논리연산자 순서로 적용.](#연산자의-우선순위는-산술연산자-️-관계연산자-️-논리연산자-순서로-적용)
      - [예시:](#예시-3)
    - [산술연산자 ➕➖✖️➗](#산술연산자-️)
    - [관계연산자 ➡️ 크기비교](#관계연산자-️-크기비교)
    - [논리연산자 ➡️ and, or, not](#논리연산자-️-and-or-not)
    - [💡 팁: 복잡한 표현식에서는 괄호()를 사용하여 연산의 순서를 명확히 할 수 있다.](#-팁-복잡한-표현식에서는-괄호를-사용하여-연산의-순서를-명확히-할-수-있다)
    - [사용 예시:](#사용-예시)
  - [다중 조건문과 중첩 조건문 활용하기 🌟](#다중-조건문과-중첩-조건문-활용하기-)
      - [여러 조건을 검사하여 해당하는 조건에 맞는 동작을 실행할 수 있다.](#여러-조건을-검사하여-해당하는-조건에-맞는-동작을-실행할-수-있다)
    - [다중 조건문 예시:](#다중-조건문-예시)
    - [중첩 조건문 예시:](#중첩-조건문-예시)
  - [`in`, `not in` 연산자를 통해 특정 값이 컨테이너 안에 존재하는지 확인할 수 있다.](#in-not-in-연산자를-통해-특정-값이-컨테이너-안에-존재하는지-확인할-수-있다)
- [코딩의 핵심: for 반복문 🔄](#코딩의-핵심-for-반복문-)
      - [for 반복문은 컬렉션(리스트, 튜플, 딕셔너리, 집합 등)의 각 요소에 대해 코드 블록을 반복 실행.](#for-반복문은-컬렉션리스트-튜플-딕셔너리-집합-등의-각-요소에-대해-코드-블록을-반복-실행)
    - [기본 구조:](#기본-구조)
    - [🔢 0부터 9까지 반복](#-0부터-9까지-반복)
    - [range() 함수는 지정된 범위의 숫자를 생성.](#range-함수는-지정된-범위의-숫자를-생성)
      - [예를 들어, `range(10)`은 `0`부터 `9`까지의 숫자를 생성.](#예를-들어-range10은-0부터-9까지의-숫자를-생성)
    - [🔢 1부터 10까지 반복](#-1부터-10까지-반복)
    - [range(시작, 종료)를 사용하여 특정 범위의 숫자를 생성.](#range시작-종료를-사용하여-특정-범위의-숫자를-생성)
      - [예를 들어, range(1, 11)은 1부터 10까지의 숫자를 생성.](#예를-들어-range1-11은-1부터-10까지의-숫자를-생성)
    - [🔢 1부터 10까지 2씩 증가시키며 반복 (홀수만 출력)](#-1부터-10까지-2씩-증가시키며-반복-홀수만-출력)
    - [range(시작, 종료, 단계)를 사용하여 특정 단계만큼 증가하는 숫자를 생성.](#range시작-종료-단계를-사용하여-특정-단계만큼-증가하는-숫자를-생성)
      - [예를 들어, `range(1, 11, 2)`는 `1`부터 시작해 `2`씩 증가하며 `11`이 되기 전까지의 숫자를 생성. 즉, 홀수만 생성.](#예를-들어-range1-11-2는-1부터-시작해-2씩-증가하며-11이-되기-전까지의-숫자를-생성-즉-홀수만-생성)
    - [➕ 1부터 1000까지의 합 계산](#-1부터-1000까지의-합-계산)
    - [1부터 1000까지 4의 배수의 합 계산하기 🔢](#1부터-1000까지-4의-배수의-합-계산하기-)
      - [range의 세 번째 인자로 4를 설정하여 4씩 증가시키며 4의 배수만 합계에 포함](#range의-세-번째-인자로-4를-설정하여-4씩-증가시키며-4의-배수만-합계에-포함)
  - [반복 가능한 자료형과 함수들 🔄](#반복-가능한-자료형과-함수들-)
      - [파이썬에서는 문자열, 리스트, 튜플, 집합, 사전과 같은 다양한 자료형을 반복할 수 있으며, 이를 위한 여러 내장 함수를 제공. 각 함수는 특정 작업을 수행하며 반복(iterable) 가능한 값을 반환.](#파이썬에서는-문자열-리스트-튜플-집합-사전과-같은-다양한-자료형을-반복할-수-있으며-이를-위한-여러-내장-함수를-제공-각-함수는-특정-작업을-수행하며-반복iterable-가능한-값을-반환)
  - [파이썬 for 반복문 실습 🔄](#파이썬-for-반복문-실습-)
    - [예제1: 리스트로 이름 출력하기 📋](#예제1-리스트로-이름-출력하기-)
      - [각 이름 앞에 "You are"를 붙여서 출력.](#각-이름-앞에-you-are를-붙여서-출력)
    - [예제2: 로또 번호 순회하기 🎱](#예제2-로또-번호-순회하기-)
      - [로또 번호를 하나씩 출력하며 행운의 숫자를 확인.](#로또-번호를-하나씩-출력하며-행운의-숫자를-확인)
    - [예제3: 문자열 순회하기 🆎](#예제3-문자열-순회하기-)
      - [`'Beautiful'` 이라는 단어의 각 문자를 하나씩 출력.](#beautiful-이라는-단어의-각-문자를-하나씩-출력)
    - [예제4: 딕셔너리 키와 값 순회하기 🔑](#예제4-딕셔너리-키와-값-순회하기-)
      - [딕셔너리에 저장된 정보(이름, 나이, 도시)를 키와 함께 출력.](#딕셔너리에-저장된-정보이름-나이-도시를-키와-함께-출력)
    - [예제5: 대소문자 변환하여 출력하기 🔠](#예제5-대소문자-변환하여-출력하기-)
      - [문자열에서 대문자는 그대로, 소문자는 대문자로 변환하여 출력.](#문자열에서-대문자는-그대로-소문자는-대문자로-변환하여-출력)
    - [break 사용 예제: 숫자 34 찾기 🚫](#break-사용-예제-숫자-34-찾기-)
      - [숫자 리스트를 순회하며 34를 찾으면 "Found : 34!"를 출력하고 반복을 종료.](#숫자-리스트를-순회하며-34를-찾으면-found--34를-출력하고-반복을-종료)
    - [continue 사용 예제: 타입과 값을 출력하기 🔠](#continue-사용-예제-타입과-값을-출력하기-)
      - [리스트 lt의 각 요소에 대해, 요소가 bool 타입이면 건너뛰고, 그렇지 않으면 타입과 값을 3배 한 결과를 출력.](#리스트-lt의-각-요소에-대해-요소가-bool-타입이면-건너뛰고-그렇지-않으면-타입과-값을-3배-한-결과를-출력)
    - [🔄 else 구문과 for 반복문 예제](#-else-구문과-for-반복문-예제)
      - [numbers 리스트 안에서 숫자 45를 찾는다.](#numbers-리스트-안에서-숫자-45를-찾는다)
      - [찾지 못하면 "Not Found 45..." 메시지를 출력.](#찾지-못하면-not-found-45-메시지를-출력)
    - [🧮 구구단 출력하기](#-구구단-출력하기)
      - [2단부터 9단까지 구구단을 출력. 각 값을 콘솔에 깔끔하게 정렬하기 위해 {:5d}를 사용.](#2단부터-9단까지-구구단을-출력-각-값을-콘솔에-깔끔하게-정렬하기-위해-5d를-사용)
    - [🔄 문자열 'Aceman' 변환하기 (변환예제)](#-문자열-aceman-변환하기-변환예제)
      - [문자열을 뒤집고, 리스트, 튜플, 집합으로 변환해 출력.](#문자열을-뒤집고-리스트-튜플-집합으로-변환해-출력)
- [🔄 파이썬에서의 While문](#-파이썬에서의-while문)
    - [🔄 While 기본 사용](#-while-기본-사용)
    - [🔄 While 기본 사용](#-while-기본-사용-1)
    - [🔄 While로 리스트 처리하기](#-while로-리스트-처리하기)
    - [🔚 Break 사용 예](#-break-사용-예)
    - [➡️ Continue 사용 예](#️-continue-사용-예)
    - [🔄 While - else 구문](#-while---else-구문)
    - [🔍 리스트에서 요소 찾기](#-리스트에서-요소-찾기)
    - [🔄 무한반복과 무한반복 탈출](#-무한반복과-무한반복-탈출)
- [Functions 함수 쌩 기초 이론 설명 📚](#functions-함수-쌩-기초-이론-설명-)
  - [🛠 파이썬 함수의 기초](#-파이썬-함수의-기초)
      - [함수는 특정 작업을 수행하는 코드의 묶음. 함수를 사용함으로써 코드의 재사용성을 높이고, 프로그램의 구조를 명확하게 할 수 있다.](#함수는-특정-작업을-수행하는-코드의-묶음-함수를-사용함으로써-코드의-재사용성을-높이고-프로그램의-구조를-명확하게-할-수-있다)
      - [함수](#함수)
      - [프로그래머가 이름을 통해서 정의 후 필요할 때 마다 호출](#프로그래머가-이름을-통해서-정의-후-필요할-때-마다-호출)
      - [반복 되는 코드를 한 번 구현 후 재사용 가능한 코드의 집합](#반복-되는-코드를-한-번-구현-후-재사용-가능한-코드의-집합)
      - [함수 구현 -\> 재사용, 루틴(프로시저, 서브루틴)](#함수-구현---재사용-루틴프로시저-서브루틴)
  - [📚 함수의 정의와 호출](#-함수의-정의와-호출)
  - [📖 함수의 종류](#-함수의-종류)
  - [🎯 예제로 함수 이해하기](#-예제로-함수-이해하기)
    - [예제 1: 매개변수 필요 없는 함수](#예제-1-매개변수-필요-없는-함수)
    - [예제 2: 매개변수 필요한 함수](#예제-2-매개변수-필요한-함수)
    - [예제 3: 결과값 반환하지 않는 함수](#예제-3-결과값-반환하지-않는-함수)
    - [예제 4: 결과값을 반환하는 함수](#예제-4-결과값을-반환하는-함수)
  - [🚀 함수 실행하기](#-함수-실행하기)
    - [함수를 호출하려면 함수 이름 뒤에 괄호를 붙이고, 필요한 경우 괄호 안에 매개변수의 값을 넣는다.](#함수를-호출하려면-함수-이름-뒤에-괄호를-붙이고-필요한-경우-괄호-안에-매개변수의-값을-넣는다)
      - [함수를 통해 코드의 재사용성을 높이고, 효율적으로 프로그램을 작성해보자! 🌈](#함수를-통해-코드의-재사용성을-높이고-효율적으로-프로그램을-작성해보자-)
- [🚀 파이썬 함수 및 입력 🚀](#-파이썬-함수-및-입력-)
  - [📖 파이썬 함수 사용법 📖](#-파이썬-함수-사용법-)
    - [함수의 중요성 🌟🌟🌟](#함수의-중요성-)
      - [1. 코드의 재사용성(Reusability) 🎈](#1-코드의-재사용성reusability-)
      - [함수를 사용하면 특정 기능을 수행하는 코드 블록을 한 번 작성해두고, 필요할 때마다 여러 곳에서 호출하여 사용할 수 있다. 이는 프로그램 전체에서 코드의 중복을 방지하고, 개발 시간을 절약할 수 있게 해준다. 예를 들어, 데이터 유효성 검사를 여러 곳에서 수행해야 한다면, 해당 로직을 함수로 만들어 두고 필요할 때마다 재사용할 수 있다.](#함수를-사용하면-특정-기능을-수행하는-코드-블록을-한-번-작성해두고-필요할-때마다-여러-곳에서-호출하여-사용할-수-있다-이는-프로그램-전체에서-코드의-중복을-방지하고-개발-시간을-절약할-수-있게-해준다-예를-들어-데이터-유효성-검사를-여러-곳에서-수행해야-한다면-해당-로직을-함수로-만들어-두고-필요할-때마다-재사용할-수-있다)
      - [2. 큰 프로그램의 설계와 개발 용이성 🎈](#2-큰-프로그램의-설계와-개발-용이성-)
      - [큰 규모의 프로그램을 개발할 때, 함수 단위로 설계하고 개발하면 프로젝트를 더욱 체계적으로 관리할 수 있다. 함수는 프로그램의 구성 요소를 논리적으로 분리하여, 각 부분의 역할과 책임을 명확히 할 수 있게 해준다. 이는 코드의 가독성을 높이고, 팀 내에서의 협업을 용이하게 한다. 또한, 프로그램의 각 부분을 독립적으로 테스트하고 디버깅할 수 있어, 전체 프로젝트의 안정성과 품질을 향상시킬 수 있다.](#큰-규모의-프로그램을-개발할-때-함수-단위로-설계하고-개발하면-프로젝트를-더욱-체계적으로-관리할-수-있다-함수는-프로그램의-구성-요소를-논리적으로-분리하여-각-부분의-역할과-책임을-명확히-할-수-있게-해준다-이는-코드의-가독성을-높이고-팀-내에서의-협업을-용이하게-한다-또한-프로그램의-각-부분을-독립적으로-테스트하고-디버깅할-수-있어-전체-프로젝트의-안정성과-품질을-향상시킬-수-있다)
      - [3. 에러 수정의 용이성 및 코드의 안전성 🎈](#3-에러-수정의-용이성-및-코드의-안전성-)
      - [함수는 프로그램의 다른 부분과 격리된 채로 동작하기 때문에, 오류가 발생했을 때 해당 함수 내부에서 문제를 찾아 수정하기가 더욱 쉽다. 이는 디버깅 시간을 단축시켜주고, 프로그램의 전체적인 안정성을 유지하는 데 도움을 준다. 또한, 함수는 외부에서 접근할 수 있는 인터페이스(매개변수와 반환값)만을 제공하므로, 내부 구현을 숨길 수 있다. 이는 캡슐화의 원칙을 강화하여, 프로그램의 안전성을 높이는 데 기여한다.](#함수는-프로그램의-다른-부분과-격리된-채로-동작하기-때문에-오류가-발생했을-때-해당-함수-내부에서-문제를-찾아-수정하기가-더욱-쉽다-이는-디버깅-시간을-단축시켜주고-프로그램의-전체적인-안정성을-유지하는-데-도움을-준다-또한-함수는-외부에서-접근할-수-있는-인터페이스매개변수와-반환값만을-제공하므로-내부-구현을-숨길-수-있다-이는-캡슐화의-원칙을-강화하여-프로그램의-안전성을-높이는-데-기여한다)
        - [함수를 사용하는 것은 단순히 코드를 재사용하기 위한 목적뿐만 아니라, 프로그램의 설계와 구현, 유지 보수의 효율성을 높이는 데 필수적인 요소이다. 프로그램의 복잡성을 관리하고, 팀으로 협업하는 프로젝트에서 더욱 체계적으로 작업할 수 있게 해주며, 최종적으로는 더 나은 소프트웨어를 만드는 데 기여한다. 🚀](#함수를-사용하는-것은-단순히-코드를-재사용하기-위한-목적뿐만-아니라-프로그램의-설계와-구현-유지-보수의-효율성을-높이는-데-필수적인-요소이다-프로그램의-복잡성을-관리하고-팀으로-협업하는-프로젝트에서-더욱-체계적으로-작업할-수-있게-해주며-최종적으로는-더-나은-소프트웨어를-만드는-데-기여한다-)
    - [함수 네이밍](#함수-네이밍)
    - [1️⃣ 풀 네임 사용](#1️⃣-풀-네임-사용)
      - [함수 이름으로 그 기능을 자세히 설명하는 방식. 예를 들어, 어떤 리스트에서 최대 값을 찾는 함수는 find\_maximum\_value와 같이 명명할 수 있다. 이 방식의 장점은 함수 이름만 보고도 함수의 역할을 명확하게 알 수 있다는 것이다. 코드의 가독성이 높아지며, 프로젝트가 복잡해질수록 이해하기 쉬운 코드를 유지할 수 있다.](#함수-이름으로-그-기능을-자세히-설명하는-방식-예를-들어-어떤-리스트에서-최대-값을-찾는-함수는-find_maximum_value와-같이-명명할-수-있다-이-방식의-장점은-함수-이름만-보고도-함수의-역할을-명확하게-알-수-있다는-것이다-코드의-가독성이-높아지며-프로젝트가-복잡해질수록-이해하기-쉬운-코드를-유지할-수-있다)
    - [2️⃣ 축약형 사용](#2️⃣-축약형-사용)
      - [함수 이름을 간단하게 축약하여 사용하는 방식이다. 예를 들어, `calculate_total_sum` 함수를 `calc_sum`과 같이 축약해서 명명할 수 있습니다. 축약형은 코드를 더 간결하게 만들어 줄 수 있지만, 함수의 역할을 명확하게 파악하기 어려울 수도 있다. 따라서, 널리 알려진 축약어나 팀 내에서 이미 정의된 축약어를 사용할 때 효과적이다.](#함수-이름을-간단하게-축약하여-사용하는-방식이다-예를-들어-calculate_total_sum-함수를-calc_sum과-같이-축약해서-명명할-수-있습니다-축약형은-코드를-더-간결하게-만들어-줄-수-있지만-함수의-역할을-명확하게-파악하기-어려울-수도-있다-따라서-널리-알려진-축약어나-팀-내에서-이미-정의된-축약어를-사용할-때-효과적이다)
    - [📌 결론](#-결론)
      - [함수의 이름을 결정할 때는 해당 함수의 역할, 팀 내의 네이밍 규칙, 코드의 일관성 등을 고려해야 합니다. 풀 네임을 사용하면 함수의 역할을 명확히 알 수 있어 코드의 이해도가 높아지는 반면, 축약형은 코드를 간결하게 유지할 수 있는 장점이 있다. 중요한 것은 프로젝트 내에서 일관된 규칙을 정하고 따르는 것이다. 🌈](#함수의-이름을-결정할-때는-해당-함수의-역할-팀-내의-네이밍-규칙-코드의-일관성-등을-고려해야-합니다-풀-네임을-사용하면-함수의-역할을-명확히-알-수-있어-코드의-이해도가-높아지는-반면-축약형은-코드를-간결하게-유지할-수-있는-장점이-있다-중요한-것은-프로젝트-내에서-일관된-규칙을-정하고-따르는-것이다-)
    - [함수 선언 및 사용](#함수-선언-및-사용)
    - [1️⃣ 기본 함수 정의와 호출](#1️⃣-기본-함수-정의와-호출)
      - [함수는 `def` 키워드로 정의되며, 실행할 코드 블록을 포함하고. 함수를 호출하려면 함수 이름과 괄호(())를 사용하고, 필요한 경우 괄호 안에 인자를 제공한다.](#함수는-def-키워드로-정의되며-실행할-코드-블록을-포함하고-함수를-호출하려면-함수-이름과-괄호를-사용하고-필요한-경우-괄호-안에-인자를-제공한다)
      - [이 예제에서 `first_func` 함수는 인자 `w1`을 받아, `"Hello,"`와 함께 출력.](#이-예제에서-first_func-함수는-인자-w1을-받아-hello와-함께-출력)
    - [2️⃣ 값 반환하기](#2️⃣-값-반환하기)
      - [함수는 `return` 키워드를 사용하여 값을 반환할 수 있다. 반환된 값은 함수를 호출한 곳에서 사용할 수 있다.](#함수는-return-키워드를-사용하여-값을-반환할-수-있다-반환된-값은-함수를-호출한-곳에서-사용할-수-있다)
      - [`return_func` 함수는 주어진 인자 `w1`에 `"Hello,"`를 붙여 반환.](#return_func-함수는-주어진-인자-w1에-hello를-붙여-반환)
    - [3️⃣ 다중 값을 반환하기](#3️⃣-다중-값을-반환하기)
      - [파이썬에서 함수는 여러 값을 한 번에 반환할 수 있으며, 이는 튜플의 형태로 반환.](#파이썬에서-함수는-여러-값을-한-번에-반환할-수-있으며-이는-튜플의-형태로-반환)
      - [`func_mul` 함수는 인자 `x`에 대해 세 가지 연산을 수행하고, 세 개의 결과를 한 번에 반환.](#func_mul-함수는-인자-x에-대해-세-가지-연산을-수행하고-세-개의-결과를-한-번에-반환)
    - [4️⃣ 다양한 타입 반환하기](#4️⃣-다양한-타입-반환하기)
      - [함수는 튜플, 리스트, 딕셔너리 등 다양한 타입의 값을 반환할 수 있다.](#함수는-튜플-리스트-딕셔너리-등-다양한-타입의-값을-반환할-수-있다)
      - [튜플 반환](#튜플-반환)
      - [리스트 반환](#리스트-반환)
      - [딕셔너리 반환](#딕셔너리-반환)
  - [📦 \*args 사용하기: 여러 위치 인자를 튜플로 처리하기](#-args-사용하기-여러-위치-인자를-튜플로-처리하기)
      - [`*args`는 함수에 여러 개의 위치 인자를 전달할 수 있게 해주며, 이러한 인자들을 함수 내에서 튜플`(tuple)` 형태로 다룹니다. 이 기능은 특히 함수에 전달되는 인자의 개수가 가변적일 때 유용.](#args는-함수에-여러-개의-위치-인자를-전달할-수-있게-해주며-이러한-인자들을-함수-내에서-튜플tuple-형태로-다룹니다-이-기능은-특히-함수에-전달되는-인자의-개수가-가변적일-때-유용)
      - [🔹 \*args를 사용함으로써 함수는 다양한 개수의 위치 인자들을 유연하게 받아 처리할 수 있으며, 이 인자들은 함수 내에서 `tuple`로 관리.](#-args를-사용함으로써-함수는-다양한-개수의-위치-인자들을-유연하게-받아-처리할-수-있으며-이-인자들은-함수-내에서-tuple로-관리)
  - [📑 \*\*kwargs 사용하기: 여러 키워드 인자를 딕셔너리로 처리하기](#-kwargs-사용하기-여러-키워드-인자를-딕셔너리로-처리하기)
      - [`**kwargs`는 함수에 이름이 지정된 키워드 인자를 임의의 개수만큼 받을 수 있게 해주며, 이 인자들을 딕셔너리(`dictionary`) 형태로 함수 내부에서 처리. 이를 통해 각 인자의 이름을 키(`key`)로, 인자의 값을 값(`value`)으로 가지는 딕셔너리가 생성.](#kwargs는-함수에-이름이-지정된-키워드-인자를-임의의-개수만큼-받을-수-있게-해주며-이-인자들을-딕셔너리dictionary-형태로-함수-내부에서-처리-이를-통해-각-인자의-이름을-키key로-인자의-값을-값value으로-가지는-딕셔너리가-생성)
      - [🔹 `**kwargs`를 사용하면, 함수는 인자의 이름을 알고 있는 상태에서, 이들을 딕셔너리 형태로 유연하게 처리할 수 있다. 함수 내에서는 이 딕셔너리를 통해 인자들에 접근하고 사용할 수 있다.](#-kwargs를-사용하면-함수는-인자의-이름을-알고-있는-상태에서-이들을-딕셔너리-형태로-유연하게-처리할-수-있다-함수-내에서는-이-딕셔너리를-통해-인자들에-접근하고-사용할-수-있다)
    - [enumerate의 기본 구조](#enumerate의-기본-구조)
      - [`enumerate`는 파이썬의 내장 함수로, 순회 가능한`(iterable) `데이터 구조(예: 리스트, 튜플, 문자열 등)를 인덱스와 함께 순회할 수 있게 해주는 함수. 이를 통해 반복문을 사용할 때 요소의 값을 뿐만 아니라, 해당 요소의 위치`(Index)`도 함께 얻을 수 있습니다. 이는 특히 리스트 같은 시퀀스를 순회할 때 매우 유용하며, 코드를 더 읽기 쉽고, 관리하기 쉽게 만들어 준다.](#enumerate는-파이썬의-내장-함수로-순회-가능한iterable-데이터-구조예-리스트-튜플-문자열-등를-인덱스와-함께-순회할-수-있게-해주는-함수-이를-통해-반복문을-사용할-때-요소의-값을-뿐만-아니라-해당-요소의-위치index도-함께-얻을-수-있습니다-이는-특히-리스트-같은-시퀀스를-순회할-때-매우-유용하며-코드를-더-읽기-쉽고-관리하기-쉽게-만들어-준다)
    - [사용 예시](#사용-예시-1)
      - [예를 들어, 리스트의 각 요소와 해당 요소의 인덱스를 출력하고 싶을 때 `enumerate` 함수를 사용할 수 있다.](#예를-들어-리스트의-각-요소와-해당-요소의-인덱스를-출력하고-싶을-때-enumerate-함수를-사용할-수-있다)
      - [이 코드에서 `enumerate(fruits)`는 `fruits` 리스트의 각 요소와 그 요소의 인덱스를 튜플 형태로 반환합니다. `for`반복문에서 이를 `index`와 `fruit` 변수로 받아서 사용. 이 방법을 사용하면, 리스트의 인덱스를 수동으로 관리할 필요 없이 각 요소의 값을 쉽게 접근할 수 있다.](#이-코드에서-enumeratefruits는-fruits-리스트의-각-요소와-그-요소의-인덱스를-튜플-형태로-반환합니다-for반복문에서-이를-index와-fruit-변수로-받아서-사용-이-방법을-사용하면-리스트의-인덱스를-수동으로-관리할-필요-없이-각-요소의-값을-쉽게-접근할-수-있다)
    - [시작 번호 지정하기](#시작-번호-지정하기)
      - [`enumerate` 함수의`start`매개변수를 사용하여 인덱스의 시작 번호를 지정할 수도 있다. 예를 들어, 인덱스를 1부터 시작하게 하고 싶은 경우 다음과 같이 작성할 수 있다.](#enumerate-함수의start매개변수를-사용하여-인덱스의-시작-번호를-지정할-수도-있다-예를-들어-인덱스를-1부터-시작하게-하고-싶은-경우-다음과-같이-작성할-수-있다)
      - [이렇게 `enumerate` 함수는 반복문에서 요소의 인덱스를 함께 사용하고자 할 때 매우 유용한 도구다.](#이렇게-enumerate-함수는-반복문에서-요소의-인덱스를-함께-사용하고자-할-때-매우-유용한-도구다)
  - [전체 혼합 사용하기 🎉](#전체-혼합-사용하기-)
      - [이 예제에서는 Python 함수가 어떻게 고정 인자, 가변 인자(\*args), 그리고 키워드 가변 인자(\*\*kwargs)를 동시에 다룰 수 있는지 보여준다\`.](#이-예제에서는-python-함수가-어떻게-고정-인자-가변-인자args-그리고-키워드-가변-인자kwargs를-동시에-다룰-수-있는지-보여준다)
    - [각 부분 설명 📚](#각-부분-설명-)
      - [예제에서 args\_1에는 10이, args\_2에는 20이 할당.](#예제에서-args_1에는-10이-args_2에는-20이-할당)
      - [\*args (가변 위치 인자): 함수 호출 시 정해진 위치 인자 이외의 추가적인 인자들을 받는다. 이들은 함수 내부에서 튜플(args)로 처리.](#args-가변-위치-인자-함수-호출-시-정해진-위치-인자-이외의-추가적인-인자들을-받는다-이들은-함수-내부에서-튜플args로-처리)
      - [예제에서 'Lee', 'Kim', 'Park', 'Cho'가 args 튜플에 할당.](#예제에서-lee-kim-park-cho가-args-튜플에-할당)
      - [\*\*kwargs (키워드 가변 인자): 이름이 지정된 인자들을 함수 호출 시 추가할 수 있으며, 이들은 함수 내에서 딕셔너리(kwargs)로 처리됨.](#kwargs-키워드-가변-인자-이름이-지정된-인자들을-함수-호출-시-추가할-수-있으며-이들은-함수-내에서-딕셔너리kwargs로-처리됨)
      - [예제에서 age1=20, age2=30, age3=40이 kwargs 딕셔너리에 할당.](#예제에서-age120-age230-age340이-kwargs-딕셔너리에-할당)
      - [함수 호출 결과 📢](#함수-호출-결과-)
      - [함수를 호출하면 다음과 같은 출력:](#함수를-호출하면-다음과-같은-출력)
      - [10과 20은 고정 위치 인자 args\_1과 args\_2에 할당된 값.](#10과-20은-고정-위치-인자-args_1과-args_2에-할당된-값)
      - [('Lee', 'Kim', 'Park', 'Cho')는 \*args를 통해 전달된 추가적인 위치 인자들의 튜플.](#lee-kim-park-cho는-args를-통해-전달된-추가적인-위치-인자들의-튜플)
      - [{'age1': 20, 'age2': 30, 'age3': 40}은 \*\*kwargs를 통해 전달된 키워드 인자들의 딕셔너리.](#age1-20-age2-30-age3-40은-kwargs를-통해-전달된-키워드-인자들의-딕셔너리)
  - [중첩 함수란? 🤔](#중첩-함수란-)
      - [중첩 함수(`Nested Function`)란, 하나의 함수 내부에 다른 함수가 정의되어 있는 형태. 이 구조를 사용하면, 내부 함수는 외부 함수의 변수 및 인자에 접근할 수 있으며, 코드를 모듈화하여 가독성과 재사용성을 높일 수 있다.](#중첩-함수nested-function란-하나의-함수-내부에-다른-함수가-정의되어-있는-형태-이-구조를-사용하면-내부-함수는-외부-함수의-변수-및-인자에-접근할-수-있으며-코드를-모듈화하여-가독성과-재사용성을-높일-수-있다)
    - [예제 설명 📖](#예제-설명-)
      - [외부 함수 nested\_func: 이 함수는 num이라는 인자를 받고, 내부에 func\_in\_func라는 또 다른 함수를 정의하고 있다. 외부 함수에서는 "In func"이라는 메시지를 출력한 후, 내부 함수를 호출하면서 인자로 num + 100을 전달.](#외부-함수-nested_func-이-함수는-num이라는-인자를-받고-내부에-func_in_func라는-또-다른-함수를-정의하고-있다-외부-함수에서는-in-func이라는-메시지를-출력한-후-내부-함수를-호출하면서-인자로-num--100을-전달)
      - [내부 함수 func\_in\_func: 이 함수는 외부 함수로부터 받은 인자를 출력하는 역할을 함. 내부 함수는 외부 함수의 스코프에 접근할 수 있으므로, 외부 함수에서 전달된 데이터를 사용하거나 변경할 수 있다.](#내부-함수-func_in_func-이-함수는-외부-함수로부터-받은-인자를-출력하는-역할을-함-내부-함수는-외부-함수의-스코프에-접근할-수-있으므로-외부-함수에서-전달된-데이터를-사용하거나-변경할-수-있다)
      - [중첩 함수의 특징 🌈](#중첩-함수의-특징-)
      - [캡슐화: 내부 함수는 외부에서 직접 호출할 수 없다. 즉, func\_in\_func(1000)과 같은 방식으로 외부에서 호출하려고 하면 에러가 발생. 이는 내부 함수가 외부 함수의 로직을 숨기고, 필요한 기능만을 외부에 노출시켜 캡슐화를 실현.](#캡슐화-내부-함수는-외부에서-직접-호출할-수-없다-즉-func_in_func1000과-같은-방식으로-외부에서-호출하려고-하면-에러가-발생-이는-내부-함수가-외부-함수의-로직을-숨기고-필요한-기능만을-외부에-노출시켜-캡슐화를-실현)
      - [스코프: 내부 함수는 외부 함수의 변수와 인자에 접근할 수 있다. 이는 어떤 데이터를 함수 간에 공유하고 싶을 때 유용.](#스코프-내부-함수는-외부-함수의-변수와-인자에-접근할-수-있다-이는-어떤-데이터를-함수-간에-공유하고-싶을-때-유용)
      - [이처럼 중첩 함수는 함수 내부의 로직을 모듈화하고, 외부에서의 접근을 제한하여 코드의 안정성을 높이는 데 도움을 준다. 또한, 특정 함수 로직을 한 곳에 집중시켜 가독성과 유지보수성을 향상시킬 수 있다. 🚀](#이처럼-중첩-함수는-함수-내부의-로직을-모듈화하고-외부에서의-접근을-제한하여-코드의-안정성을-높이는-데-도움을-준다-또한-특정-함수-로직을-한-곳에-집중시켜-가독성과-유지보수성을-향상시킬-수-있다-)
  - [람다 함수란? 🤔](#람다-함수란-)
      - [람다 함수(`lambda function`)는 파이썬에서 간단한 함수를 한 줄로 표현할 수 있게 해주는 기능. 주로 간단한 연산이나 함수를 인자로 넘길 때 사용되며, 코드를 간결하게 만들 수 있다.](#람다-함수lambda-function는-파이썬에서-간단한-함수를-한-줄로-표현할-수-있게-해주는-기능-주로-간단한-연산이나-함수를-인자로-넘길-때-사용되며-코드를-간결하게-만들-수-있다)
    - [기본 구조 🏗️](#기본-구조-️)
      - [매개변수는 콤마(,)로 구분하여 여러 개를 지정할 수 있습니다.](#매개변수는-콤마로-구분하여-여러-개를-지정할-수-있습니다)
      - [콜론(:) 뒤에는 이 함수가 반환할 표현식을 작성합니다.](#콜론-뒤에는-이-함수가-반환할-표현식을-작성합니다)
    - [예제 코드 🔍](#예제-코드-)
      - [위 예제에서 `mul_func` 함수는 두 매개변수를 받아 곱한 결과를 반환하는 일반적인 함수.](#위-예제에서-mul_func-함수는-두-매개변수를-받아-곱한-결과를-반환하는-일반적인-함수)
      - [a에 할당된 람다 함수는 동일하게 두 매개변수를 받아 곱한 결과를 반환하지만, 한 줄로 간결하게 표현되어 있다.](#a에-할당된-람다-함수는-동일하게-두-매개변수를-받아-곱한-결과를-반환하지만-한-줄로-간결하게-표현되어-있다)
    - [람다 함수 사용하기 🚀](#람다-함수-사용하기-)
      - [a(5, 6)을 호출하면, 람다 함수가 실행되어 5와 6을 곱한 결과인 30이 출력됨.](#a5-6을-호출하면-람다-함수가-실행되어-5와-6을-곱한-결과인-30이-출력됨)
    - [장단점 📊](#장단점-)
    - [메모리 관리 💾](#메모리-관리-)
    - [일반 함수 예제 📝](#일반-함수-예제-)
    - [람다 함수 예제 🚀](#람다-함수-예제-)
    - [함수와 람다의 차이점 🌟](#함수와-람다의-차이점-)
      - [이 코드에서 사용된 `Hint`는 파이썬의 타입 힌트(`Type Hint`) 기능을 사용한 것. 타입 힌트는 파이썬 3.5 이상부터 사용할 수 있으며, 함수의 매개변수와 반환값에 예상되는 타입을 명시적으로 선언할 수 있게 한다. 코드의 가독성을 높이고, 개발자가 의도한 데이터 타입을 명확히 전달하기 위해 사용. 📘✏️](#이-코드에서-사용된-hint는-파이썬의-타입-힌트type-hint-기능을-사용한-것-타입-힌트는-파이썬-35-이상부터-사용할-수-있으며-함수의-매개변수와-반환값에-예상되는-타입을-명시적으로-선언할-수-있게-한다-코드의-가독성을-높이고-개발자가-의도한-데이터-타입을-명확히-전달하기-위해-사용-️)
    - [타입 힌트 사용 예시 📝](#타입-힌트-사용-예시-)
    - [함수 호출 예시](#함수-호출-예시)
    - [또 다른 함수 호출 예시](#또-다른-함수-호출-예시)
    - [Hint가 중요한 이유 🌟](#hint가-중요한-이유-)
    - [주의할 점 ⚠️](#주의할-점-️)
      - [파이썬은 동적 타입 언어이기 때문에, 타입 힌트는 강제되지 않는다. 즉, 타입 힌트와 다른 타입의 데이터가 전달되더라도 실행 시 오류가 발생하지 않는다. 타입 힌트는 개발자의 의도를 명확히 전달하기 위한 수단이며, 코드의 가독성과 안정성을 높이는 데 도움을 준다. 🚀](#파이썬은-동적-타입-언어이기-때문에-타입-힌트는-강제되지-않는다-즉-타입-힌트와-다른-타입의-데이터가-전달되더라도-실행-시-오류가-발생하지-않는다-타입-힌트는-개발자의-의도를-명확히-전달하기-위한-수단이며-코드의-가독성과-안정성을-높이는-데-도움을-준다-)
- [📥 파이썬 사용자 입력: input 사용법 및 기본 타입(str) 📥](#-파이썬-사용자-입력-input-사용법-및-기본-타입str-)
  - [📌 예제1: 기본적인 사용자 입력 받기 🖊️](#-예제1-기본적인-사용자-입력-받기-️)
      - [이 예제는 사용자에게 이름, 등급, 회사 이름을 순서대로 입력받아 화면에 출력.](#이-예제는-사용자에게-이름-등급-회사-이름을-순서대로-입력받아-화면에-출력)
  - [📌 예제2: 입력된 데이터의 타입 확인하기 🔍](#-예제2-입력된-데이터의-타입-확인하기-)
      - [입력받은 number와 name이 문자열(str)임을 확인하고, number에 대해 문자열 반복을 시도.](#입력받은-number와-name이-문자열str임을-확인하고-number에-대해-문자열-반복을-시도)
  - [📌 예제3: 문자열 입력을 숫자로 변환하여 계산하기 🔢](#-예제3-문자열-입력을-숫자로-변환하여-계산하기-)
      - [사용자의 입력을 정수(int)로 변환하여 더하는 방법을 보여줌.](#사용자의-입력을-정수int로-변환하여-더하는-방법을-보여줌)
  - [📌 예제4: 실수 입력 받기 🌊](#-예제4-실수-입력-받기-)
      - [입력받은 값을 실수(float)로 변환하고, 이를 출력하여 확인.](#입력받은-값을-실수float로-변환하고-이를-출력하여-확인)
  - [📌 예제5: format() 함수와 함께 입력받아 출력하기 🖨️](#-예제5-format-함수와-함께-입력받아-출력하기-️)
      - [사용자로부터 입력 받은 데이터를 바로 format() 함수에 적용해 출력하는 방법.](#사용자로부터-입력-받은-데이터를-바로-format-함수에-적용해-출력하는-방법)
      - [이렇게 각 예제에 이모지를 추가하여 설명. 이를 통해 `input()` 함수의 다양한 활용 방법을 보다 쉽게 이해하실 수 있고. 사용자로부터 데이터를 입력받고, 이를 프로그램 내에서 다루는 방법은 프로그래밍에서 매우 중요한 부분이다. 🌟](#이렇게-각-예제에-이모지를-추가하여-설명-이를-통해-input-함수의-다양한-활용-방법을-보다-쉽게-이해하실-수-있고-사용자로부터-데이터를-입력받고-이를-프로그램-내에서-다루는-방법은-프로그래밍에서-매우-중요한-부분이다-)
  - [🛠 Input 사용법(2023년) - 기본 타입(str)](#-input-사용법2023년---기본-타입str)
  - [예제1 -\> 예외처리 🚫](#예제1---예외처리-)
      - [사용자가 숫자를 입력해야 하는 상황에서 문자열 등 숫자가 아닌 다른 타입의 데이터를 입력했을 때 오류를 방지하는 방법.](#사용자가-숫자를-입력해야-하는-상황에서-문자열-등-숫자가-아닌-다른-타입의-데이터를-입력했을-때-오류를-방지하는-방법)
      - [`try` 블록 안에서 사용자로부터 입력 받은 값`(input())을 정수(int)`로 변환.](#try-블록-안에서-사용자로부터-입력-받은-값input을-정수int로-변환)
      - [만약 사용자가 숫자가 아닌 다른 값을 입력하면, `ValueError` 예외가 발생하고 `except` 블록이 실행.](#만약-사용자가-숫자가-아닌-다른-값을-입력하면-valueerror-예외가-발생하고-except-블록이-실행)
  - [예제2 -\> 올바른 값 입력 완료까지 지속 🔁](#예제2---올바른-값-입력-완료까지-지속-)
      - [사용자가 올바른 형태의 숫자를 입력할 때까지 계속해서 입력을 요청하는 방법.](#사용자가-올바른-형태의-숫자를-입력할-때까지-계속해서-입력을-요청하는-방법)
      - [`while True`를 통해 무한 루프를 시작하고, 사용자로부터 올바른 형태의 입력(여기서는 숫자)을 받을 때까지 반복.](#while-true를-통해-무한-루프를-시작하고-사용자로부터-올바른-형태의-입력여기서는-숫자을-받을-때까지-반복)
      - [try 블록에서 입력 받은 값을 정수로 변환을 시도.](#try-블록에서-입력-받은-값을-정수로-변환을-시도)
      - [숫자로 정상 변환되면 `break`를 통해 루프를 종료.](#숫자로-정상-변환되면-break를-통해-루프를-종료)
      - [`ValueError` 예외가 발생하면, 즉 사용자가 숫자가 아닌 값을 입력하면, 사용자에게 오류 메시지를 출력하고 다시 입력을 요청.](#valueerror-예외가-발생하면-즉-사용자가-숫자가-아닌-값을-입력하면-사용자에게-오류-메시지를-출력하고-다시-입력을-요청)
      - [이러한 방식으로 `try`와 `except`를 사용하여 입력 값의 유효성 검사를 할 수 있으며, 사용자로부터 올바른 형태의 데이터를 안전하게 입력받을 수 있다. 🛡️🔄](#이러한-방식으로-try와-except를-사용하여-입력-값의-유효성-검사를-할-수-있으며-사용자로부터-올바른-형태의-데이터를-안전하게-입력받을-수-있다-️)
- [전반부 복습 🔄📖](#전반부-복습-)
  - [print 함수와 포맷팅 🖨️🎨](#print-함수와-포맷팅-️)
    - [3가지 Print Formatting:](#3가지-print-formatting)
  - [변수와 예약어 📦🚫](#변수와-예약어-)
      - [참조 유형:](#참조-유형)
  - [파이썬 자료형과 연산자 🔢✖️](#파이썬-자료형과-연산자-️)
  - [파이썬 문자형 사용 📝](#파이썬-문자형-사용-)
  - [리스트의 특징과 활용 📋](#리스트의-특징과-활용-)
  - [튜플의 이해와 활용 📌](#튜플의-이해와-활용-)
  - [딕셔너리의 특징과 활용 📖](#딕셔너리의-특징과-활용-)
    - [딕셔너리 (Dictionary) 🔑](#딕셔너리-dictionary-)
      - [딕셔너리는 키(key)와 값(value)의 쌍으로 이루어진 데이터 구조입니다. Python 3.7 이상에서는 요소들이 추가된 순서를 기억하며, 이를 통해 데이터에 빠르고 순차적으로 접근할 수 있다. 이는 코드의 예측 가능성과 읽기 쉬움을 향상.](#딕셔너리는-키key와-값value의-쌍으로-이루어진-데이터-구조입니다-python-37-이상에서는-요소들이-추가된-순서를-기억하며-이를-통해-데이터에-빠르고-순차적으로-접근할-수-있다-이는-코드의-예측-가능성과-읽기-쉬움을-향상)
    - [딕셔너리 활용 ➕➖](#딕셔너리-활용-)
    - [순서의 중요성 🚀](#순서의-중요성-)
      - [Python 3.7 이전에는 딕셔너리의 순서가 무작위로 보였으나, Python 3.7 이후 버전에서는 딕셔너리가 요소를 추가한 순서를 유지. 이로 인해 순서가 중요한 작업에서도 딕셔너리를 사용할 수 있게 되었다. 예를 들어, 데이터를 순차적으로 출력하거나 순서에 의존하는 작업을 할 때 유용.](#python-37-이전에는-딕셔너리의-순서가-무작위로-보였으나-python-37-이후-버전에서는-딕셔너리가-요소를-추가한-순서를-유지-이로-인해-순서가-중요한-작업에서도-딕셔너리를-사용할-수-있게-되었다-예를-들어-데이터를-순차적으로-출력하거나-순서에-의존하는-작업을-할-때-유용)
  - [집합(Sets)의 특성과 변환 🎲](#집합sets의-특성과-변환-)
  - [파이썬 제어문 - IF문 🚦](#파이썬-제어문---if문-)
  - [반복문 - FOR문 🔁](#반복문---for문-)
  - [반복문 - while문 ⏳](#반복문---while문-)
  - [파이썬 함수의 정의와 람다 함수 🛠️](#파이썬-함수의-정의와-람다-함수-️)
  - [사용자 입력과 예외 처리 📥🛡️](#사용자-입력과-예외-처리-️)
- [🐍 파이썬 클래스와 OOP 🔄](#-파이썬-클래스와-oop-)
      - [객체 지향 프로그래밍(OOP, Object-Oriented Programming)은 프로그램을 여러 개의 독립된 객체들의 모임으로 파악하고자 하는 프로그래밍 패러다임. 파이썬에서 클래스는 OOP의 핵심 요소로, 데이터와 기능을 함께 묶어 관리할 수 있게 한다.](#객체-지향-프로그래밍oop-object-oriented-programming은-프로그램을-여러-개의-독립된-객체들의-모임으로-파악하고자-하는-프로그래밍-패러다임-파이썬에서-클래스는-oop의-핵심-요소로-데이터와-기능을-함께-묶어-관리할-수-있게-한다)
  - [🤝 클래스와 인스턴스 차이](#-클래스와-인스턴스-차이)
  - [🌌 네임스페이스](#-네임스페이스)
  - [📚 클래스 변수 vs 인스턴스 변수](#-클래스-변수-vs-인스턴스-변수)
      - [클래스 정의 내부에서 생성되며, 클래스 자체에 속하는 변수.](#클래스-정의-내부에서-생성되며-클래스-자체에-속하는-변수)
      - [클래스의 모든 인스턴스들 사이에서 공유되며, 클래스명.변수명으로 접근 가능.](#클래스의-모든-인스턴스들-사이에서-공유되며-클래스명변수명으로-접근-가능)
      - [예: 학생 클래스에서 학생들이 다니는 학교명을 클래스 변수로 설정할 수 있다.](#예-학생-클래스에서-학생들이-다니는-학교명을-클래스-변수로-설정할-수-있다)
      - [인스턴스 변수:](#인스턴스-변수)
      - [클래스의 각 인스턴스, 즉 객체마다 별도로 존재하는 변수.](#클래스의-각-인스턴스-즉-객체마다-별도로-존재하는-변수)
      - [self.변수명을 사용하여 각 인스턴스 내에서 정의하고 접근.](#self변수명을-사용하여-각-인스턴스-내에서-정의하고-접근)
      - [예: 학생 클래스의 인스턴스인 각 학생의 이름을 인스턴스 변수로 설정할 수 있다.](#예-학생-클래스의-인스턴스인-각-학생의-이름을-인스턴스-변수로-설정할-수-있다)
  - [self의 이해와 활용 in 파이썬 클래스 🐍🔍](#self의-이해와-활용-in-파이썬-클래스-)
    - [self는 클래스 내부에서 현재 인스턴스 객체를 참조하는 데 사용되는 변수. 즉, 클래스의 메소드를 호출할 때, 해당 메소드를 호출한 인스턴스 자체가 첫 번째 인자로 전달되며, 이를 self라고 표현.](#self는-클래스-내부에서-현재-인스턴스-객체를-참조하는-데-사용되는-변수-즉-클래스의-메소드를-호출할-때-해당-메소드를-호출한-인스턴스-자체가-첫-번째-인자로-전달되며-이를-self라고-표현)
  - [🌱 self의 주요 사용 사례:](#-self의-주요-사용-사례)
    - [인스턴스 변수 접근 📦:](#인스턴스-변수-접근-)
      - [클래스 내부에서 self.변수명을 통해 인스턴스 변수에 접근.](#클래스-내부에서-self변수명을-통해-인스턴스-변수에-접근)
      - [객체의 상태를 저장하거나 수정할 때 사용.](#객체의-상태를-저장하거나-수정할-때-사용)
    - [메소드 호출 📞:](#메소드-호출-)
      - [같은 객체 내의 다른 메소드를 self.메소드명() 형식으로 호출.](#같은-객체-내의-다른-메소드를-self메소드명-형식으로-호출)
      - [이를 통해 객체의 행동을 정의하고, 코드의 재사용성을 높일 수 있다.](#이를-통해-객체의-행동을-정의하고-코드의-재사용성을-높일-수-있다)
    - [🌟 self의 특징:](#-self의-특징)
      - [첫 번째 매개변수:](#첫-번째-매개변수)
      - [self는 파이썬 클래스 메소드의 첫 번째 매개변수로 사용됨.](#self는-파이썬-클래스-메소드의-첫-번째-매개변수로-사용됨)
      - [메소드를 호출하는 객체 자신을 참조.](#메소드를-호출하는-객체-자신을-참조)
      - [관례적 이름:](#관례적-이름)
      - [파이썬에서 self의 이름은 관례적으로 사용.](#파이썬에서-self의-이름은-관례적으로-사용)
      - [다른 이름을 사용할 수도 있으나, self가 일반적으로 좋은 프로그래밍 관습으로 간주. 📚](#다른-이름을-사용할-수도-있으나-self가-일반적으로-좋은-프로그래밍-관습으로-간주-)
    - [객체의 속성과 메소드에 접근:](#객체의-속성과-메소드에-접근)
      - [self를 통해 클래스 내부에서 객체의 속성(`attributes`)과 메소드(`methods`)에 접근할 수 있다.](#self를-통해-클래스-내부에서-객체의-속성attributes과-메소드methods에-접근할-수-있다)
      - [객체 지향 프로그래밍의 핵심적인 기능을 구현하는 데 필수적. 🛠️](#객체-지향-프로그래밍의-핵심적인-기능을-구현하는-데-필수적-️)
      - [self는 클래스 내부에서 객체의 인스턴스를 참조하며, 클래스의 인스턴스 간에 데이터와 행위를 구분 짓는 중요한 역할을 함. 객체 지향 프로그래밍에서 `self`를 이해하고 활용하는 것은 파이썬 프로그래밍의 기본이며, 효과적인 코드 구조를 만드는 데 있어 핵심적인 요소. 🌈🚀](#self는-클래스-내부에서-객체의-인스턴스를-참조하며-클래스의-인스턴스-간에-데이터와-행위를-구분-짓는-중요한-역할을-함-객체-지향-프로그래밍에서-self를-이해하고-활용하는-것은-파이썬-프로그래밍의-기본이며-효과적인-코드-구조를-만드는-데-있어-핵심적인-요소-)
  - [예제1: 기본적인 클래스 정의와 인스턴스 생성 🏗️](#예제1-기본적인-클래스-정의와-인스턴스-생성-️)
  - [📖 개념 정리:](#-개념-정리)
  - [예제2: self의 이해 🤔🔍](#예제2-self의-이해-)
  - [클래스 메소드 vs 인스턴스 메소드:](#클래스-메소드-vs-인스턴스-메소드)
  - [주의사항 ⚠️:](#주의사항-️)
  - [🏭 클래스 변수 vs 인스턴스 변수 🆚](#-클래스-변수-vs-인스턴스-변수-)
    - [클래스 변수 stock\_num 🔄: Warehouse 클래스의 모든 인스턴스에 의해 공유됨. 클래스 단위에서 관리되며, 모든 인스턴스가 동일한 값을 보유.](#클래스-변수-stock_num--warehouse-클래스의-모든-인스턴스에-의해-공유됨-클래스-단위에서-관리되며-모든-인스턴스가-동일한-값을-보유)
    - [인스턴스 변수 name 🆔: 생성된 각 Warehouse 인스턴스에 고유합니다. 인스턴스마다 독립적인 값을 가짐.](#인스턴스-변수-name--생성된-각-warehouse-인스턴스에-고유합니다-인스턴스마다-독립적인-값을-가짐)
    - [🚶‍♂️ 생성자(__init__)와 소멸자(__del__)](#️-생성자init와-소멸자del)
    - [📝 예제 사용](#-예제-사용)
      - [이 예제는 클래스 변수와 인스턴스 변수의 개념을 명확히 이해하는 데 도움을 준다. 클래스 변수는 클래스에 속하며 모든 인스턴스에 의해 공유되는 반면, 인스턴스 변수는 각 인스턴스에 고유하며 독립적인 값을 가짐. 생성자와 소멸자는 객체의 생명주기 동안 자동으로 호출되는 특별한 메소드로, 리소스의 할당과 해제에 유용하게 사용된다. 🚀✨](#이-예제는-클래스-변수와-인스턴스-변수의-개념을-명확히-이해하는-데-도움을-준다-클래스-변수는-클래스에-속하며-모든-인스턴스에-의해-공유되는-반면-인스턴스-변수는-각-인스턴스에-고유하며-독립적인-값을-가짐-생성자와-소멸자는-객체의-생명주기-동안-자동으로-호출되는-특별한-메소드로-리소스의-할당과-해제에-유용하게-사용된다-)
  - [🐕 예제4: 클래스 메소드와 인스턴스 생성 🗣️](#-예제4-클래스-메소드와-인스턴스-생성-️)
    - [📚 클래스 정의하기](#-클래스-정의하기)
    - [🐶 인스턴스 생성](#-인스턴스-생성)
    - [📢 메소드 호출](#-메소드-호출)
    - [📢 speak 메소드 호출](#-speak-메소드-호출)
    - [💡 주석 설명](#-주석-설명)
      - [이 예제를 통해 클래스의 구조와 기능, 인스턴스 생성 방법, 그리고 인스턴스 메소드의 호출 방법을 배울 수 있다. 클래스를 사용함으로써 관련 데이터와 함수를 묶어서 효율적으로 관리할 수 있으며, 코드의 재사용성과 구조화를 향상시킬 수 있다. 🌈🚀](#이-예제를-통해-클래스의-구조와-기능-인스턴스-생성-방법-그리고-인스턴스-메소드의-호출-방법을-배울-수-있다-클래스를-사용함으로써-관련-데이터와-함수를-묶어서-효율적으로-관리할-수-있으며-코드의-재사용성과-구조화를-향상시킬-수-있다-)
- [파이썬 모듈 📦🔍](#파이썬-모듈-)
  - [📁 모듈이란?](#-모듈이란)
      - [모듈(Module)은 함수, 변수, 클래스 등 파이썬 구성 요소들을 모아놓은 파일. 모듈을 사용함으로써 코드를 재사용하기 쉽게 만들고, 파일을 기능별로 분리하여 프로그램을 체계적으로 관리할 수 있다.](#모듈module은-함수-변수-클래스-등-파이썬-구성-요소들을-모아놓은-파일-모듈을-사용함으로써-코드를-재사용하기-쉽게-만들고-파일을-기능별로-분리하여-프로그램을-체계적으로-관리할-수-있다)
  - [🧮 기본 연산 모듈 예제](#-기본-연산-모듈-예제)
    - [🚀 __name__ 사용하기](#-name-사용하기)
      - [파이썬 파일이 `"직접 실행"`될 때와 "`모듈로 임포트되어 실행`"될 때를 구분하기 위해 __name__ 변수를 사용. 파일이 직접 실행될 때 __name__ 변수의 값은 "__main__"이 된다.](#파이썬-파일이-직접-실행될-때와-모듈로-임포트되어-실행될-때를-구분하기-위해-name-변수를-사용-파일이-직접-실행될-때-name-변수의-값은-main이-된다)
      - [if __name__ == "__main__": 이 조건문은 현재 파일이 프로그램의 시작점인지 확인.](#if-name--main-이-조건문은-현재-파일이-프로그램의-시작점인지-확인)
      - [이 구문을 사용하면, 모듈이 다른 파일에 임포트될 때는 내부 코드가 실행되지 않고, 파일이 직접 실행될 때만 코드가 실행.](#이-구문을-사용하면-모듈이-다른-파일에-임포트될-때는-내부-코드가-실행되지-않고-파일이-직접-실행될-때만-코드가-실행)
  - [🎯 주요 포인트](#-주요-포인트)
      - [이 설명이 모듈의 개념과 \_\_name\_\_의 사용 방법을 이해하고. 모듈을 통해 코드를 모듈화하고 재사용하는 방법을 배우는 것은 파이썬 프로그래밍에서 매우 중요. 🌟](#이-설명이-모듈의-개념과-__name__의-사용-방법을-이해하고-모듈을-통해-코드를-모듈화하고-재사용하는-방법을-배우는-것은-파이썬-프로그래밍에서-매우-중요-)
- [모듈 사용 실습 🛠️](#모듈-사용-실습-️)
  - [파이썬에서 모듈을 사용하면, 표준 라이브러리 또는 외부 라이브러리의 기능을 활용할 수 있다. 여기서는 sys 모듈을 사용하는 기본적인 예제를 다뤄보자.](#파이썬에서-모듈을-사용하면-표준-라이브러리-또는-외부-라이브러리의-기능을-활용할-수-있다-여기서는-sys-모듈을-사용하는-기본적인-예제를-다뤄보자)
  - [sys 모듈 🖥️](#sys-모듈-️)
      - [sys 모듈은 파이썬 인터프리터와 관련된 함수와 변수들을 제공. 예를 들어, 스크립트를 실행하기 위한 많은 설정들과 함수들에 접근할 수 있게 해준다.](#sys-모듈은-파이썬-인터프리터와-관련된-함수와-변수들을-제공-예를-들어-스크립트를-실행하기-위한-많은-설정들과-함수들에-접근할-수-있게-해준다)
      - [sys.path는 파이썬이 모듈을 찾기 위해 검색하는 디렉토리의 리스트. 이 리스트에 디렉토리 경로를 추가하면, 해당 경로에 있는 모듈도 임포트할 수 있다.](#syspath는-파이썬이-모듈을-찾기-위해-검색하는-디렉토리의-리스트-이-리스트에-디렉토리-경로를-추가하면-해당-경로에-있는-모듈도-임포트할-수-있다)
  - [모듈 경로 삽입 📂](#모듈-경로-삽입-)
      - [이렇게 하면, 'C:/math' 디렉토리에 있는 파이썬 파일(모듈)을 임포트할 수 있게 된다.](#이렇게-하면-cmath-디렉토리에-있는-파이썬-파일모듈을-임포트할-수-있게-된다)
  - [모듈 사용 📚](#모듈-사용-)
      - [모듈이 임포트되면, 해당 모듈에 정의된 함수, 변수, 클래스 등을 사용할 수 있다.](#모듈이-임포트되면-해당-모듈에-정의된-함수-변수-클래스-등을-사용할-수-있다)
- [모듈 임포트 📖](#모듈-임포트-)
      - [이 부분은 `chapter06_02`라는 이름의 파이썬 파일(모듈)을 현재 스크립트에 임포트하는 예시. 임포트된 모듈의 함수나 변수, 클래스 등을 사용할 수 있게 됨.](#이-부분은-chapter06_02라는-이름의-파이썬-파일모듈을-현재-스크립트에-임포트하는-예시-임포트된-모듈의-함수나-변수-클래스-등을-사용할-수-있게-됨)
      - [이 실습을 통해 파이썬에서 모듈을 임포트하는 방법과 sys.path를 통해 모듈 검색 경로를 관리하는 방법에 대해 알아보았다. 모듈을 사용하면 다양한 기능을 쉽게 활용할 수 있어 파이썬 프로그래밍이 더욱 효율적이고 강력해진다. 🌈](#이-실습을-통해-파이썬에서-모듈을-임포트하는-방법과-syspath를-통해-모듈-검색-경로를-관리하는-방법에-대해-알아보았다-모듈을-사용하면-다양한-기능을-쉽게-활용할-수-있어-파이썬-프로그래밍이-더욱-효율적이고-강력해진다-)
  - [📦 패키지란 무엇인가요?](#-패키지란-무엇인가요)
      - [패키지는 관련된 모듈들을 모아둔 폴더. 이를 통해 코드를 모듈화하여 재사용성을 높이고, 프로젝트의 구조를 체계적으로 관리할 수 있다. 간단히 말해서, 패키지는 코드를 깔끔하고 관리하기 쉽게 도와주는 폴더 시스템. 🗃️](#패키지는-관련된-모듈들을-모아둔-폴더-이를-통해-코드를-모듈화하여-재사용성을-높이고-프로젝트의-구조를-체계적으로-관리할-수-있다-간단히-말해서-패키지는-코드를-깔끔하고-관리하기-쉽게-도와주는-폴더-시스템-️)
  - [🗂 __init__.py 파일](#-initpy-파일)
      - [파이썬에서는 특정 폴더가 패키지의 일부임을 인식하기 위해 __init__.py 파일을 사용. 이 파일은 패키지 초기화 코드를 담거나 비어 있을 수 있다. `Python 3.3` 이상에서는 이 파일 없이도 폴더를 패키지로 인식하지만, 호환성을 위해 여전히 이 파일을 포함시키는 것이 좋다. 📝](#파이썬에서는-특정-폴더가-패키지의-일부임을-인식하기-위해-initpy-파일을-사용-이-파일은-패키지-초기화-코드를-담거나-비어-있을-수-있다-python-33-이상에서는-이-파일-없이도-폴더를-패키지로-인식하지만-호환성을-위해-여전히-이-파일을-포함시키는-것이-좋다-)
  - [🛤 상대 경로 사용](#-상대-경로-사용)
      - [패키지 내부에서 다른 모듈을 임포트할 때, 상대 경로를 사용할 수 있다. 이 방식은 코드를 더욱 간결하게 만들고, 모듈 간의 의존성을 쉽게 관리할 수 있게 해준다.](#패키지-내부에서-다른-모듈을-임포트할-때-상대-경로를-사용할-수-있다-이-방식은-코드를-더욱-간결하게-만들고-모듈-간의-의존성을-쉽게-관리할-수-있게-해준다)
    - [🚀 패키지 사용 예시](#-패키지-사용-예시)
      - [예제 1: 직접 임포트](#예제-1-직접-임포트)
      - [이 방법을 사용하면, 패키지 안에 있는 특정 모듈을 직접 사용할 수 있다. 패키지와 모듈 이름을 명시해 주어야 한다.](#이-방법을-사용하면-패키지-안에-있는-특정-모듈을-직접-사용할-수-있다-패키지와-모듈-이름을-명시해-주어야-한다)
      - [예제 2: 상대 경로 임포트](#예제-2-상대-경로-임포트)
        - [같은 패키지 내 모듈 임포트](#같은-패키지-내-모듈-임포트)
        - [상위 패키지에서 하위 패키지 모듈 임포트](#상위-패키지에서-하위-패키지-모듈-임포트)
      - [이 방법들을 사용하면, 코드의 재사용성을 높이고, 프로젝트의 구조를 더욱 명확하게 만들 수 있다. 상대 경로를 사용함으로써, 패키지 구조 변경에 더 유연하게 대응할 수 있다. 🛠️](#이-방법들을-사용하면-코드의-재사용성을-높이고-프로젝트의-구조를-더욱-명확하게-만들-수-있다-상대-경로를-사용함으로써-패키지-구조-변경에-더-유연하게-대응할-수-있다-️)
- [🧩 sys와 inspect 모듈 활용하기](#-sys와-inspect-모듈-활용하기)
  - [🛠️ sys 모듈](#️-sys-모듈)
    - [sys 모듈은 파이썬 인터프리터와 관련된 함수와 변수들을 포함하고 있다. 예를 들어, sys.path는 파이썬이 모듈을 검색할 때 참조하는 경로 목록.](#sys-모듈은-파이썬-인터프리터와-관련된-함수와-변수들을-포함하고-있다-예를-들어-syspath는-파이썬이-모듈을-검색할-때-참조하는-경로-목록)
  - [🔍 inspect 모듈](#-inspect-모듈)
      - [`inspect` 모듈은 파이썬 코드의 실행 중인 객체들에 대한 정보를 얻기 위해 사용. 여기서는 현재 실행 중인 함수의 파일 경로를 얻는 데 사용.](#inspect-모듈은-파이썬-코드의-실행-중인-객체들에-대한-정보를-얻기-위해-사용-여기서는-현재-실행-중인-함수의-파일-경로를-얻는-데-사용)
  - [📝 코드 예제](#-코드-예제)
    - [module2.py](#module2py)
    - [module1.py](#module1py)
  - [📌 설명](#-설명)
      - [inspect.getfile(inspect.currentframe()): 이 코드는 현재 실행 중인 함수가 정의된 파일의 경로를 반환. `inspect.currentframe()` 함수는 현재의 스택 프레임을 가져오고, `inspect.getfile()` 함수는 주어진 프레임의 파일 경로를 찾는다.](#inspectgetfileinspectcurrentframe-이-코드는-현재-실행-중인-함수가-정의된-파일의-경로를-반환-inspectcurrentframe-함수는-현재의-스택-프레임을-가져오고-inspectgetfile-함수는-주어진-프레임의-파일-경로를-찾는다)
      - [`print("Module1 -> Test1")`와 같은 문장은 각 함수가 호출될 때, 해당 함수가 어느 모듈의 일부인지를 식별하는 메시지를 출력.](#printmodule1---test1와-같은-문장은-각-함수가-호출될-때-해당-함수가-어느-모듈의-일부인지를-식별하는-메시지를-출력)
  - [💭 주의사항](#-주의사항)
      - [상대경로를 사용한 모듈 임포트 (예: from ..sub1 import module1)는 해당 코드가 어떤 패키지 구조 안에 포함되어 있을 때만 유효. 이 문서에서는 주석 처리되어 있어, 실제 코드 구조와 패키지 구성에 따라 주석을 해제하고 사용할 수 있다.](#상대경로를-사용한-모듈-임포트-예-from-sub1-import-module1는-해당-코드가-어떤-패키지-구조-안에-포함되어-있을-때만-유효-이-문서에서는-주석-처리되어-있어-실제-코드-구조와-패키지-구성에-따라-주석을-해제하고-사용할-수-있다)
      - [이 예제를 통해 현재 실행 중인 코드의 위치를 파악하는 방법과 sys, inspect 모듈의 기본적인 사용법에 대해 알아보았다. 이는 디버깅이나 코드 분석 시 유용하게 사용될 수 있다. 🚀🔎](#이-예제를-통해-현재-실행-중인-코드의-위치를-파악하는-방법과-sys-inspect-모듈의-기본적인-사용법에-대해-알아보았다-이는-디버깅이나-코드-분석-시-유용하게-사용될-수-있다-)
  - [🎯 예제들을 통한 패키지 사용법과 sys.path의 이해](#-예제들을-통한-패키지-사용법과-syspath의-이해)
    - [📂 예제 1: 모듈을 전체 경로로 임포트하기](#-예제-1-모듈을-전체-경로로-임포트하기)
      - [이 방법은 모듈을 패키지 경로를 포함하여 전체 경로로 직접 임포트.](#이-방법은-모듈을-패키지-경로를-포함하여-전체-경로로-직접-임포트)
      - [패키지와 모듈의 구조를 명확히 알 수 있게 해주지만, 사용할 때마다 전체 경로를 지정해야 하는 번거로움이 있다. 🛣️](#패키지와-모듈의-구조를-명확히-알-수-있게-해주지만-사용할-때마다-전체-경로를-지정해야-하는-번거로움이-있다-️)
    - [🛤 예제 2: 모듈 임포트 및 별칭 사용](#-예제-2-모듈-임포트-및-별칭-사용)
      - [`from ... import ...`를 사용하여 모듈을 임포트하고, 필요한 경우 별칭(as)을 지정해 사용의 편의성을 높일 수 있다.](#from--import-를-사용하여-모듈을-임포트하고-필요한-경우-별칭as을-지정해-사용의-편의성을-높일-수-있다)
      - [코드를 더 깔끔하게 유지할 수 있으며, 함수 호출 시 모듈의 전체 경로를 지정할 필요가 없다. 📌](#코드를-더-깔끔하게-유지할-수-있으며-함수-호출-시-모듈의-전체-경로를-지정할-필요가-없다-)
    - [🌟 예제 3: 패키지로부터 모든 것 임포트하기](#-예제-3-패키지로부터-모든-것-임포트하기)
      - [from ... import \* 구문을 사용하여 패키지의 모든 모듈을 임포트.](#from--import--구문을-사용하여-패키지의-모든-모듈을-임포트)
    - [🌟 from ... import \* 구문의 사용과 주의점](#-from--import--구문의-사용과-주의점)
      - [from ... import \* 구문은 특정 모듈이나 패키지로부터 모든 것을 임포트. 이 방식은 특정 모듈의 모든 정의(함수, 변수, 클래스 등)를 현재 네임스페이스로 가져오므로, 코드를 작성할 때 매우 편리할 수 있다. 그러나 이 방법은 몇 가지 주의해야 할 점이 있다:](#from--import--구문은-특정-모듈이나-패키지로부터-모든-것을-임포트-이-방식은-특정-모듈의-모든-정의함수-변수-클래스-등를-현재-네임스페이스로-가져오므로-코드를-작성할-때-매우-편리할-수-있다-그러나-이-방법은-몇-가지-주의해야-할-점이-있다)
      - [성능과 메모리 사용에 대한 고려](#성능과-메모리-사용에-대한-고려)
      - [비록 현대의 컴퓨터가 충분한 성능과 메모리를 제공하지만, 효율적인 프로그래밍 관습은 여전히 중요하다. 특히, 대규모 프로그램이나 메모리 사용이 중요한 응용 프로그램에서는 더욱 그렇다.](#비록-현대의-컴퓨터가-충분한-성능과-메모리를-제공하지만-효율적인-프로그래밍-관습은-여전히-중요하다-특히-대규모-프로그램이나-메모리-사용이-중요한-응용-프로그램에서는-더욱-그렇다)
      - [좋은 프로그래밍 습관은 자원을 절약하고, 코드의 유지보수성을 높이며, 향후 발생할 수 있는 문제를 미연에 방지하는 데 도움이 된다. 따라서 가능한 한 명확하게 필요한 것만 임포트하여 사용하는 것이 권장된다. 🌱](#좋은-프로그래밍-습관은-자원을-절약하고-코드의-유지보수성을-높이며-향후-발생할-수-있는-문제를-미연에-방지하는-데-도움이-된다-따라서-가능한-한-명확하게-필요한-것만-임포트하여-사용하는-것이-권장된다-)
    - [💡 sys.path와의 연관성](#-syspath와의-연관성)
      - [sys.path는 파이썬 인터프리터가 모듈을 검색할 때 참조하는 디렉토리 목록. 파이썬이 모듈을 임포트할 때, `sys.path`에 나열된 디렉토리들을 순서대로 검색하여 해당 모듈을 찾는다.](#syspath는-파이썬-인터프리터가-모듈을-검색할-때-참조하는-디렉토리-목록-파이썬이-모듈을-임포트할-때-syspath에-나열된-디렉토리들을-순서대로-검색하여-해당-모듈을-찾는다)
      - [패키지를 사용할 때, 패키지가 위치한 디렉토리가 sys.path에 포함되어 있어야 파이썬이 해당 패키지를 찾을 수 있다.](#패키지를-사용할-때-패키지가-위치한-디렉토리가-syspath에-포함되어-있어야-파이썬이-해당-패키지를-찾을-수-있다)
      - [만약 패키지가 `sys.path`에 나열된 경로 밖에 있다면, `sys.path.append('/path/to/package') `메소드를 사용하여 패키지 경로를 `sys.path`에 추가해야 한다. 🛠️](#만약-패키지가-syspath에-나열된-경로-밖에-있다면-syspathappendpathtopackage-메소드를-사용하여-패키지-경로를-syspath에-추가해야-한다-️)
      - [이렇게 sys.path를 이해하고 관리하는 것은 파이썬에서 패키지를 효과적으로 사용하는 데 매우 중요🌟](#이렇게-syspath를-이해하고-관리하는-것은-파이썬에서-패키지를-효과적으로-사용하는-데-매우-중요)
  - [🌟 복습 🌟](#-복습-)
    - [🚀 \_\_pycache\_\_와 컴파일](#-__pycache__와-컴파일)
      - [파이썬은 코드를 실행할 때, `.py` 파일을 바이트 코드로 "컴파일"하고 이를 __pycache__ 폴더에 저장. 이 바이트 코드는 파이썬이 실행할 때 더 빠르게 로드할 수 있게 해준다. 컴파일이라는 용어는 전통적인 컴파일 언어와는 다소 다르게 사용되지만, 여기서는 파이썬 코드를 실행 가능한 바이트 코드로 변환하는 과정을 의미. 🚗💨](#파이썬은-코드를-실행할-때-py-파일을-바이트-코드로-컴파일하고-이를-pycache-폴더에-저장-이-바이트-코드는-파이썬이-실행할-때-더-빠르게-로드할-수-있게-해준다-컴파일이라는-용어는-전통적인-컴파일-언어와는-다소-다르게-사용되지만-여기서는-파이썬-코드를-실행-가능한-바이트-코드로-변환하는-과정을-의미-)
    - [📂 __init__.py 파일과 __all__ 변수](#-initpy-파일과-all-변수)
      - [__all__ 변수: __init__.py 파일 안에서 __all__ 변수를 사용하여, 패키지로부터 from ... import \* 할 때 어떤 모듈이 임포트될지 명시적으로 지정할 수 있다. 이는 패키지를 사용하는 다른 개발자들에게 어떤 모듈이 공개 인터페이스의 일부인지 알려주는 역할도 한다. 예를 들어, __all__ = \['module1', 'module2'\]라고 설정하면, module1과 module2만 from ... import \*를 통해 임포트될 수 있다. 🔐](#all-변수-initpy-파일-안에서-all-변수를-사용하여-패키지로부터-from--import--할-때-어떤-모듈이-임포트될지-명시적으로-지정할-수-있다-이는-패키지를-사용하는-다른-개발자들에게-어떤-모듈이-공개-인터페이스의-일부인지-알려주는-역할도-한다-예를-들어-all--module1-module2라고-설정하면-module1과-module2만-from--import-를-통해-임포트될-수-있다-)
      - [🌍 패키지의 중요성](#-패키지의-중요성)
      - [파이썬에서 패키지를 사용하면 코드를 모듈화하고 재사용하기 쉽게 만들 수 있습니다. 또한, 패키지는 프로젝트의 구조를 명확하게 하고, 다양한 기능을 로직별로 분리하여 관리할 수 있게 해줍니다. 패키지는 마치 폴더처럼 동작하며, 모듈과 서브패키지를 포함할 수 있다. 🏗️](#파이썬에서-패키지를-사용하면-코드를-모듈화하고-재사용하기-쉽게-만들-수-있습니다-또한-패키지는-프로젝트의-구조를-명확하게-하고-다양한-기능을-로직별로-분리하여-관리할-수-있게-해줍니다-패키지는-마치-폴더처럼-동작하며-모듈과-서브패키지를-포함할-수-있다-️)
      - [🛠️ 패키지 임포트 방법](#️-패키지-임포트-방법)
      - [from ... import ... 절을 사용하는 것이 일반적으로 편리하다. 이 방법은 필요한 모듈만 명확하게 지정하여 임포트할 수 있게 해주며, 코드의 가독성을 높이고 반복을 최소화할 수 있다. 또한, 별칭(as)을 사용하여 모듈에 대한 참조를 더 간단하게 만들 수도 있다. 🖋️](#from--import--절을-사용하는-것이-일반적으로-편리하다-이-방법은-필요한-모듈만-명확하게-지정하여-임포트할-수-있게-해주며-코드의-가독성을-높이고-반복을-최소화할-수-있다-또한-별칭as을-사용하여-모듈에-대한-참조를-더-간단하게-만들-수도-있다-️)
      - [패키지를 효과적으로 사용함으로써, 코드의 구조를 개선하고 다른 개발자들과의 협업을 용이하게 만들 수 있다. 이러한 방법들은 파이썬 어플리케이션을 개발할 때 중요한 기본 요소다. 🌟](#패키지를-효과적으로-사용함으로써-코드의-구조를-개선하고-다른-개발자들과의-협업을-용이하게-만들-수-있다-이러한-방법들은-파이썬-어플리케이션을-개발할-때-중요한-기본-요소다-)
- [파이썬 예외처리의 이해 🐍🔧](#파이썬-예외처리의-이해-)
  - [🚨 예외(Exception)란?](#-예외exception란)
    - [프로그램 실행 중에 발생하는 오류로, 예상치 못한 상황에서 프로그램이 중단되지 않도록 처리해야 하는 중요한 사건.](#프로그램-실행-중에-발생하는-오류로-예상치-못한-상황에서-프로그램이-중단되지-않도록-처리해야-하는-중요한-사건)
  - [📚 예외 종류](#-예외-종류)
      - [파이썬에서는 다양한 종류의 예외가 있으며, 각각 다른 원인에 의해 발생.](#파이썬에서는-다양한-종류의-예외가-있으며-각각-다른-원인에-의해-발생)
    - [🛡️ 예외 처리하기](#️-예외-처리하기)
      - [예외 처리는 `try, except` 블록을 사용하여 수행. 이를 통해 예외가 발생할 가능성이 있는 코드를 `try` 블록에 넣고, 예외 발생 시 실행할 코드를 `except` 블록에 넣는다.](#예외-처리는-try-except-블록을-사용하여-수행-이를-통해-예외가-발생할-가능성이-있는-코드를-try-블록에-넣고-예외-발생-시-실행할-코드를-except-블록에-넣는다)
    - [📌 예외 처리의 기본 원칙](#-예외-처리의-기본-원칙)
      - [예외는 반드시 처리해야 한다. 👍](#예외는-반드시-처리해야-한다-)
    - [SyntaxError: 문법 오류 🚫📚](#syntaxerror-문법-오류-)
      - [SyntaxError는 파이썬 코드가 올바른 문법에 따라 작성되지 않았을 때 발생하는 오류. 코드를 작성할 때 발생할 수 있는 몇 가지 일반적인 SyntaxError 예시와 그 해결 방법을 알아보자.](#syntaxerror는-파이썬-코드가-올바른-문법에-따라-작성되지-않았을-때-발생하는-오류-코드를-작성할-때-발생할-수-있는-몇-가지-일반적인-syntaxerror-예시와-그-해결-방법을-알아보자)
    - [예시 1: 따옴표 누락](#예시-1-따옴표-누락)
    - [예시 2: 괄호 불일치](#예시-2-괄호-불일치)
    - [예시 3: 콜론(:) 누락](#예시-3-콜론-누락)
      - [📌 기억해야 할 사항](#-기억해야-할-사항)
  - [NameError: 참조 없음 🔍❌](#nameerror-참조-없음-)
    - [NameError는 프로그램에서 선언되지 않은 변수나 함수, 혹은 다른 식별자를 참조하려고 할 때 발생하는 오류. 즉, 파이썬 인터프리터가 해당 이름을 알아볼 수 없을 때 이 오류가 발생.](#nameerror는-프로그램에서-선언되지-않은-변수나-함수-혹은-다른-식별자를-참조하려고-할-때-발생하는-오류-즉-파이썬-인터프리터가-해당-이름을-알아볼-수-없을-때-이-오류가-발생)
    - [📝 오류 예시](#-오류-예시)
      - [🛠️ 정정 코드](#️-정정-코드)
    - [📌 기억해야 할 사항](#-기억해야-할-사항-1)
      - [오타 조심: 변수나 함수의 이름을 잘못 입력한 경우 `NameError`가 발생할 수 있다. 오타가 없는지 주의 깊게 확인하자. 🔍](#오타-조심-변수나-함수의-이름을-잘못-입력한-경우-nameerror가-발생할-수-있다-오타가-없는지-주의-깊게-확인하자-)
      - [스코프 이해: 파이썬에서 변수의 스코프(변수가 접근 가능한 범위)를 이해하는 것도 중요하다. 함수 내부에서 선언된 변수는 해당 함수 외부에서는 접근할 수 없다. 스코프 문제로 `NameError`가 발생할 수도 있습니다. 🚧](#스코프-이해-파이썬에서-변수의-스코프변수가-접근-가능한-범위를-이해하는-것도-중요하다-함수-내부에서-선언된-변수는-해당-함수-외부에서는-접근할-수-없다-스코프-문제로-nameerror가-발생할-수도-있습니다-)
        - [`NameError`는 코드를 작성하면서 가장 흔히 마주치는 오류 중 하나. 이 오류를 해결하는 방법을 배움으로써, 코드를 더 정확하고 효율적으로 작성하는 데 도움이 된다! 💡](#nameerror는-코드를-작성하면서-가장-흔히-마주치는-오류-중-하나-이-오류를-해결하는-방법을-배움으로써-코드를-더-정확하고-효율적으로-작성하는-데-도움이-된다-)
  - [ZeroDivisionError: 0으로 나누기 🔢🚫](#zerodivisionerror-0으로-나누기-)
      - [ZeroDivisionError는 숫자를 0으로 나누려고 시도할 때 발생하는 오류. 수학에서는 어떤 수를 0으로 나누는 것이 정의되지 않으며, 파이썬에서도 마찬가지로 이를 허용하지 않는다.](#zerodivisionerror는-숫자를-0으로-나누려고-시도할-때-발생하는-오류-수학에서는-어떤-수를-0으로-나누는-것이-정의되지-않으며-파이썬에서도-마찬가지로-이를-허용하지-않는다)
    - [📝 오류 예시](#-오류-예시-1)
    - [🛠️ 예외 처리를 통한 해결 방법](#️-예외-처리를-통한-해결-방법)
      - [이 코드는 `try` 블록 안에서 0으로 나누기를 시도하고, `ZeroDivisionError`가 발생하면 `except` 블록이 실행되어 사용자에게 "0으로 나눌 수 없습니다!"라는 메시지를 출력.](#이-코드는-try-블록-안에서-0으로-나누기를-시도하고-zerodivisionerror가-발생하면-except-블록이-실행되어-사용자에게-0으로-나눌-수-없습니다라는-메시지를-출력)
    - [📌 기억해야 할 사항](#-기억해야-할-사항-2)
  - [IndexError: 인덱스 범위 초과 📊🔍](#indexerror-인덱스-범위-초과-)
      - [`IndexError`는 리스트, 튜플, 문자열 등의 시퀀스 타입에서 범위를 벗어난 인덱스를 사용하려고 할 때 발생하는 오류. 즉, 시퀀스의 길이보다 크거나 같은 인덱스를 사용하려고 하면 이 오류가 발생.](#indexerror는-리스트-튜플-문자열-등의-시퀀스-타입에서-범위를-벗어난-인덱스를-사용하려고-할-때-발생하는-오류-즉-시퀀스의-길이보다-크거나-같은-인덱스를-사용하려고-하면-이-오류가-발생)
    - [📝 오류 예시](#-오류-예시-2)
    - [🛠️ .pop() 메소드와 IndexError](#️-pop-메소드와-indexerror)
      - [.pop() 메소드는 리스트의 마지막 요소를 제거하고 반환. 리스트가 비어있을 때 .pop()을 호출하면 `IndexError`가 발생.](#pop-메소드는-리스트의-마지막-요소를-제거하고-반환-리스트가-비어있을-때-pop을-호출하면-indexerror가-발생)
    - [📌 예외 처리를 통한 해결 방법](#-예외-처리를-통한-해결-방법)
      - [위 코드는 .pop() 메소드를 사용하여 리스트에서 요소를 제거하려고 시도하고, 만약 `IndexError`가 발생하면 사용자에게 메시지를 출력.](#위-코드는-pop-메소드를-사용하여-리스트에서-요소를-제거하려고-시도하고-만약-indexerror가-발생하면-사용자에게-메시지를-출력)
    - [기억해야 할 사항](#기억해야-할-사항)
  - [KeyError: 키가 딕셔너리에 없음 🔑❌](#keyerror-키가-딕셔너리에-없음-)
      - [KeyError는 주어진 키가 딕셔너리에 없을 때 발생하는 오류. 딕셔너리는 키-값 쌍으로 데이터를 저장하는 데이터 타입이며, 각 키는 해당 딕셔너리 내에서 유일해야 한다.](#keyerror는-주어진-키가-딕셔너리에-없을-때-발생하는-오류-딕셔너리는-키-값-쌍으로-데이터를-저장하는-데이터-타입이며-각-키는-해당-딕셔너리-내에서-유일해야-한다)
    - [📝 오류 예시](#-오류-예시-3)
    - [.get() 메소드를 사용한 안전한 접근](#get-메소드를-사용한-안전한-접근)
      - [.get() 메소드는 딕셔너리에서 키가 존재하지 않는 경우에도 프로그램이 중단되지 않도록 도와준다. 또한, `.get()`메소드는 두 번째 매개변수로 존재하지 않는 키에 대한 기본값을 설정할 수 있다.](#get-메소드는-딕셔너리에서-키가-존재하지-않는-경우에도-프로그램이-중단되지-않도록-도와준다-또한-get메소드는-두-번째-매개변수로-존재하지-않는-키에-대한-기본값을-설정할-수-있다)
      - [📌 기억해야 할 사항](#-기억해야-할-사항-3)
      - [EAFP(Easier to Ask for Forgiveness than Permission)는 파이썬 프로그래밍에서 권장되는 예외 처리 방식 중 하나. 🛡️ 이 접근 방식은 "허락을 구하기보다는 용서를 구하는 것이 쉽다"는 격언에서 유래했으며, 코드 실행을 시도하고 실행 중에 예외가 발생할 경우 그 예외를 처리하는 것을 의미.](#eafpeasier-to-ask-for-forgiveness-than-permission는-파이썬-프로그래밍에서-권장되는-예외-처리-방식-중-하나-️-이-접근-방식은-허락을-구하기보다는-용서를-구하는-것이-쉽다는-격언에서-유래했으며-코드-실행을-시도하고-실행-중에-예외가-발생할-경우-그-예외를-처리하는-것을-의미)
    - [EAFP의 핵심 원칙 🌟](#eafp의-핵심-원칙-)
    - [EAFP 예제 코드 📝](#eafp-예제-코드-)
      - [LBYL (Look Before You Leap) 방식](#lbyl-look-before-you-leap-방식)
        - [이 방식은 "점프하기 전에 보라"는 의미로, 특정 작업을 시도하기 전에 모든 전제 조건을 검사한다. 이는 EAFP와 대비되는 개념이다.](#이-방식은-점프하기-전에-보라는-의미로-특정-작업을-시도하기-전에-모든-전제-조건을-검사한다-이는-eafp와-대비되는-개념이다)
      - [EAFP 방식은 코드가 실행될 환경을 미리 검사하는 대신, 작업을 시도하고 실패할 경우에 대비하여 예외 처리를 한다.](#eafp-방식은-코드가-실행될-환경을-미리-검사하는-대신-작업을-시도하고-실패할-경우에-대비하여-예외-처리를-한다)
      - [EAFP의 장점 ✨](#eafp의-장점-)
        - [EAFP 방식은 코드를 더 간결하고 파이썬스럽게 만들며, 예외 상황을 효과적으로 처리할 수 있도록 도와준다. 따라서 예외 처리를 구현할 때 EAFP 방식을 고려해 보는 것이 좋다. 🚀](#eafp-방식은-코드를-더-간결하고-파이썬스럽게-만들며-예외-상황을-효과적으로-처리할-수-있도록-도와준다-따라서-예외-처리를-구현할-때-eafp-방식을-고려해-보는-것이-좋다-)
  - [AttributeError: 잘못된 속성 사용 예외 🛠️🔍](#attributeerror-잘못된-속성-사용-예외-️)
      - [예를 들어, 파이썬의 표준 라이브러리 중 하나인 `time` 모듈에서 존재하지 않는 함수를 호출하려고 할 때 `AttributeError`가 발생합니다.](#예를-들어-파이썬의-표준-라이브러리-중-하나인-time-모듈에서-존재하지-않는-함수를-호출하려고-할-때-attributeerror가-발생합니다)
    - [📝 예시 코드](#-예시-코드)
    - [🛡️ 해결 방법](#️-해결-방법)
    - [📌 기억해야 할 사항](#-기억해야-할-사항-4)
      - [AttributeError는 오타나 잘못된 속성 이름으로 인해 자주 발생. 메서드나 속성 이름을 정확히 입력했는지 확인하자.](#attributeerror는-오타나-잘못된-속성-이름으로-인해-자주-발생-메서드나-속성-이름을-정확히-입력했는지-확인하자)
      - [만약 자주 사용하는 라이브러리나 모듈이라면, 해당 객체가 제공하는 속성이나 메서드를 기억하거나 자주 참조하는 문서를 가까이 두는 것이 좋다.](#만약-자주-사용하는-라이브러리나-모듈이라면-해당-객체가-제공하는-속성이나-메서드를-기억하거나-자주-참조하는-문서를-가까이-두는-것이-좋다)
  - [ValueError: 잘못된 값 예외 🚫🔢](#valueerror-잘못된-값-예외-)
      - [리스트에서 remove() 메서드는 리스트 내에 있는 특정 값을 제거. 만약 제거하고자 하는 값이 리스트 내에 없을 경우, ValueError가 발생.](#리스트에서-remove-메서드는-리스트-내에-있는-특정-값을-제거-만약-제거하고자-하는-값이-리스트-내에-없을-경우-valueerror가-발생)
    - [📝 예시 코드](#-예시-코드-1)
    - [🛡️ 예외 처리를 통한 해결 방법](#️-예외-처리를-통한-해결-방법-1)
      - [`try-except` 블록을 사용하여 `ValueError`를 처리할 수 있다. 이렇게 하면 프로그램이 예외로 인해 비정상적으로 종료되는 것을 방지할 수 있다.](#try-except-블록을-사용하여-valueerror를-처리할-수-있다-이렇게-하면-프로그램이-예외로-인해-비정상적으로-종료되는-것을-방지할-수-있다)
    - [📌 기억해야 할 사항](#-기억해야-할-사항-5)
  - [FileNotFoundError: 파일을 찾을 수 없음 🚫📄](#filenotfounderror-파일을-찾을-수-없음-)
      - [파이썬에서 파일을 다룰 때, 해당 파일이 지정된 경로에 존재하지 않는 경우 FileNotFoundError가 발생.](#파이썬에서-파일을-다룰-때-해당-파일이-지정된-경로에-존재하지-않는-경우-filenotfounderror가-발생)
    - [📝 예시 코드](#-예시-코드-2)
    - [🛡️ 예외 처리를 통한 해결 방법](#️-예외-처리를-통한-해결-방법-2)
      - [try-except 블록을 사용하여 FileNotFoundError를 처리할 수 있다. 이렇게 하면 파일이 존재하지 않는 상황에서도 프로그램이 안정적으로 동작하게 할 수 있다.](#try-except-블록을-사용하여-filenotfounderror를-처리할-수-있다-이렇게-하면-파일이-존재하지-않는-상황에서도-프로그램이-안정적으로-동작하게-할-수-있다)
    - [📌 기억해야 할 사항](#-기억해야-할-사항-6)
      - [FileNotFoundError는 파일 작업을 할 때 흔히 마주치는 오류 중 하나. 이러한 예외를 적절히 처리함으로써, 프로그램의 안정성을 높이고 사용자에게 보다 친절한 피드백을 제공할 수 있다. 🚀](#filenotfounderror는-파일-작업을-할-때-흔히-마주치는-오류-중-하나-이러한-예외를-적절히-처리함으로써-프로그램의-안정성을-높이고-사용자에게-보다-친절한-피드백을-제공할-수-있다-)
  - [TypeError: 자료형에 맞지 않는 연산 📊❌](#typeerror-자료형에-맞지-않는-연산-)
      - [TypeError 예시를 살펴보면, 리스트(x), 튜플(y), 문자열(z) 간의 더하기 연산을 시도하는 코드에서 이 오류가 발생.](#typeerror-예시를-살펴보면-리스트x-튜플y-문자열z-간의-더하기-연산을-시도하는-코드에서-이-오류가-발생)
    - [📝 예시 코드와 오류](#-예시-코드와-오류)
    - [🛡️ 오류 해결 방법](#️-오류-해결-방법)
    - [서로 다른 타입의 객체를 연결하려면, 타입을 일치시킨 후 연산을 수행해야 한다. 예를 들어, 튜플을 리스트로 변환하거나, 문자열을 리스트로 변환하는 등의 작업이 필요하다.](#서로-다른-타입의-객체를-연결하려면-타입을-일치시킨-후-연산을-수행해야-한다-예를-들어-튜플을-리스트로-변환하거나-문자열을-리스트로-변환하는-등의-작업이-필요하다)
    - [📌 기억해야 할 사항](#-기억해야-할-사항-7)
  - [예외 처리의 기본 구조 🛑](#예외-처리의-기본-구조-)
    - [🔄 try 블록](#-try-블록)
    - [🛑 except 블록](#-except-블록)
    - [🌈 else 블록](#-else-블록)
    - [🏁 finally 블록](#-finally-블록)
    - [예제 코드](#예제-코드)
      - [이 코드에서는 10 / 0으로 ZeroDivisionError가 발생하여, 해당 except 블록이 실행됩니다. 그 후, finally 블록의 코드가 실행.](#이-코드에서는-10--0으로-zerodivisionerror가-발생하여-해당-except-블록이-실행됩니다-그-후-finally-블록의-코드가-실행)
    - [📌 기억해야 할 사항](#-기억해야-할-사항-8)
      - [`try` 블록은 필수적으로 사용해야 하며, `except, else, finally` 블록은 필요에 따라 선택적으로 사용할 수 있다.](#try-블록은-필수적으로-사용해야-하며-except-else-finally-블록은-필요에-따라-선택적으로-사용할-수-있다)
      - [여러 예외를 처리할 때는 가장 구체적인 예외부터 처리하도록 `except` 블록을 정렬하는 것이 좋다.](#여러-예외를-처리할-때는-가장-구체적인-예외부터-처리하도록-except-블록을-정렬하는-것이-좋다)
      - [finally 블록은 프로그램이 중단되거나 함수에서`return`문을 만나도 실행된다.](#finally-블록은-프로그램이-중단되거나-함수에서return문을-만나도-실행된다)
    - [예제 코드와 설명 📝](#예제-코드와-설명-)
      - [🛠 예제1: 예외 처리를 사용한 요소 검색](#-예제1-예외-처리를-사용한-요소-검색)
    - [🌈 else 블록의 사용](#-else-블록의-사용)
      - [else 블록은 try 블록에서 예외가 발생하지 않았을 때 실행되는 코드를 포함. 이 예제에서는 try 블록이 성공적으로 실행되면, 즉, z가 리스트 name 내에 존재하면, 'Ok! else.' 메시지를 출력.](#else-블록은-try-블록에서-예외가-발생하지-않았을-때-실행되는-코드를-포함-이-예제에서는-try-블록이-성공적으로-실행되면-즉-z가-리스트-name-내에-존재하면-ok-else-메시지를-출력)
    - [📌 기억해야 할 사항](#-기억해야-할-사항-9)
      - [예외 처리를 사용하면 프로그램의 안정성을 높일 수 있다. 예상치 못한 상황에서 프로그램이 중단되지 않도록 하고, 적절한 예외 메시지를 통해 사용자에게 유용한 피드백을 제공할 수 있다.](#예외-처리를-사용하면-프로그램의-안정성을-높일-수-있다-예상치-못한-상황에서-프로그램이-중단되지-않도록-하고-적절한-예외-메시지를-통해-사용자에게-유용한-피드백을-제공할-수-있다)
      - [try-except 블록은 예상할 수 있는 오류를 처리하는 데 사용되며, else 블록은 예외가 발생하지 않았을 때 추가적인 작업을 수행하는 데 사용.](#try-except-블록은-예상할-수-있는-오류를-처리하는-데-사용되며-else-블록은-예외가-발생하지-않았을-때-추가적인-작업을-수행하는-데-사용)
    - [예제2: 모든 예외 잡기](#예제2-모든-예외-잡기)
      - [작동 방식](#작동-방식)
    - [📌 주의사항](#-주의사항-1)
      - [가능하면 except 블록에서는 구체적인 예외 유형을 명시하는 것이 좋다. 이렇게 함으로써 예상치 못한 다른 유형의 예외가 발생했을 때, 그것을 놓치지 않고 적절하게 처리할 수 있다.](#가능하면-except-블록에서는-구체적인-예외-유형을-명시하는-것이-좋다-이렇게-함으로써-예상치-못한-다른-유형의-예외가-발생했을-때-그것을-놓치지-않고-적절하게-처리할-수-있다)
      - ['Not found it! - Occurred ValueError!' 메시지는 ValueError를 가정하고 있지만, except 블록이 모든 예외를 잡기 때문에, 실제로는 다른 종류의 예외가 발생해도 동일한 메시지가 출력된다.](#not-found-it---occurred-valueerror-메시지는-valueerror를-가정하고-있지만-except-블록이-모든-예외를-잡기-때문에-실제로는-다른-종류의-예외가-발생해도-동일한-메시지가-출력된다)
    - [예제3: 예외 정보 출력 및 마무리 작업](#예제3-예외-정보-출력-및-마무리-작업)
      - [작동 방식](#작동-방식-1)
    - [📌 주의사항](#-주의사항-2)
    - [예제4: raise를 이용한 예외 발생](#예제4-raise를-이용한-예외-발생)
    - [작동 방식](#작동-방식-2)
    - [📌 주의사항](#-주의사항-3)
- [파이썬 내장(Built-in) 함수 실습 📘](#파이썬-내장built-in-함수-실습-)
    - [abs() 함수의 사용법 🛠](#abs-함수의-사용법-)
      - [abs() 함수는 파이썬에서 제공하는 내장 함수 중 하나로, 주어진 숫자의 절대값을 반환. 📏✨](#abs-함수는-파이썬에서-제공하는-내장-함수-중-하나로-주어진-숫자의-절대값을-반환-)
      - [구문: abs(x)](#구문-absx)
      - [예제 코드](#예제-코드-1)
      - [이 예제에서 abs() 함수에 -3을 인자로 넣었을 때, 3을 반환합니다. -3의 절대값이 3이기 때문.](#이-예제에서-abs-함수에--3을-인자로-넣었을-때-3을-반환합니다--3의-절대값이-3이기-때문)
      - [추가 정보](#추가-정보)
      - [abs() 함수는 음수를 양수로 변환하는 가장 간단한 방법. 이 함수는 금융, 과학 계산, 데이터 분석 등 다양한 분야에서 에러나 차이의 크기를 계산할 때 유용하게 사용.](#abs-함수는-음수를-양수로-변환하는-가장-간단한-방법-이-함수는-금융-과학-계산-데이터-분석-등-다양한-분야에서-에러나-차이의-크기를-계산할-때-유용하게-사용)
      - [복소수에 abs()를 사용하면, 해당 복소수의 크기(복소 평면에서 원점으로부터의 거리)를 반환. 예를 들어, 복소수 3 + 4j의 크기는 5.](#복소수에-abs를-사용하면-해당-복소수의-크기복소-평면에서-원점으로부터의-거리를-반환-예를-들어-복소수-3--4j의-크기는-5)
      - [abs() 함수는 파이썬 프로그래밍에서 자주 사용되는 기본적이면서도 중요한 함수 중 하나로, 코드 내에서 수치 데이터의 절대값을 쉽게 구할 수 있게 도와줌.](#abs-함수는-파이썬-프로그래밍에서-자주-사용되는-기본적이면서도-중요한-함수-중-하나로-코드-내에서-수치-데이터의-절대값을-쉽게-구할-수-있게-도와줌)
    - [all() 함수 🔄✅](#all-함수-)
      - [all()과 any() 함수는 파이썬의 내장 함수로, iterable 객체(리스트, 튜플, 딕셔너리 등) 내의 모든 요소를 검사하여 참 또는 거짓을 반환. 이들 함수는 조건문 내에서 또는 복잡한 조건을 간결하게 표현할 때 유용하게 사용. 🔄✅](#all과-any-함수는-파이썬의-내장-함수로-iterable-객체리스트-튜플-딕셔너리-등-내의-모든-요소를-검사하여-참-또는-거짓을-반환-이들-함수는-조건문-내에서-또는-복잡한-조건을-간결하게-표현할-때-유용하게-사용-)
      - [이 예제에서 \[1, 2, 3\] 리스트의 모든 요소는 Boolean 평가 시 True로 간주되므로, all(\[1, 2, 3\])은 True를 반환.](#이-예제에서-1-2-3-리스트의-모든-요소는-boolean-평가-시-true로-간주되므로-all1-2-3은-true를-반환)
    - [any() 함수 🔄✅](#any-함수-)
      - [\[1, 2, 0\] 리스트에서 0을 제외한 모든 요소는 Boolean 평가 시 True. 따라서, any(\[1, 2, 0\])은 True를 반환.](#1-2-0-리스트에서-0을-제외한-모든-요소는-boolean-평가-시-true-따라서-any1-2-0은-true를-반환)
      - [📌 기억해야 할 사항](#-기억해야-할-사항-10)
      - [all() 함수는 iterable 내의 모든 요소가 참이어야 True를 반환하는 반면, any() 함수는 하나의 요소라도 참이면 True를 반환.](#all-함수는-iterable-내의-모든-요소가-참이어야-true를-반환하는-반면-any-함수는-하나의-요소라도-참이면-true를-반환)
      - [이러한 함수들은 조건이 여러 개 있을 때 코드를 간결하게 만들어주며, 특히 데이터의 유효성 검사나 조건 충족 여부를 확인할 때 유용.](#이러한-함수들은-조건이-여러-개-있을-때-코드를-간결하게-만들어주며-특히-데이터의-유효성-검사나-조건-충족-여부를-확인할-때-유용)
      - [all()과 any() 함수를 사용함으로써 복잡한 조건문을 간결하게 표현하고, 코드의 가독성을 향상시킬 수 있다. 🚀](#all과-any-함수를-사용함으로써-복잡한-조건문을-간결하게-표현하고-코드의-가독성을-향상시킬-수-있다-)
    - [hr() 함수: 아스키 코드를 문자로 변환 🔄](#hr-함수-아스키-코드를-문자로-변환-)
      - [구문: chr(i)](#구문-chri)
      - [구문: ord(c)](#구문-ordc)
      - [이러한 함수들은 파이썬에서 문자와 관련된 다양한 작업을 할 때 기본적으로 알고 있어야 하는 함수들 중 하나. 🚀](#이러한-함수들은-파이썬에서-문자와-관련된-다양한-작업을-할-때-기본적으로-알고-있어야-하는-함수들-중-하나-)
    - [enumerate() 함수 사용법](#enumerate-함수-사용법)
      - [enumerate() 함수는 파이썬의 내장 함수로, 순회 가능한(iterable) 객체들을 인덱스와 함께 순회할 수 있게 도와준다. 이 함수는 순회하는 객체의 인덱스와 값을 튜플 형태로 반환. 🔄🔢](#enumerate-함수는-파이썬의-내장-함수로-순회-가능한iterable-객체들을-인덱스와-함께-순회할-수-있게-도와준다-이-함수는-순회하는-객체의-인덱스와-값을-튜플-형태로-반환-)
      - [enumerate() 함수를 사용하면 반복문에서 객체의 인덱스와 값을 동시에 쉽게 얻을 수 있다. 이는 특히 리스트나 문자열 같은 순서가 있는 데이터를 다룰 때 유용.](#enumerate-함수를-사용하면-반복문에서-객체의-인덱스와-값을-동시에-쉽게-얻을-수-있다-이는-특히-리스트나-문자열-같은-순서가-있는-데이터를-다룰-때-유용)
    - [예제 코드](#예제-코드-2)
        - [출력 결과](#출력-결과)
      - [📌 기억해야 할 사항](#-기억해야-할-사항-11)
      - [enumerate() 함수는 기본적으로 0부터 인덱싱을 시작. 시작 인덱스를 변경하고 싶다면, enumerate(iterable, start=1)과 같이 start 매개변수에 원하는 시작 인덱스를 지정할 수 있다.](#enumerate-함수는-기본적으로-0부터-인덱싱을-시작-시작-인덱스를-변경하고-싶다면-enumerateiterable-start1과-같이-start-매개변수에-원하는-시작-인덱스를-지정할-수-있다)
      - [이 함수는 리스트, 튜플, 문자열 등 다양한 순회 가능한 객체와 함께 사용될 수 있다.](#이-함수는-리스트-튜플-문자열-등-다양한-순회-가능한-객체와-함께-사용될-수-있다)
    - [filter() 함수 사용법](#filter-함수-사용법)
      - [filter() 함수는 반복 가능한(iterable) 객체에서 특정 조건을 만족하는 요소만을 추출하여 새로운 이터레이터를 생성하는 파이썬의 내장 함수. 이 함수는 주로 데이터를 필터링할 때 사용되며, 함수와 반복 가능한 객체를 인자로 받는다. 🚿🔍](#filter-함수는-반복-가능한iterable-객체에서-특정-조건을-만족하는-요소만을-추출하여-새로운-이터레이터를-생성하는-파이썬의-내장-함수-이-함수는-주로-데이터를-필터링할-때-사용되며-함수와-반복-가능한-객체를-인자로-받는다-)
      - [구문: filter(function, iterable)](#구문-filterfunction-iterable)
      - [매개변수:](#매개변수)
      - [function: 각 요소에 적용될 함수. 이 함수는 각 요소를 인자로 받아 True 또는 False를 반환해야 한다.](#function-각-요소에-적용될-함수-이-함수는-각-요소를-인자로-받아-true-또는-false를-반환해야-한다)
      - [iterable: 필터링될 반복 가능한 객체(리스트, 튜플 등).](#iterable-필터링될-반복-가능한-객체리스트-튜플-등)
      - [반환값: 조건에 맞는 요소들로 이루어진 새로운 이터레이터.](#반환값-조건에-맞는-요소들로-이루어진-새로운-이터레이터)
    - [예제 코드](#예제-코드-3)
      - [첫 번째 예제에서 conv\_pos 함수는 절대값이 2보다 큰지를 평가하여 True 또는 False를 반환. filter() 함수는 이 평가 결과가 True인 요소만을 추출.](#첫-번째-예제에서-conv_pos-함수는-절대값이-2보다-큰지를-평가하여-true-또는-false를-반환-filter-함수는-이-평가-결과가-true인-요소만을-추출)
      - [두 번째 예제에서는 람다 함수를 사용하여 동일한 조건을 한 줄로 간결하게 표현하고 있다.](#두-번째-예제에서는-람다-함수를-사용하여-동일한-조건을-한-줄로-간결하게-표현하고-있다)
    - [출력 결과](#출력-결과-1)
      - [두 예제 모두 \[1, -3, 2, 0, -5, 6\] 리스트에서 절대값이 2보다 큰 요소인 \[-3, -5, 6\]을 추출하여 출력.](#두-예제-모두-1--3-2-0--5-6-리스트에서-절대값이-2보다-큰-요소인--3--5-6을-추출하여-출력)
    - [📌 기억해야 할 사항](#-기억해야-할-사항-12)
    - [id() 함수의 사용](#id-함수의-사용)
      - [id() 함수는 파이썬의 내장 함수로, 주어진 객체의 "정체성(identity)"을 나타내는 고유한 정수를 반환. 이 정수는 객체의 메모리 주소를 기반으로 하며, 프로그램 실행 동안 객체에 대해 고유하게 유지. 🆔✨](#id-함수는-파이썬의-내장-함수로-주어진-객체의-정체성identity을-나타내는-고유한-정수를-반환-이-정수는-객체의-메모리-주소를-기반으로-하며-프로그램-실행-동안-객체에-대해-고유하게-유지-)
    - [예제 코드](#예제-코드-4)
    - [출력 결과에 대한 이해](#출력-결과에-대한-이해)
    - [📌 기억해야 할 사항](#-기억해야-할-사항-13)
      - [id() 함수를 사용하여 두 객체가 실제로 같은 객체인지(즉, 메모리상 동일한 위치에 있는지) 확인할 수 있다.](#id-함수를-사용하여-두-객체가-실제로-같은-객체인지즉-메모리상-동일한-위치에-있는지-확인할-수-있다)
      - [파이썬에서 변수는 단지 이름일 뿐이며, id() 함수는 변수가 참조하는 객체의 고유한 정체성을 확인하는 데 사용된다.](#파이썬에서-변수는-단지-이름일-뿐이며-id-함수는-변수가-참조하는-객체의-고유한-정체성을-확인하는-데-사용된다)
      - [객체의 값이 같다고 해서 id() 값이 반드시 같은 것은 아니다. 값이 같은 두 개의 독립적인 객체는 서로 다른 메모리 주소를 가질 수 있다.](#객체의-값이-같다고-해서-id-값이-반드시-같은-것은-아니다-값이-같은-두-개의-독립적인-객체는-서로-다른-메모리-주소를-가질-수-있다)
      - [id() 함수는 디버깅이나 객체의 정체성을 확인할 때 유용하게 사용될 수 있다. 🚀](#id-함수는-디버깅이나-객체의-정체성을-확인할-때-유용하게-사용될-수-있다-)
    - [len() 함수 사용법](#len-함수-사용법)
      - [len() 함수는 파이썬의 내장 함수로, 주어진 컨테이너(예: 문자열, 리스트, 튜플, 딕셔너리 등)의 요소 개수를 반환. 이 함수는 컨테이너에 포함된 요소의 "길이"를 알고 싶을 때 매우 유용하게 사용. 📏✨](#len-함수는-파이썬의-내장-함수로-주어진-컨테이너예-문자열-리스트-튜플-딕셔너리-등의-요소-개수를-반환-이-함수는-컨테이너에-포함된-요소의-길이를-알고-싶을-때-매우-유용하게-사용-)
    - [예제 코드](#예제-코드-5)
    - [📌 기억해야 할 사항](#-기억해야-할-사항-14)
    - [max() 함수: 최대값 찾기](#max-함수-최대값-찾기)
      - [max()와 min() 함수는 파이썬의 내장 함수로, 주어진 컬렉션(예: 리스트, 문자열, 튜플 등) 내에서 최대값이나 최소값을 찾아 반환. 이 함수들은 데이터 분석, 알고리즘 구현 등 다양한 상황에서 유용하게 사용. 🚀✨](#max와-min-함수는-파이썬의-내장-함수로-주어진-컬렉션예-리스트-문자열-튜플-등-내에서-최대값이나-최소값을-찾아-반환-이-함수들은-데이터-분석-알고리즘-구현-등-다양한-상황에서-유용하게-사용-)
    - [min() 함수: 최소값 찾기](#min-함수-최소값-찾기)
    - [예제 코드](#예제-코드-6)
    - [📌 기억해야 할 사항](#-기억해야-할-사항-15)
    - [map() 함수 사용법](#map-함수-사용법)
      - [map() 함수는 파이썬의 내장 함수로, 주어진 함수를 반복 가능한(iterable) 객체의 각 요소에 적용한 후, 그 결과를 반환. 이를 통해 원본 리스트를 변환하거나 정보를 추출하는 등의 작업을 간단히 처리할 수 있다. 🔄🔧](#map-함수는-파이썬의-내장-함수로-주어진-함수를-반복-가능한iterable-객체의-각-요소에-적용한-후-그-결과를-반환-이를-통해-원본-리스트를-변환하거나-정보를-추출하는-등의-작업을-간단히-처리할-수-있다-)
    - [예제 코드](#예제-코드-7)
    - [출력 결과](#출력-결과-2)
    - [📌 기억해야 할 사항](#-기억해야-할-사항-16)
    - [pow() 함수 사용법](#pow-함수-사용법)
      - [pow() 함수는 파이썬의 내장 함수로, 주어진 숫자의 거듭제곱 값을 계산합니다. 이 함수는 두 개의 필수 인자를 받으며, 세 번째 인자는 선택적. 🚀✨](#pow-함수는-파이썬의-내장-함수로-주어진-숫자의-거듭제곱-값을-계산합니다-이-함수는-두-개의-필수-인자를-받으며-세-번째-인자는-선택적-)
    - [예제 코드](#예제-코드-8)
    - [출력 결과](#출력-결과-3)
    - [📌 기억해야 할 사항](#-기억해야-할-사항-17)
    - [range() 함수 사용법](#range-함수-사용법)
      - [range() 함수는 주어진 시작점, 끝점, 스텝(간격)을 기반으로 일련의 숫자를 포함하는 반복 가능한 객체를 생성. 이 함수는 주로 반복문에서 숫자 시퀀스를 생성하는 데 사용. 🔄🔢](#range-함수는-주어진-시작점-끝점-스텝간격을-기반으로-일련의-숫자를-포함하는-반복-가능한-객체를-생성-이-함수는-주로-반복문에서-숫자-시퀀스를-생성하는-데-사용-)
    - [예제 코드](#예제-코드-9)
    - [출력 결과](#출력-결과-4)
    - [📌 기억해야 할 사항](#-기억해야-할-사항-18)
    - [round() 함수 사용법](#round-함수-사용법)
      - [round() 함수는 파이썬의 내장 함수로, 숫자를 반올림하여 주어진 자릿수까지의 값을 반환. 이 함수는 금융 계산, 데이터 처리, 사용자에게 보여줄 결과의 포맷팅 등 다양한 상황에서 유용하게 사용. 🔄💲](#round-함수는-파이썬의-내장-함수로-숫자를-반올림하여-주어진-자릿수까지의-값을-반환-이-함수는-금융-계산-데이터-처리-사용자에게-보여줄-결과의-포맷팅-등-다양한-상황에서-유용하게-사용-)
    - [예제 코드](#예제-코드-10)
    - [출력 결과](#출력-결과-5)
    - [📌 기억해야 할 사항](#-기억해야-할-사항-19)
    - [sorted() 함수 사용법](#sorted-함수-사용법)
      - [sorted() 함수는 파이썬의 내장 함수로, 주어진 반복 가능한 객체(iterable)의 모든 요소를 정렬한 새로운 리스트를 반환. 이 함수는 원본 데이터를 변경하지 않고, 정렬된 새로운 리스트를 만들어내는 특징이 있다. 🔄📈](#sorted-함수는-파이썬의-내장-함수로-주어진-반복-가능한-객체iterable의-모든-요소를-정렬한-새로운-리스트를-반환-이-함수는-원본-데이터를-변경하지-않고-정렬된-새로운-리스트를-만들어내는-특징이-있다-)
    - [예제 코드](#예제-코드-11)
    - [출력 결과](#출력-결과-6)
    - [📌 기억해야 할 사항](#-기억해야-할-사항-20)
    - [sum() 함수 사용법](#sum-함수-사용법)
      - [sum() 함수는 파이썬의 내장 함수로, 반복 가능한 객체(예: 리스트, 튜플, range 객체 등) 내의 모든 요소의 합을 반환. 이 함수는 수치 데이터의 총합을 계산할 때 유용하게 사용. 💰➕](#sum-함수는-파이썬의-내장-함수로-반복-가능한-객체예-리스트-튜플-range-객체-등-내의-모든-요소의-합을-반환-이-함수는-수치-데이터의-총합을-계산할-때-유용하게-사용-)
    - [예제 코드](#예제-코드-12)
    - [출력 결과](#출력-결과-7)
    - [📌 기억해야 할 사항](#-기억해야-할-사항-21)
    - [type() 함수 사용법](#type-함수-사용법)
    - [type() 함수는 파이썬의 내장 함수로, 주어진 객체의 타입(자료형)을 반환. 이 함수는 개발과 디버깅 과정에서 객체의 타입을 확인할 때 유용하게 사용. 🕵️‍♂️🔍](#type-함수는-파이썬의-내장-함수로-주어진-객체의-타입자료형을-반환-이-함수는-개발과-디버깅-과정에서-객체의-타입을-확인할-때-유용하게-사용-️️)
    - [예제 코드](#예제-코드-13)
    - [출력 결과](#출력-결과-8)
    - [📌 기억해야 할 사항](#-기억해야-할-사항-22)
    - [zip() 함수 사용법](#zip-함수-사용법)
      - [zip() 함수는 파이썬의 내장 함수로, 여러 개의 반복 가능한(iterable) 객체들을 인자로 받아, 각 객체들의 요소를 튜플로 묶어서 반환. 이 함수는 여러 데이터 그룹을 동시에 루프 돌면서 처리할 때 매우 유용. 🔄🔗](#zip-함수는-파이썬의-내장-함수로-여러-개의-반복-가능한iterable-객체들을-인자로-받아-각-객체들의-요소를-튜플로-묶어서-반환-이-함수는-여러-데이터-그룹을-동시에-루프-돌면서-처리할-때-매우-유용-)
    - [예제 코드](#예제-코드-14)
    - [출력 결과](#출력-결과-9)
    - [📌 기억해야 할 사항](#-기억해야-할-사항-23)
- [파이썬 외장(External) 함수 🌐🛠](#파이썬-외장external-함수-)
      - [파이썬 외장 함수는 표준 라이브러리의 일부로, 다양한 목적에 맞는 프로그램 개발을 지원. 실제 프로그램 개발 시 자주 사용되는 sys, pickle, os, shutil, glob, tempfile, time, random 등의 모듈을 포함. 이러한 함수들은 파일 시스템 처리, 데이터 직렬화, 시간 처리, 난수 생성 등 다양한 시스템 및 프로그램 작업에 유용하게 사용.](#파이썬-외장-함수는-표준-라이브러리의-일부로-다양한-목적에-맞는-프로그램-개발을-지원-실제-프로그램-개발-시-자주-사용되는-sys-pickle-os-shutil-glob-tempfile-time-random-등의-모듈을-포함-이러한-함수들은-파일-시스템-처리-데이터-직렬화-시간-처리-난수-생성-등-다양한-시스템-및-프로그램-작업에-유용하게-사용)
      - [sys 모듈은 파이썬에서 시스템 관련 정보와 기능을 다룰 때 사용하는 외장 모듈. 프로그램의 실행 환경을 제어하고, 파이썬 인터프리터에 대한 정보에 접근할 수 있게 해주며, 프로그램을 직접적으로 종료시키는 등의 작업을 수행할 수 있다. 🛠️🔧](#sys-모듈은-파이썬에서-시스템-관련-정보와-기능을-다룰-때-사용하는-외장-모듈-프로그램의-실행-환경을-제어하고-파이썬-인터프리터에-대한-정보에-접근할-수-있게-해주며-프로그램을-직접적으로-종료시키는-등의-작업을-수행할-수-있다-️)
      - [sys 모듈의 주요 기능](#sys-모듈의-주요-기능)
      - [명령줄 인수 접근 (sys.argv): 프로그램 실행 시 명령줄을 통해 전달된 인수들에 접근할 수 있다. 이를 통해 사용자가 프로그램을 시작할 때 옵션을 지정하거나 입력 값을 제공할 수 있다. 📋✨](#명령줄-인수-접근-sysargv-프로그램-실행-시-명령줄을-통해-전달된-인수들에-접근할-수-있다-이를-통해-사용자가-프로그램을-시작할-때-옵션을-지정하거나-입력-값을-제공할-수-있다-)
    - [`sys.argv`를 사용하면 파이썬 스크립트를 실행할 때 명령줄에서 전달된 인수들을 캡처할 수 있다. 이를 통해 스크립트의 동작을 동적으로 제어할 수 있는 옵션을 제공하게 된다. 예를 들어, 스크립트에 파일 이름을 인수로 전달하거나, 실행에 필요한 설정 값을 명령줄에서 지정할 수 있다. 아래는 sys.argv 사용의 간단한 예제:](#sysargv를-사용하면-파이썬-스크립트를-실행할-때-명령줄에서-전달된-인수들을-캡처할-수-있다-이를-통해-스크립트의-동작을-동적으로-제어할-수-있는-옵션을-제공하게-된다-예를-들어-스크립트에-파일-이름을-인수로-전달하거나-실행에-필요한-설정-값을-명령줄에서-지정할-수-있다-아래는-sysargv-사용의-간단한-예제)
      - [이 스크립트를 example.py라는 이름으로 저장하고, 명령줄에서 다음과 같이 실행한다고 가정:](#이-스크립트를-examplepy라는-이름으로-저장하고-명령줄에서-다음과-같이-실행한다고-가정)
      - [여기서 sys.argv는 \['example.py', 'arg1', 'arg2'\]라는 리스트를 담고 있으며, 이 리스트의 첫 번째 요소는 실행된 스크립트의 이름이고, 나머지 요소들은 스크립트에 전달된 인수들.](#여기서-sysargv는-examplepy-arg1-arg2라는-리스트를-담고-있으며-이-리스트의-첫-번째-요소는-실행된-스크립트의-이름이고-나머지-요소들은-스크립트에-전달된-인수들)
      - [`sys.argv`를 사용함으로써 스크립트에 대한 유연성을 크게 높일 수 있으며, 스크립트를 더 다양한 상황에 맞게 조정할 수 있다.](#sysargv를-사용함으로써-스크립트에-대한-유연성을-크게-높일-수-있으며-스크립트를-더-다양한-상황에-맞게-조정할-수-있다)
  - [파이썬 외장 함수: sys와 pickle 모듈 📚💾](#파이썬-외장-함수-sys와-pickle-모듈-)
    - [파이썬의 외장 함수들은 프로그램 개발 시 필요한 다양한 기능을 제공한다. 여기서는 sys와 pickle 모듈의 기본적인 사용 방법을 살펴보자.](#파이썬의-외장-함수들은-프로그램-개발-시-필요한-다양한-기능을-제공한다-여기서는-sys와-pickle-모듈의-기본적인-사용-방법을-살펴보자)
    - [sys 모듈: 실행 관련 제어 🚦](#sys-모듈-실행-관련-제어-)
      - [sys 모듈은 파이썬 인터프리터와 밀접하게 관련된 기능들을 제공.](#sys-모듈은-파이썬-인터프리터와-밀접하게-관련된-기능들을-제공)
    - [예제1: 명령줄 인수 출력 📋](#예제1-명령줄-인수-출력-)
      - [스크립트에 전달된 인수들을 리스트로 출력.](#스크립트에-전달된-인수들을-리스트로-출력)
      - [첫 번째 인수는 항상 스크립트 파일의 이름.](#첫-번째-인수는-항상-스크립트-파일의-이름)
    - [예제2: 프로그램 강제 종료 🛑](#예제2-프로그램-강제-종료-)
      - [주석을 해제하고 실행하면, 이 코드가 실행되는 지점에서 프로그램이 종료(주의!)).](#주석을-해제하고-실행하면-이-코드가-실행되는-지점에서-프로그램이-종료주의)
      - [sys.exit()](#sysexit)
    - [예제3: 파이썬 패키지 위치 🔍](#예제3-파이썬-패키지-위치-)
      - [파이썬이 모듈을 검색할 때 참조하는 경로 목록을 출력.](#파이썬이-모듈을-검색할-때-참조하는-경로-목록을-출력)
    - [pickle 모듈: 객체 파일 쓰기 및 읽기 📁](#pickle-모듈-객체-파일-쓰기-및-읽기-)
    - [pickle 모듈은 파이썬 객체를 바이트 스트림으로 직렬화하고, 이를 파일에 저장하거나 파일로부터 객체를 복원하는 기능을 제공.](#pickle-모듈은-파이썬-객체를-바이트-스트림으로-직렬화하고-이를-파일에-저장하거나-파일로부터-객체를-복원하는-기능을-제공)
    - [예제4: 객체를 파일에 쓰기 (직렬화) 📤](#예제4-객체를-파일에-쓰기-직렬화-)
    - [pickle 모듈을 사용해서 파이썬 객체를 파일에 저장하는 과정을 직렬화라고 합니다. 이 과정에서 wb (write binary) 모드로 파일을 열어, 데이터를 바이너리 형태로 파일에 쓰게 된다.](#pickle-모듈을-사용해서-파이썬-객체를-파일에-저장하는-과정을-직렬화라고-합니다-이-과정에서-wb-write-binary-모드로-파일을-열어-데이터를-바이너리-형태로-파일에-쓰게-된다)
    - ['wb' 모드로 파일 열기: 바이너리 쓰기 모드](#wb-모드로-파일-열기-바이너리-쓰기-모드)
      - [pickle.dump() 함수는 파이썬 객체를 받아서 바이너리 형태로 변환(직렬화)하여 파일에 저장. 여기서 obj는 사전 객체이며, 이 객체가 파일에 바이너리 형태로 저장.](#pickledump-함수는-파이썬-객체를-받아서-바이너리-형태로-변환직렬화하여-파일에-저장-여기서-obj는-사전-객체이며-이-객체가-파일에-바이너리-형태로-저장)
    - [예제5: 파일로부터 객체 읽기 (역직렬화) 📥](#예제5-파일로부터-객체-읽기-역직렬화-)
      - [역직렬화는 직렬화된 데이터를 다시 파이썬 객체로 복원하는 과정. rb (read binary) 모드로 파일을 열어, 파일에 저장된 바이너리 데이터를 파이썬 객체로 로드.](#역직렬화는-직렬화된-데이터를-다시-파이썬-객체로-복원하는-과정-rb-read-binary-모드로-파일을-열어-파일에-저장된-바이너리-데이터를-파이썬-객체로-로드)
    - ['rb' 모드로 파일 열기: 바이너리 읽기 모드](#rb-모드로-파일-열기-바이너리-읽기-모드)
      - [pickle.load() 함수는 파일로부터 바이너리 데이터를 읽어 원래의 파이썬 객체로 복원(역직렬화)한다. 이 과정을 통해 파일에 저장된 데이터를 다시 파이썬에서 사용할 수 있는 객체 형태로 불러올 수 있다.](#pickleload-함수는-파일로부터-바이너리-데이터를-읽어-원래의-파이썬-객체로-복원역직렬화한다-이-과정을-통해-파일에-저장된-데이터를-다시-파이썬에서-사용할-수-있는-객체-형태로-불러올-수-있다)
    - [요약](#요약)
      - [pickle 모듈은 파이썬 객체를 파일에 저장하고(직렬화), 파일로부터 다시 파이썬 객체를 복원할 수 있게 해주는(역직렬화) 매우 유용한 모듈. 데이터를 영구적으로 저장하고 필요할 때 다시 불러와 사용해야 하는 경우에 이 모듈이 특히 유용.](#pickle-모듈은-파이썬-객체를-파일에-저장하고직렬화-파일로부터-다시-파이썬-객체를-복원할-수-있게-해주는역직렬화-매우-유용한-모듈-데이터를-영구적으로-저장하고-필요할-때-다시-불러와-사용해야-하는-경우에-이-모듈이-특히-유용)
  - [s 모듈: 환경 변수 및 파일 시스템 접근 🗂️🌍](#s-모듈-환경-변수-및-파일-시스템-접근-️)
      - [os 모듈은 운영 체제와 상호 작용하는 다양한 기능을 제공. 환경 변수의 접근, 파일 및 디렉토리의 관리(생성, 삭제, 이름 변경) 등 운영 체제 수준의 다양한 작업을 수행할 수 있다.](#os-모듈은-운영-체제와-상호-작용하는-다양한-기능을-제공-환경-변수의-접근-파일-및-디렉토리의-관리생성-삭제-이름-변경-등-운영-체제-수준의-다양한-작업을-수행할-수-있다)
    - [예제6: 환경 변수 접근 🌱](#예제6-환경-변수-접근-)
      - [os.environ은 현재 시스템의 환경 변수들을 담고 있는 사전(dict) 객체.](#osenviron은-현재-시스템의-환경-변수들을-담고-있는-사전dict-객체)
      - ['USERNAME' 환경 변수를 통해 현재 사용자 이름을 알 수 있다.](#username-환경-변수를-통해-현재-사용자-이름을-알-수-있다)
    - [예제7: 현재 작업 디렉토리 조회 📂](#예제7-현재-작업-디렉토리-조회-)
      - [`os.getcwd()` 함수는 현재 파이썬 스크립트가 실행되고 있는 디렉토리의 경로를 반환.](#osgetcwd-함수는-현재-파이썬-스크립트가-실행되고-있는-디렉토리의-경로를-반환)
    - [주요 기능과 사용법](#주요-기능과-사용법)
      - [활용 예시](#활용-예시)
    - [time 모듈: 시간 관련 처리 ⏰🔄](#time-모듈-시간-관련-처리-)
      - [time 모듈은 시간에 관련된 다양한 기능을 제공. 현재 시간 조회, 시간 형식 변환, 지연 시간 생성 등 프로그램 내에서 시간을 다룰 때 필요한 작업을 수행할 수 있다.](#time-모듈은-시간에-관련된-다양한-기능을-제공-현재-시간-조회-시간-형식-변환-지연-시간-생성-등-프로그램-내에서-시간을-다룰-때-필요한-작업을-수행할-수-있다)
    - [예제8: 현재 시간을 에포크 시간으로 출력하기](#예제8-현재-시간을-에포크-시간으로-출력하기)
      - [에포크 시간(Epoch time): 1970년 1월 1일 00:00:00부터 현재까지의 초를 나타낸다.](#에포크-시간epoch-time-1970년-1월-1일-000000부터-현재까지의-초를-나타낸다)
    - [예제9: 현재 시간을 구조화된 시간으로 변환하기](#예제9-현재-시간을-구조화된-시간으로-변환하기)
      - [구조화된 시간(tm struct): 연, 월, 일, 시, 분, 초 등으로 구성된 시간 정보.](#구조화된-시간tm-struct-연-월-일-시-분-초-등으로-구성된-시간-정보)
    - [예제10: 현재 시간을 간단한 문자열 형태로 출력하기](#예제10-현재-시간을-간단한-문자열-형태로-출력하기)
      - [ctime 함수는 주어진 시간(초)을 인간이 읽을 수 있는 형태로 변환.](#ctime-함수는-주어진-시간초을-인간이-읽을-수-있는-형태로-변환)
    - [예제11: 현재 시간을 지정된 형식의 문자열로 출력하기](#예제11-현재-시간을-지정된-형식의-문자열로-출력하기)
      - [strftime 함수는 사용자가 지정한 형식으로 시간을 문자열로 변환.](#strftime-함수는-사용자가-지정한-형식으로-시간을-문자열로-변환)
    - [예제12: 시간 간격을 두고 숫자 출력하기](#예제12-시간-간격을-두고-숫자-출력하기)
      - [sleep 함수는 프로그램을 지정된 시간(초) 동안 일시 정지.](#sleep-함수는-프로그램을-지정된-시간초-동안-일시-정지)
    - [🔎 출력값 설명:](#-출력값-설명)
    - [예제13: 0과 1 사이의 실수형 난수 생성](#예제13-0과-1-사이의-실수형-난수-생성)
      - [random.random()은 0.0 이상 1.0 미만의 실수 난수를 반환.](#randomrandom은-00-이상-10-미만의-실수-난수를-반환)
    - [예제14: 지정된 범위 내의 정수형 난수 생성](#예제14-지정된-범위-내의-정수형-난수-생성)
      - [random.randint(a, b)는 a 이상 b 이하의 정수형 난수를 반환.](#randomrandinta-b는-a-이상-b-이하의-정수형-난수를-반환)
      - [random.randrange(start, stop)는 start 이상 stop 미만의 정수형 난수를 반환.](#randomrandrangestart-stop는-start-이상-stop-미만의-정수형-난수를-반환)
    - [예제15: 리스트의 요소를 무작위로 섞기](#예제15-리스트의-요소를-무작위로-섞기)
      - [random.shuffle(x) 함수는 리스트 x의 요소들을 무작위로 섞는다.](#randomshufflex-함수는-리스트-x의-요소들을-무작위로-섞는다)
    - [예제16: 리스트에서 무작위 요소 하나 선택하기](#예제16-리스트에서-무작위-요소-하나-선택하기)
      - [random.choice(seq) 함수는 주어진 시퀀스 seq에서 무작위로 요소 하나를 선택하여 반환.](#randomchoiceseq-함수는-주어진-시퀀스-seq에서-무작위로-요소-하나를-선택하여-반환)
    - [🔍 주요 포인트와 활용법](#-주요-포인트와-활용법)
    - [🌐 웹 브라우저 자동 실행하기: webbrowser 모듈 사용하기](#-웹-브라우저-자동-실행하기-webbrowser-모듈-사용하기)
      - [webbrowser 모듈은 파이썬 스크립트에서 웹 브라우저를 자동으로 실행하게 해주는 간단하고 편리한 방법을 제공. 이 모듈을 사용하면 사용자의 기본 웹 브라우저를 통해 특정 URL을 열 수 있다.](#webbrowser-모듈은-파이썬-스크립트에서-웹-브라우저를-자동으로-실행하게-해주는-간단하고-편리한-방법을-제공-이-모듈을-사용하면-사용자의-기본-웹-브라우저를-통해-특정-url을-열-수-있다)
    - [예제17: 기본 웹 브라우저에서 URL 열기 🌍](#예제17-기본-웹-브라우저에서-url-열기-)
      - [webbrowser.open(url) 함수는 새 탭이나 창에서 지정된 URL을 엽니다.](#webbrowseropenurl-함수는-새-탭이나-창에서-지정된-url을-엽니다)
      - [webbrowser.open\_new(url) 함수는 가능한 새 창에서 지정된 URL을 엽니다.](#webbrowseropen_newurl-함수는-가능한-새-창에서-지정된-url을-엽니다)
    - [🔍 주요 포인트와 활용법](#-주요-포인트와-활용법-1)
    - [활용 예시](#활용-예시-1)
  - [🔄 복습 중요한것 🔄](#-복습-중요한것-)
    - [📦 pickle 모듈: 파이썬 객체 직렬화 🔄](#-pickle-모듈-파이썬-객체-직렬화-)
    - [⏰ time 모듈: 시간 관련 기능 ⌛](#-time-모듈-시간-관련-기능-)
    - [🗂 os 모듈: 운영체제와 상호작용 🖥](#-os-모듈-운영체제와-상호작용-)
    - [🚦 sys 모듈: 시스템 관련 정보 접근 🛠](#-sys-모듈-시스템-관련-정보-접근-)
      - [각 모듈은 파이썬 프로그래밍에서 자주 사용되며, 데이터의 저장 및 복원, 시간 관련 작업, 파일 및 디렉토리 관리, 시스템과의 상호작용 등 다양한 영역에서 중요한 역할을 한다. 비전공자도 이해하기 쉽게 접근할 수 있도록 기본 개념과 주요 사용 시나리오를 중심으로 학습하는 것이 좋다.](#각-모듈은-파이썬-프로그래밍에서-자주-사용되며-데이터의-저장-및-복원-시간-관련-작업-파일-및-디렉토리-관리-시스템과의-상호작용-등-다양한-영역에서-중요한-역할을-한다-비전공자도-이해하기-쉽게-접근할-수-있도록-기본-개념과-주요-사용-시나리오를-중심으로-학습하는-것이-좋다)
- [파일 읽기 및 쓰기 📖✍️](#파일-읽기-및-쓰기-️)
      - [파일을 다루는 기본적인 작업은 파일을 읽고, 쓰는 것. 파이썬에서는 이러한 작업을 간단하게 할 수 있는 내장 함수를 제공. 파일을 열 때 사용할 수 있는 다양한 모드와 경로를 지정하는 방법에 대해 알아보자.](#파일을-다루는-기본적인-작업은-파일을-읽고-쓰는-것-파이썬에서는-이러한-작업을-간단하게-할-수-있는-내장-함수를-제공-파일을-열-때-사용할-수-있는-다양한-모드와-경로를-지정하는-방법에-대해-알아보자)
    - [파일 모드와 경로 지정 📁🛠](#파일-모드와-경로-지정-)
      - [파이썬에서 파일을 다루는 기본적인 방법은 파일을 열고(open), 읽거나 쓰고`(read/write)`, 닫는`(close)` 것이다. 이 과정에서 다양한 파일 모드와 경로를 지정할 수 있다.](#파이썬에서-파일을-다루는-기본적인-방법은-파일을-열고open-읽거나-쓰고readwrite-닫는close-것이다-이-과정에서-다양한-파일-모드와-경로를-지정할-수-있다)
    - [파일 모드 📑](#파일-모드-)
      - [읽기 모드 (read): 파일을 읽기 전용으로 엽니다. 파일이 존재하지 않으면 FileNotFoundError 오류가 발생.](#읽기-모드-read-파일을-읽기-전용으로-엽니다-파일이-존재하지-않으면-filenotfounderror-오류가-발생)
      - [쓰기 모드 (write): 파일을 쓰기 전용으로 엽니다. 파일이 이미 존재하면 해당 파일의 내용을 모두 삭제하고 처음부터 씁니다. 파일이 없으면 새로 생성.](#쓰기-모드-write-파일을-쓰기-전용으로-엽니다-파일이-이미-존재하면-해당-파일의-내용을-모두-삭제하고-처음부터-씁니다-파일이-없으면-새로-생성)
      - [추가 모드 (append): 파일의 끝에 새로운 내용을 추가할 때 사용. 파일이 없으면 새로 생성.](#추가-모드-append-파일의-끝에-새로운-내용을-추가할-때-사용-파일이-없으면-새로-생성)
      - [텍스트 모드 (text): 텍스트 파일을 처리할 때 사용. 이는 기본값.](#텍스트-모드-text-텍스트-파일을-처리할-때-사용-이는-기본값)
      - [바이너리 모드 (binary): 바이너리 파일(이미지, 비디오 등)을 처리할 때 사용.](#바이너리-모드-binary-바이너리-파일이미지-비디오-등을-처리할-때-사용)
    - [경로 지정 🗺️](#경로-지정-️)
      - [상대 경로: 현재 작업 중인 디렉토리를 기준으로 파일의 위치를 지정.](#상대-경로-현재-작업-중인-디렉토리를-기준으로-파일의-위치를-지정)
      - [절대 경로: 루트 디렉토리부터 전체 디렉토리 경로를 지정.](#절대-경로-루트-디렉토리부터-전체-디렉토리-경로를-지정)
    - [파일 읽기(Read) 📖✨](#파일-읽기read-)
      - [파일을 읽는 과정은 데이터를 처리하거나 분석하기 위해 필요한 첫 단계. 여기서는 기본적인 파일 읽기 방법과 파일 객체의 주요 속성들을 확인하는 방법에 대해 알아보자.](#파일을-읽는-과정은-데이터를-처리하거나-분석하기-위해-필요한-첫-단계-여기서는-기본적인-파일-읽기-방법과-파일-객체의-주요-속성들을-확인하는-방법에-대해-알아보자)
    - [예제1: 파일 읽기 및 속성 확인](#예제1-파일-읽기-및-속성-확인)
    - [핵심 포인트 및 중요 속성들 🔑](#핵심-포인트-및-중요-속성들-)
      - [속성 확인:](#속성-확인)
    - [이해하고 넘어가야 할 중요 포인트 🧐](#이해하고-넘어가야-할-중요-포인트-)
  - [파일 읽기(Read)의 또 다른 방법: with 문 사용하기 📘🔍](#파일-읽기read의-또-다른-방법-with-문-사용하기-)
      - [파일을 열고 작업한 후 자동으로 닫기 위해` with` 문을 사용하는 방법을 소개한다. 이 방법은 파일을 다룰 때 권장되는 방식 중 하나로, 파일을 올바르게 닫아 자원 누수를 방지하고 코드의 가독성을 높여준다.](#파일을-열고-작업한-후-자동으로-닫기-위해-with-문을-사용하는-방법을-소개한다-이-방법은-파일을-다룰-때-권장되는-방식-중-하나로-파일을-올바르게-닫아-자원-누수를-방지하고-코드의-가독성을-높여준다)
    - [예제2: with 문을 사용한 파일 읽기](#예제2-with-문을-사용한-파일-읽기)
      - [핵심 포인트 🌟](#핵심-포인트-)
    - [중요한 포인트 📌](#중요한-포인트-)
      - [이러한 방법으로 파일을 읽는 작업은 파이썬 프로그래밍의 기본 중 하나. 특히 비전공자도 쉽게 이해할 수 있도록 핵심적인 개념과 사용 방법에 집중하는 것이 중요.](#이러한-방법으로-파일을-읽는-작업은-파이썬-프로그래밍의-기본-중-하나-특히-비전공자도-쉽게-이해할-수-있도록-핵심적인-개념과-사용-방법에-집중하는-것이-중요)
    - [파일 읽기의 고급 기법: 부분 읽기와 커서 조작 📚🔍](#파일-읽기의-고급-기법-부분-읽기와-커서-조작-)
      - [파일에서 데이터를 부분적으로 읽거나, 파일 내의 특정 위치로 커서를 이동시키는 방법을 살펴보자. 이는 큰 파일을 처리하거나, 파일 내 특정 데이터에 접근할 때 유용하게 사용.](#파일에서-데이터를-부분적으로-읽거나-파일-내의-특정-위치로-커서를-이동시키는-방법을-살펴보자-이는-큰-파일을-처리하거나-파일-내-특정-데이터에-접근할-때-유용하게-사용)
    - [예제3: read()와 seek() 메서드 활용하기](#예제3-read와-seek-메서드-활용하기)
    - [핵심 포인트 🌟](#핵심-포인트--1)
      - [read(바이트수) 메서드: read() 메서드에 바이트 수를 지정하면, 해당 크기만큼의 데이터를 파일에서 읽어온다. 지정하지 않으면 파일의 전체 내용을 읽는다.](#read바이트수-메서드-read-메서드에-바이트-수를-지정하면-해당-크기만큼의-데이터를-파일에서-읽어온다-지정하지-않으면-파일의-전체-내용을-읽는다)
    - [중요한 포인트 📌](#중요한-포인트--1)
  - [파일에서 한 줄씩 읽기: readline() 메서드 📝➡️](#파일에서-한-줄씩-읽기-readline-메서드-️)
      - [파일을 처리할 때 특히 텍스트 파일을 한 줄씩 읽어야 하는 경우가 자주 있다. 파이썬의 readline() 메서드를 사용하면 이를 간단히 할 수 있다. 이 방법은 로그 파일 분석, 설정 파일 읽기 등 다양한 상황에서 유용하게 사용.](#파일을-처리할-때-특히-텍스트-파일을-한-줄씩-읽어야-하는-경우가-자주-있다-파이썬의-readline-메서드를-사용하면-이를-간단히-할-수-있다-이-방법은-로그-파일-분석-설정-파일-읽기-등-다양한-상황에서-유용하게-사용)
    - [예제4: readline() 사용하기](#예제4-readline-사용하기)
    - [핵심 포인트 🌟](#핵심-포인트--2)
      - [사용 시나리오 🛠](#사용-시나리오-)
    - [추가 팁 ✨](#추가-팁-)
  - [파일을 라인 단위로 읽고 리스트에 저장하기: readlines() 메서드 📚📃](#파일을-라인-단위로-읽고-리스트에-저장하기-readlines-메서드-)
      - [파일의 내용을 한 번에 모두 읽어 각 줄을 리스트의 아이템으로 저장하고자 할 때 `readlines()` 메서드를 사용할 수 있다. 이 메서드는 특히 파일의 모든 라인을 순회하면서 처리해야 할 때 유용.](#파일의-내용을-한-번에-모두-읽어-각-줄을-리스트의-아이템으로-저장하고자-할-때-readlines-메서드를-사용할-수-있다-이-메서드는-특히-파일의-모든-라인을-순회하면서-처리해야-할-때-유용)
    - [예제5: readlines() 사용하기](#예제5-readlines-사용하기)
    - [핵심 포인트 🌟](#핵심-포인트--3)
    - [사용 시나리오 🛠](#사용-시나리오--1)
    - [추가 팁 ✨](#추가-팁--1)
      - [간단한 처리를 위해서는 파일 객체를 직접 순회하는 방법(`for line in f:`)을 사용하는 것이 메모리 사용 측면에서 더 효율적일 수 있다.](#간단한-처리를-위해서는-파일-객체를-직접-순회하는-방법for-line-in-f을-사용하는-것이-메모리-사용-측면에서-더-효율적일-수-있다)
      - [readlines() 메서드를 사용하면 파일의 모든 줄을 쉽게 리스트로 변환하여 다양한 처리를 할 수 있다. 파일을 다루는 다양한 상황에서 이 메서드를 활용하여 코드를 간결하고 효율적으로 작성할 수 있다.](#readlines-메서드를-사용하면-파일의-모든-줄을-쉽게-리스트로-변환하여-다양한-처리를-할-수-있다-파일을-다루는-다양한-상황에서-이-메서드를-활용하여-코드를-간결하고-효율적으로-작성할-수-있다)
  - [파일 쓰기(Write) 방법들 🖋️📄](#파일-쓰기write-방법들-️)
    - [파이썬에서 제공하는 다양한 방법을 통해 파일에 데이터를 쓰는 과정을 자세히 알아보자. 이 과정은 데이터의 영구 저장, 설정 파일 작성, 로그 기록 등에 활용.](#파이썬에서-제공하는-다양한-방법을-통해-파일에-데이터를-쓰는-과정을-자세히-알아보자-이-과정은-데이터의-영구-저장-설정-파일-작성-로그-기록-등에-활용)
    - [예제1: 기본 텍스트 쓰기](#예제1-기본-텍스트-쓰기)
      - [📝 'w' 모드는 파일이 존재하지 않을 경우 새로운 파일을 생성하고, 이미 존재한다면 그 내용을 모두 지우고 처음부터 쓴다.](#-w-모드는-파일이-존재하지-않을-경우-새로운-파일을-생성하고-이미-존재한다면-그-내용을-모두-지우고-처음부터-쓴다)
    - [예제2: 텍스트 추가하기](#예제2-텍스트-추가하기)
      - [📌 'a' 모드는 기존 파일의 내용을 보존하면서 끝에 추가적인 데이터를 쓸 때 사용.](#-a-모드는-기존-파일의-내용을-보존하면서-끝에-추가적인-데이터를-쓸-때-사용)
    - [예제3: 리스트를 파일에 쓰기](#예제3-리스트를-파일에-쓰기)
      - [🍊🍎 리스트의 각 원소는 파일에 그대로 쓰이며, 원소마다 이미 개행 문자(\\n)가 포함되어 있어서 각 줄에 하나의 원소가 기록된다.](#-리스트의-각-원소는-파일에-그대로-쓰이며-원소마다-이미-개행-문자n가-포함되어-있어서-각-줄에-하나의-원소가-기록된다)
    - [예제4: print 함수를 이용한 파일 쓰기](#예제4-print-함수를-이용한-파일-쓰기)
      - [🖨️ `print` 함수의 `file` 파라미터를 사용하면 콘솔 대신 파일에 직접 출력할 수 있으며, 자동으로 개행이 추가된다.](#️-print-함수의-file-파라미터를-사용하면-콘솔-대신-파일에-직접-출력할-수-있으며-자동으로-개행이-추가된다)
      - [핵심 포인트 🌟](#핵심-포인트--4)
    - [사용 시나리오 🛠](#사용-시나리오--2)
    - [중요 포인트와 사용 시나리오 📌](#중요-포인트와-사용-시나리오-)
  - [CSV 파일 읽기 및 쓰기 📝🔀](#csv-파일-읽기-및-쓰기-)
    - [`CSV(Comma-Separated Values)` 파일은 간단한 텍스트 파일로, 데이터를 쉼표(,)로 구분하여 저장합니다. 이 형식은 테이블 데이터를 저장하고 공유하기 위한 가장 일반적인 방법 중 하나입니다. `MIME` 타입은 `text/csv`이다.](#csvcomma-separated-values-파일은-간단한-텍스트-파일로-데이터를-쉼표로-구분하여-저장합니다-이-형식은-테이블-데이터를-저장하고-공유하기-위한-가장-일반적인-방법-중-하나입니다-mime-타입은-textcsv이다)
    - [🗂️🐍CSV 파일의 특징](#️csv-파일의-특징)
    - [🗂️🐍 파이썬에서 CSV 다루기](#️-파이썬에서-csv-다루기)
  - [파이썬으로 CSV 파일 읽기: csv.reader() 사용하기 📖🐍](#파이썬으로-csv-파일-읽기-csvreader-사용하기-)
      - [파이썬의 csv 모듈은 `CSV` 파일을 효과적으로 처리할 수 있는 간편한 방법을 제공. 여기서는 `csv.reader()` 함수를 사용하여 CSV 파일을 읽는 기본적인 방법을 알아본다.](#파이썬의-csv-모듈은-csv-파일을-효과적으로-처리할-수-있는-간편한-방법을-제공-여기서는-csvreader-함수를-사용하여-csv-파일을-읽는-기본적인-방법을-알아본다)
    - [예제1: csv.reader()로 CSV 파일 읽기](#예제1-csvreader로-csv-파일-읽기)
    - [핵심 포인트 🌟](#핵심-포인트--5)
    - [사용 시나리오 🛠](#사용-시나리오--3)
    - [중요 포인트 📌](#중요-포인트-)
    - [CSV 파일 읽기: 구분자 지정하기 📖🔧](#csv-파일-읽기-구분자-지정하기-)
      - [CSV 파일을 읽을 때, 데이터가 쉼표(,)로 구분되지 않는 경우가 있을 수 있다. 이럴 때는 `csv.reader`에 `delimiter` 매개변수를 사용하여 적절한 구분자를 지정할 수 있다.](#csv-파일을-읽을-때-데이터가-쉼표로-구분되지-않는-경우가-있을-수-있다-이럴-때는-csvreader에-delimiter-매개변수를-사용하여-적절한-구분자를-지정할-수-있다)
    - [예제2: 구분자 지정하여 CSV 파일 읽기](#예제2-구분자-지정하여-csv-파일-읽기)
    - [핵심 포인트 🌟](#핵심-포인트--6)
    - [사용 시나리오 🛠](#사용-시나리오--4)
    - [중요 포인트 📌](#중요-포인트--1)
    - [CSV 파일을 딕셔너리로 변환하기: csv.DictReader() 사용 🗂️➡️📖](#csv-파일을-딕셔너리로-변환하기-csvdictreader-사용-️️)
      - [파이썬의 `csv` 모듈에서는 `csv.DictReader()` 함수를 사용하여 `CSV` 파일의 각 줄을 딕셔너리로 쉽게 변환할 수 있다. 이 방법은 `CSV `파일의 컬럼 헤더를 키로, 각 줄의 데이터를 값으로 사용하여 작업을 진행할 때 특히 유용.](#파이썬의-csv-모듈에서는-csvdictreader-함수를-사용하여-csv-파일의-각-줄을-딕셔너리로-쉽게-변환할-수-있다-이-방법은-csv-파일의-컬럼-헤더를-키로-각-줄의-데이터를-값으로-사용하여-작업을-진행할-때-특히-유용)
    - [예제3: csv.DictReader()로 CSV 파일 읽기](#예제3-csvdictreader로-csv-파일-읽기)
    - [핵심 포인트 🌟](#핵심-포인트--7)
    - [사용 시나리오 🛠](#사용-시나리오--5)
    - [중요 포인트 📌](#중요-포인트--2)
    - [CSV 파일 쓰기: csv.writer() 사용하기 ✍️📁](#csv-파일-쓰기-csvwriter-사용하기-️)
      - [파이썬의 csv 모듈을 사용하여 리스트 데이터를 CSV 파일로 쉽게 쓸 수 있다. 여기서는 `csv.writer()` 함수를 활용하여 다차원 리스트의 데이터를 `CSV` 파일에 쓰는 방법을 알아보자.](#파이썬의-csv-모듈을-사용하여-리스트-데이터를-csv-파일로-쉽게-쓸-수-있다-여기서는-csvwriter-함수를-활용하여-다차원-리스트의-데이터를-csv-파일에-쓰는-방법을-알아보자)
    - [예제4: csv.writer()로 데이터 쓰기](#예제4-csvwriter로-데이터-쓰기)
    - [핵심 포인트 🌟](#핵심-포인트--8)
    - [사용 시나리오 🛠](#사용-시나리오--6)
    - [중요 포인트 📌](#중요-포인트--3)
    - [CSV 파일에 딕셔너리 데이터 쓰기: csv.DictWriter() 활용하기 ✍️🗂️](#csv-파일에-딕셔너리-데이터-쓰기-csvdictwriter-활용하기-️️)
      - [파이썬의 `csv` 모듈에서는 `DictWriter` 클래스를 통해 딕셔너리 데이터를 `CSV` 파일로 쉽게 쓸 수 있습니다. 이 방법은 데이터의 각 필드(컬럼)를 명시적으로 정의하고 싶을 때 특히 유용.](#파이썬의-csv-모듈에서는-dictwriter-클래스를-통해-딕셔너리-데이터를-csv-파일로-쉽게-쓸-수-있습니다-이-방법은-데이터의-각-필드컬럼를-명시적으로-정의하고-싶을-때-특히-유용)
    - [예제5: csv.DictWriter()로 딕셔너리 데이터 쓰기](#예제5-csvdictwriter로-딕셔너리-데이터-쓰기)
    - [핵심 포인트 🌟](#핵심-포인트--9)
    - [사용 시나리오 🛠](#사용-시나리오--7)
    - [중요 포인트 📌](#중요-포인트--4)
  - [행맨(Hangman) 미니게임 제작 가이드  (1)🎮👨‍💻](#행맨hangman-미니게임-제작-가이드--1)
      - [행맨 게임은 플레이어가 제한된 횟수 내에 숨겨진 단어를 맞추는 간단하지만 재미있는 게임입니다. 여기서는 게임의 기본 구조와 필요한 파이썬 코드, 사용되는 함수와 메서드에 대해 자세히 설명한다.](#행맨-게임은-플레이어가-제한된-횟수-내에-숨겨진-단어를-맞추는-간단하지만-재미있는-게임입니다-여기서는-게임의-기본-구조와-필요한-파이썬-코드-사용되는-함수와-메서드에-대해-자세히-설명한다)
    - [1. 게임 시작: 사용자 인터랙션 및 초기 설정 🚀](#1-게임-시작-사용자-인터랙션-및-초기-설정-)
    - [2. 핵심 게임 로직: 단어 추측하기 🔍](#2-핵심-게임-로직-단어-추측하기-)
    - [게임의 흐름 🌊](#게임의-흐름-)
  - [행맨(Hangman) 미니게임 제작 가이드  (2)🎮👨‍💻](#행맨hangman-미니게임-제작-가이드--2)
    - [🚀 시작 단계](#-시작-단계)
      - [라이브러리 import 📚: 게임 개발에 필요한 time, random, csv, winsound 라이브러리를 임포트.](#라이브러리-import--게임-개발에-필요한-time-random-csv-winsound-라이브러리를-임포트)
      - [`time`은 대기 시간 생성에,](#time은-대기-시간-생성에)
      - [`random`은 단어 선택에,](#random은-단어-선택에)
      - [`csv`는 단어 목록 load에,](#csv는-단어-목록-load에)
      - [`winsound`는 소리 재생에 사용.](#winsound는-소리-재생에-사용)
    - [📖 데이터 로드 단계](#-데이터-로드-단계)
    - [🕹 게임 진행 단계](#-게임-진행-단계)
    - [🎉 종료 조건](#-종료-조건)
    - [🛠 핵심 포인트](#-핵심-포인트)
          - [이렇게 해서 파이썬 기초문법을 알아보았다. 🎉🐍 이 과정을 통해 변수, 조건문, 반복문, 함수, 모듈 사용법 등 파이썬 프로그래밍의 기본적인 요소들을 배웠다. 프로그래밍은 이론뿐만 아니라 실습을 통해 배우는 것이 중요한거같다. 앞으로도 이글을 보고 배우신 분들이 있다면 이 내용을 다양한 프로젝트에 적용해보면서 더 깊이 있는 지식을 쌓아가시길 바랍니당 🚀💻](#이렇게-해서-파이썬-기초문법을-알아보았다--이-과정을-통해-변수-조건문-반복문-함수-모듈-사용법-등-파이썬-프로그래밍의-기본적인-요소들을-배웠다-프로그래밍은-이론뿐만-아니라-실습을-통해-배우는-것이-중요한거같다-앞으로도-이글을-보고-배우신-분들이-있다면-이-내용을-다양한-프로젝트에-적용해보면서-더-깊이-있는-지식을-쌓아가시길-바랍니당-)
          - [인프런 파이썬 입문 강의 보고 작성한 글입니다 기초 문법 다지기도 작성할 예정입니다. 📚💡](#인프런-파이썬-입문-강의-보고-작성한-글입니다-기초-문법-다지기도-작성할-예정입니다-)



# 📘 파이썬 완전 기초
## 📄 Print 사용법
##### 파이썬에서 데이터를 화면에 출력하기 위해 print() 함수를 사용. 🖨️ 이 함수는 매우 다양하고 유연한 출력 옵션을 제공하고. 이를 통해 데이터를 명확하고 이해하기 쉬운 형태로 표시할 수 있음.

## 📝 기본 출력
```python
Copy code
print('Python Start!')  # 단일 따옴표를 사용한 기본 출력
print("Python Start!")  # 이중 따옴표를 사용한 기본 출력
print("""Python Start!""")  # 세 개의 이중 따옴표를 사용하여 여러 줄에 걸쳐 출력
print('''Python Start!''')  # 세 개의 단일 따옴표를 사용하여 여러 줄에 걸쳐 출력
```
#### 문자열은 작은따옴표(') 또는 큰따옴표(")로 둘러싸서 표현.
## 🔐 Escape 코드
```python
print("줄바꿈을 하려면 \n을 사용하세요.")  # \n : 개행 (줄바꿈)
print("탭 간격을 주려면 \t을 사용하세요.")  # \t : 탭 (여러 칸 띄우기)
print("따옴표를 출력하려면 \", \'를 사용하세요.")  # \'와 \" : 문자열 내 따옴표 사용
```
## 🔗 separator 옵션 사용
```python
print('P', 'Y', 'T', 'H', 'O', 'N', sep='')  # PYTON
print('010', '7777', '7777', sep='-')  # 010-7777-7777
print('python', 'google.com', sep='@')  # python@google.com
```
## ➡️ end 옵션 사용
```python
print('Welcome To', end=' ')  # 다음 출력과 같은 줄에 이어서 출력
print('IT News', end=' ')
print('Web Site')
```
## 📤 file 옵션 사용
```python
import sys
print('Learn Python', file=sys.stdout)  # 표준 출력으로 메시지를 출력
```
## 🖊️ 문자열 포맷팅
### % 연산자를 이용한 포맷팅
```python
print('%s %s' % ('one', 'two'))  # 문자열 포맷팅
print('%10s' % ('nice',))  # 오른쪽 정렬로 총 10자리 확보
print('%-10s' % ('nice',))  # 왼쪽 정렬로 총 10자리 확보
print('%.5s' % ('pythonstudy',))  # 문자열에서 처음 5글자만 출력
```
## 🧩 format() 메소드를 이용한 포맷팅
```python
print('{} {}'.format('one', 'two'))  # 기본 포맷
print('{1} {0}'.format('one', 'two'))  # 인덱스를 통한 포맷
print('{:>10}'.format('nice'))  # 오른쪽 정렬로 총 10자리 확보
print('{:10}'.format('nice'))  # 왼쪽 정렬로 총 10자리 확보
print('{:_<10}'.format('nice'))  # 왼쪽 정렬 및 빈 공간을 '_'로 채움
print('{:^10}'.format('nice'))  # 가운데 정렬로 총 10자리 확보
print('{:.5}'.format('pythonstudy'))  # 문자열에서 처음 5글자만 출력
```
## 📐 숫자 포맷팅
```python
# %d, %f
print('%d %d' % (1, 2))  # 정수 포맷팅
print('%4d' % (42,))  # 최소 4자리 확보
print('%f' % (3.141592653589793,))  # 부동 소수점 수 포맷팅
print('%06.2f' % (3.141592653589793,))  # 총 6자리 확보, 소수점 이하 2자리

# format() 메소드
print('{:4d}'.format(42))  # 최소 4자리 확보
print('{:f}'.format(3.141592653589793))  # 부동 소수점 수 포맷팅
print('{:06.2f}'.format(3.141592653589793))  # 총 6자리 확보, 소수점 이하 2자리
```
#### 이렇게 print() 함수를 활용하여 파이썬에서 데이터를 다양하고 유연한 방식으로 표현할 수 있다. 코드를 작성하며 결과를 확인하고, 데이터를 가공하는 과정에서 이러한 기법을 활용해 보자. 🚀🌟
---
# 🌟 파이썬 기초 다지기
## 🖨️ Print 사용법 깊게 알아보기
#### 파이썬에서는 데이터를 화면에 표시하는 여러 방법을 제공. 이번 세션에서는 문자열을 출력하는 세 가지 주요 방법을 살펴보며, 각 방법이 어떻게 다른지, 어떤 상황에 어느 방법을 사용하면 좋을지 알아보자. 🌈

### 먼저, 문자열 포맷팅에 사용될 변수들을 정의해 보자.

```python
x = 50  # 📌 숫자 50을 변수 x에 저장.
y = 100  # 📌 숫자 100을 변수 y에 저장.
text = 308276567  # 📌 숫자 308276567을 변수 text에 저장.
n = 'Lee'  # 📌 문자열 'Lee'를 변수 n에 저장.
```
## 📖 문자열 포맷팅 방법
### 출력1: % 연산자
#### 이 방법은 C언어 스타일의 포맷팅 방법으로, 문자열 내에 특정 값들을 삽입할 때 사용.

```python
# 변수를 문자열 내에 삽입하기
ex1 = 'n = %s, s = %s, sum=%d' % (n, text, (x + y))  # 여기서 %s는 문자열, %d는 정수를 의미.
print(ex1)  # 출력 결과: n = Lee, s = 308276567, sum=150
```
#### %s는 문자열을, %d는 정수를 나타냄. n, text, 그리고 x + y의 결과가 각 위치에 삽입되어 문자열이 완성된다.
### 출력2: .format() 메소드
#### .format() 메소드는 % 연산자보다 더 유연하고 직관적인 방법을 제공.

```python
# 변수를 문자열 내에 삽입하기
ex2 = 'n = {n}, s = {serialno}, sum={sum}'.format(n=n, serialno=text, sum=x + y)
print(ex2)  # 출력 결과: n = Lee, s = 308276567, sum=150
```
#### {}는 변수의 값을 삽입할 위치를 나타내며, .format() 메소드의 인자를 통해 실제 값들이 전달됨.
### 출력3: f-스트링 (f-strings)
#### f-스트링은 Python 3.6 이상에서 사용할 수 있는 가장 최신의 포맷팅 기법. 가독성과 편의성이 뛰어남.

```python
# 변수를 문자열 내에 직접 삽입하기
ex3 = f'n = {n}, s = {text}, sum={x + y}'
print(ex3)  # 출력 결과: n = Lee, s = 308276567, sum=150
```
#### 문자열 앞에 f를 붙이고, {} 안에 직접 변수명이나 수식을 넣어 값을 삽입.
### 출력4: 다양한 f-스트링 활용법
#### 진수 변환, 구분자 사용, 정렬, 그리고 채우기와 같은 다양한 포맷팅을 f-스트링으로 쉽게 할 수 있다.

```python
k = 98  # 📌 숫자 98을 변수 k에 저장.

# 진수 변환하기
print(f"k 2진수: {k:b}, k 8진수: {k:o}")  # k를 2진수와 8진수로 변환하여 출력.
print(f"k 16진수 - 소문자:{k:x}, 대문자:{k:X}")  # k를 16진수로 변환하여 출력.

# 큰 숫자에 구분기호(,) 사용하기
m = 10000000000  # 📌 큰 숫자를 변수 m에 저장.
print(f"m: {m:,}")  # m을 천 단위로 구분하여 출력.

# 숫자 정렬하기
t = 20  # 📌 숫자 20을 변수 t에 저장.
print(f"t :{t:10}")  # t를 기본 정렬로 출력.
print(f"t center: {t:^10}")  # t를 가운데 정렬로 출력.
print(f"t left: {t:<10}")  # t를 왼쪽 정렬로 출력.
print(f"t right: {t:>10}")  # t를 오른쪽 정렬로 출력.

# 숫자 채우기
print(f"t:{t:-^10}")  # t를 가운데 정렬하고 빈 공간을 '-'로 채움.
print(f"t:{t:#^10}")  # t를 가운데 정렬하고 빈 공간을 '#'로 채움.
```
#### 위 예시들처럼 `print()` 함수와 문자열 포맷팅을 활용하면, 복잡한 데이터도 이해하기 쉽고 깔끔한 형태로 출력할 수 있다.
---
# 📘 파이썬 기초 다지기 II
## 🚀 파이썬 변수 기본
#### 변수는 파이썬에서 데이터를 저장하는 컨테이너. 내가 작성한 프로그램에서 다양한 데이터를 다룰 때 변수를 사용하여 이를 저장하고 참조할 수 있다.

## 📝 기본 선언
```python
n = 700  # n이라는 변수에 700을 할당.
```
### 🖨️ 출력
```python
print(n)  # 변수 n의 값을 출력.
print(type(n))  # 변수 n의 데이터 타입을 출력. 이 경우 'int'.
```
## 🔗 동시 선언
```python
x = y = z = 700  # x, y, z 세 변수에 동시에 700을 할당.
```
### 🖨️ 출력
```python
print(x, y, z)  # x, y, z 변수의 값을 출력.
```
## 🔄 재선언과 타입 변경
```python
var = 75  # 처음에는 var에 숫자를 할당.
print(var)
print(type(var))  # 숫자이므로 'int' 타입.

var = "Change Value"  # 동일한 var 변수에 문자열을 재할당.
print(var)
print(type(var))  # 이제 var는 'str' 문자열 타입.
```
## 🌐 객체 참조와 변수의 아이덴티티
#### 파이썬에서 변수를 할당할 때는 실제로 메모리에 객체를 생성하고, 변수는 그 객체를 참조하게 됨.

## 🧐 객체 참조
```python

n = 777  # n에 777을 할당.
m = n  # m에 n의 값을 할당. 여기서 m과 n은 같은 객체를 참조.
print(m, n)  # 두 변수 모두 777을 출력.
print(type(m), type(n))  # 두 변수의 타입은 'int'.
```
## 🔍 id(identity)확인: 객체의 고유값 확인
```python
m = 800
n = 655
print(id(m))  # m의 메모리 주소(고유 ID)를 출력.
print(id(n))  # n의 메모리 주소(고유 ID)를 출력.

m = 800
n = 800
print(id(m))  # 같은 값을 가지면 파이썬 내부에서 하나의 객체를 재사용.
print(id(n))  # 따라서 m과 n의 id가 같게 됨.
```
## 🎨 다양한 변수 선언 방식
```python
# Camel Case: 각 단어의 첫 글자를 대문자로 시작 (numberOfCollegeGraduates).
# Pascal Case: 첫 글자도 대문자로 시작 (NumberOfCollegeGraduates).
# Snake Case: 단어 사이에 언더스코어(_)를 사용 (number_of_college_graduates).
```
## ✅ 허용하는 변수 선언 법
```python
age = 1
Age = 2
aGe = 3
AGE = 4
a_g_e = 5
_age = 6  # 언더스코어로 시작 가능하지만 특별한 경우를 제외하고는 일반적으로 사용하지 않음.
age_ = 7  # 변수명 끝에 언더스코어 사용 가능
_AGE_ = 8  # 언더스코어로 시작하고 끝나는 변수명도 가능하지만, 일반적으로 내부 사용을 위한 명명 규칙으로 쓰임.
```
### ❗ 예약어는 변수명으로 사용할 수 없음.
#### 파이썬에서 이미 문법적인 용도로 사용되고 있는 단어들(예: if, for, class 등)은 변수 이름으로 사용할 수 없다. 이러한 단어들은 파이썬의 기능을 수행하기 위해 예약되어 있기 때문
```py
False def	if	raise
None del import	return
True elif	in	try
and	else is	while
as	except	lambda	with
assert	finally	nonlocal yield
break	for	not	
class	from or	
continue global	pass	
```
---
# 📘 파이썬 완전 기초: 숫자형 다루기
### 파이썬에서 숫자를 다루는 것은 프로그래밍의 기본. 숫자형은 계산, 데이터 분석, 알고리즘 구현 등 다양한 영역에서 활용. 여기서는 파이썬이 지원하는 숫자형과 기본적인 수학 연산에 대해 알아보자. 🚀

## 📚 파이썬 지원 자료형
#### 파이썬에서 사용할 수 있는 기본적인 숫자형은 다음과 같다:
```py
int (정수): -3, -2, -1, 0, 1, 2, 3...
float (실수): -3.5, -2.0, 0.0, 1.5...
complex (복소수): 1 + j, 2 + 3j...
bool (불린): True, False
```
#### 또한, 숫자형 이외에도 여러가지 타입이 있어, 데이터를 다양한 형태로 표현할 수 있다:
```py
str: '문자열'(시퀀스)
list: '리스트'(시퀀스)
tuple: '튜플'(시퀀스)
set: '집합'
dict: '사전'
```
## 🧮 숫자형 연산자
#### 파이썬에서 숫자를 다루기 위한 기본 연산자는 아래와 같다:
```py
+: 더하기 ➕
-: 빼기 ➖
*: 곱하기 ✖️
/: 나누기 ➗
//: 나눈 후 몫 🧮
%: 나머지 🔄
**: 제곱 🔥
```
## 💡 숫자형 예제와 연산 실습
#### 기본 숫자형 사용
```python
i = 77  # 정수형 변수
f = 0.9999  # 실수형 변수

print(i)  # 77 출력
print(f)  # 0.9999 출력
```
#### 간단한 수학 연산
```python
# 더하기
print("i + f:", i + f)  # 77.9999

# 나누기 및 몫
print("i / 2:", i / 2)  # 38.5 - 나누기
print("i // 2:", i // 2)  # 38 - 몫

# 제곱
print("2 ** 3:", 2 ** 3)  # 8 - 2의 3제곱
```
## 🔄 형 변환 실습
#### 형 변환은 한 타입의 데이터를 다른 타입으로 변경하는 것을 말함. 숫자형에서 자주 사용:

```python
# 정수 -> 실수
print(float(i))  # 77.0

# 실수 -> 정수
print(int(f))  # 0

# 불리언 -> 정수
print(int(True))  # 1
print(int(False))  # 0
```
## 🧑‍🔬 수치 연산 함수
#### 파이썬에는 숫자를 다루는 데 유용한 내장 함수들이 있다:

```python
# 절대값
print(abs(-7))  # 7

# 몫과 나머지
x, y = divmod(100, 8)
print("몫:", x, "나머지:", y)  # 몫: 12, 나머지: 4

# 제곱
print(pow(5, 3))  # 125 - 5의 3제곱
```
## 📚 외부 모듈 사용하기: math 모듈
#### 파이썬은 수학 연산을 위한 `math` 모듈을 제공. 이 모듈을 사용하면 복잡한 수학 연산을 쉽게 수행할 수 있다:

```python
import math

print(math.ceil(5.1))  # 6 - 5.1보다 크거나 같은 가장 작은 정수
print(math.floor(5.9))  # 5 - 5.9보다 작거나 같은 가장 큰 정수
print(math.pi)  # 원주율 π 값 출력
```
#### 숫자형과 이를 다루는 기본 연산자, 수치 연산 함수를 이해하고 사용할 줄 알면, 파이썬 프로그래밍의 기초를 탄탄히 다질 수 있다. 이러한 지식은 나아가 데이터 분석, 과학 계산 등 보다 고급 주제를 학습하는 데 큰 도움이 될 것! 🌟📈
---
# 📘 파이썬 완전 기초: 문자형 이해하기
## 문자형은 파이썬에서 매우 중요한 데이터 유형. 문자열을 저장하고 처리하는 방법을 배우면, 프로그래밍의 많은 영역에서 활용할 수 있다.

## 📝 문자열 생성하기
#### 파이썬에서 문자열을 만드는 방법은 간단. 다양한 방법으로 문자열을 생성해 볼 수 있다:

```python
str1 = "I am Python."  # 이중 따옴표로 둘러싸인 문자열
str2 = 'Python'        # 단일 따옴표로 둘러싸인 문자열
str3 = """How are you?"""  # 이중 따옴표 세 개를 사용한 멀티라인 문자열
str4 = '''Thank you!'''    # 단일 따옴표 세 개를 사용한 멀티라인 문자열
```
### 🖨️ 문자열 출력 및 타입 확인
#### 문자열의 타입을 확인하고, 문자열의 길이를 알아보자:

```python
# 문자열 출력
print(type(str1))  # str1의 데이터 타입을 출력. 예상 결과: <class 'str'>
print(type(str2))  # str2의 데이터 타입을 출력. 예상 결과: <class 'str'>
print(type(str3))  # str3의 데이터 타입을 출력. 예상 결과: <class 'str'>
print(type(str4))  # str4의 데이터 타입을 출력. 예상 결과: <class 'str'>

# 문자열 길이
print(len(str1))  # str1 문자열의 길이(문자 개수)를 출력.
print(len(str2))  # str2 문자열의 길이를 출력.
print(len(str3))  # str3 문자열의 길이를 출력.
print(len(str4))  # str4 문자열의 길이를 출력.


print(type(str_t1), len(str_t1))  # str_t1의 데이터 타입과 길이를 출력. 예상 결과: <class 'str'> 0
print(type(str_t2), len(str_t2))  # str_t2의 데이터 타입과 길이를 출력. 예상 결과: <class 'str'> 0
```
## 🚀 빈 문자열 생성
#### 빈 문자열도 문자열의 한 형태. 다음과 같이 생성할 수 있다:

```python
str_t1 = ''       # 빈 문자열을 str_t1 변수에 할당.
str_t2 = str()    # str() 생성자를 사용하여 빈 문자열을 str_t2 변수에 할당.
```
## ✨ 이스케이프 문자 사용하기
#### 특수 문자를 문자열 안에 포함시키고 싶을 때, 이스케이프 문자를 사용:

```python
# 이스케이프 문자 사용
escape_str1 = "Do you have a \"retro games\"?"  # 큰따옴표 안에서 큰따옴표를 사용하기 위해 이스케이프 문자(\)를 사용.
escape_str2 = 'What\'s on TV?'  # 작은따옴표 안에서 작은따옴표를 사용하기 위해 이스케이프 문자(\)를 사용.
```
## 🌈 탭과 줄바꿈
#### 탭(\t)과 줄바꿈(\n)을 사용하여 문자열을 보기 좋게 구성할 수 있다:

```python
t_s1 = "Click \tStart!"  # 탭 적용
t_s2 = "New Line\nCheck!"  # 줄바꿈 적용
```
## 📂 Raw String 활용하기
#### 파일 경로 등에서 백슬래시(\)를 그대로 사용하고 싶을 때 Raw String을 사용:

```python
# Raw String 사용
raw_s1 = r'D:\Python\python3'  # r을 문자열 앞에 붙여서 Raw String으로 생성. 이스케이프 시퀀스를 무시하고 문자 그대로를 출력.
raw_s2 = r"\\x\y\z\q"  # 마찬가지로 r을 사용하여 Raw String을 생성. 이스케이프 시퀀스를 무시하고 문자 그대로를 출력.
```

## 📜 멀티라인 문자열
#### 여러 줄에 걸쳐 문자열을 작성하고 싶을 때 사용:

```python
# 멀티라인 문자열 생성
multi_str1 = \
    """
    문자열
    멀티라인 입력
    테스트
    """
# 멀티라인 출력
# 여기서 \ 문자 뒤에 바로 개행 문자가 오면, 그 개행 문자를 무시하고 문자열을 연속해서 작성할 수 있다.
# """ 또는 ''' 안에 텍스트를 입력하면 개행을 포함한 멀티라인 문자열을 생성할 수 있다.
print(multi_str1)

# 멀티라인 문자열 생성 및 역슬래시 사용
multi_str2 = \
    '''
    문자열 멀티라인 
    역슬래시(\) \
    테스트
    '''
# 멀티라인(역슬래시) 출력
# 여기서 역슬래시(\)는 문자열 내에서 특별한 기능을 하지 않고 문자 그대로 출력.
# 역슬래시를 사용하여 멀티라인 문자열 내에서도 문자열의 연속을 나타낼 수 있다.
print(multi_str2)
```
## 🎭 문자열 연산
#### 문자열을 더하거나 반복하는 등의 연산을 할 수 있다:

```python
# 문자열 연산
str_o1 = "Python"
str_o2 = "Apple"
str_o3 = "How are you doing?"
str_o4 = "Seoul Deajeon Busan Jinju"

print(3 * str_o1)  # 문자열 str_o1을 3번 반복. 결과: 'PythonPythonPython'
print(str_o1 + str_o2)  # 문자열 str_o1과 str_o2를 연결. 결과: 'PythonApple'
print(dir(str_o1))  # str_o1에 사용할 수 있는 메서드(함수)의 목록을 출력.
print('y' in str_o1)  # 문자열 str_o1 내에 'y' 문자가 있는지 확인. 결과: True
print('n' in str_o1)  # 문자열 str_o1 내에 'n' 문자가 있는지 확인. 결과: True
print('P' not in str_o2)  # 문자열 str_o2 내에 'P' 문자가 없는지 확인. 결과: False
```
## 🔄 문자열 형 변환
#### 다른 데이터 타입을 문자열로 변환할 수 있다:

```python
# 문자열 형 변환
print(str(66))  # 정수 66을 문자열 '66'으로 변환하여 출력.
print(str(10.1))  # 실수 10.1을 문자열 '10.1'로 변환하여 출력.
print(str(True))  # 불리언 True를 문자열 'True'로 변환하여 출력.
print(str(complex(12)))  # 복소수 12+0j를 문자열 '12+0j'로 변환하여 출력.
```
## 🛠️ 문자열 메서드 활용하기
#### 문자열을 대문자로 변환하거나, 특정 문자로 시작하는지 확인하고, 문자열을 분리하는 등 여러 메서드를 사용할 수 있다:
```python
# 문자열 함수 사용 예제
print("Capitalize: ", str_o1.capitalize())  # 문자열의 첫 글자를 대문자로 변환. 결과: 'Python' -> 'Python'
print("endswith?: ", str_o2.endswith("s"))  # 문자열이 's'로 끝나는지 확인. 결과: 'Apple' -> False
print("join str: ", str_o1.join(["I'm ", "!"]))  # 주어진 문자열 사이에 str_o1을 삽입. 결과: "I'm Python!"
print("replace1: ", str_o1.replace('thon', ' Good'))  # 'thon'을 ' Good'으로 교체. 결과: 'Py Good'
print("replace2: ", str_o3.replace("are", "was"))  # 'are'을 'was'로 교체. 결과: 'How was you doing?'
print("split: ", str_o4.split(' '))  # 공백을 기준으로 문자열을 나누어 리스트를 반환. 결과: ['Seoul', 'Deajeon', 'Busan', 'Jinju']
print("sorted: ", sorted(str_o1))  # 문자열의 모든 문자를 알파벳 순으로 정렬. 결과: ['P', 'h', 'n', 'o', 't', 'y']
print("reversed1: ", reversed(str_o2))  # 문자열의 문자 순서를 뒤집음. 결과 객체는 reversed 객체이므로 리스트로 변환해야 함.
print("reversed2: ", list(reversed(str_o2)))  # reversed 객체를 리스트로 변환하여 출력. 결과: ['e', 'l', 'p', 'p', 'A']
```
## 🔍 반복문을 사용한 문자 출력
#### 문자열도 반복 가능한 객체이므로, for문을 사용하여 문자열의 각 문자를 출력할 수 있다:

```python
# 문자열과 반복문
im_str = "Good Boy!"  # 문자열 선언

print(dir(im_str))  # 문자열이 가진 속성과 메서드를 리스트 형태로 출력. 여기서 '__iter__'는 문자열이 반복 가능한 객체임을 나타냄.

# 문자열의 각 문자를 순회하는 반복문
for i in im_str:
    print(i)  # 문자열 'Good Boy!'의 각 문자를 한 줄씩 출력.
```
## 🔎 슬라이싱으로 문자열 부분 선택하기
#### 문자열에서 원하는 부분만 추출할 수 있다:

```python
# 슬라이싱 예제
str_sl = 'Nice Python'  # 문자열 선언

# 문자열 슬라이싱 기본
print(str_sl[0:3])  # 'Nic'을 출력. 인덱스 0부터 2까지의 문자를 포함. 3은 포함하지 않음.
print(str_sl[:len(str_sl)])  # 'Nice Python'을 출력. 문자열의 시작부터 끝까지 전체 문자열을 가져옴.
print(str_sl[:len(str_sl) - 1])  # 'Nice Pytho'를 출력. 문자열의 시작부터 마지막 문자 전까지를 가져옴.
print(str_sl[:])  # 'Nice Python'을 출력. 문자열의 전체를 나타냅니다. 시작과 끝을 생략하면 전체 문자열을 가져옴.

# 문자열 슬라이싱 응용
print(str_sl[1:4:2])  # 'ie'를 출력. 인덱스 1부터 3까지 2칸 간격으로 문자를 포함.
print(str_sl[-4:-2])  # 'th'를 출력. 뒤에서 4번째 문자부터 뒤에서 2번째 문자 전까지를 가져옴.
print(str_sl[1:-2])  # 'ice Pyth'를 출력. 인덱스 1부터 뒤에서 2번째 문자 전까지를 가져옴.
print(str_sl[::-1])  # 'nohtyP eciN'을 출력. 문자열을 거꾸로 뒤집음. 스텝을 -1로 설정하여 역순으로 가져옴.
print(str_sl[::2])  # 'Nc yhn'을 출력. 문자열에서 한 칸 건너뛰며 문자를 포함. 시작과 끝을 생략하고 스텝을 2로 설정.
```

## 📚 아스키코드와 문자 변환
#### 문자와 이에 해당하는 아스키 코드를 상호 변환할 수 있다:

```python
# 아스키코드 변환 예제
a = 'z'  # 문자 'z'를 변수 a에 할당

print(ord(a))  # ord() 함수를 사용하여 문자 'z'의 아스키 코드 값을 출력. 결과는 122.
print(chr(122))  # chr() 함수를 사용하여 아스키 코드 값 122에 해당하는 문자를 출력. 결과는 'z'.
```
#### 이러한 문자형 데이터와 다양한 작업들을 통해, 파이썬에서 문자열을 더 효과적으로 다룰 수 있다. 문자열은 프로그래밍에서 매우 자주 사용되므로 이러한 기본적인 내용들을 잘 이해! 🌟
---

# 📘 파이썬 리스트
### 리스트는 파이썬에서 가장 자주 사용되는 자료구조 중 하나. 순서가 있고, 중복을 허용하며, 수정과 삭제가 가능 (파이썬 배열 제공X).

## 📝 리스트 선언
#### 파이썬에서 리스트를 만드는 여러 가지 방법.

```python
a = []  # 빈 리스트를 생성.
b = list()  # list 함수를 사용해 빈 리스트를 생성.
c = [70, 75, 80, 85]  # 숫자로 구성된 리스트를 생성.
d = [1000, 10000, 'Ace', 'Base', 'Captine']  # 숫자와 문자열을 포함한 리스트를 생성.
e = [1000, 10000, ['Ace', 'Base', 'Captine']]  # 리스트 내에 또 다른 리스트(중첩 리스트)를 포함.
f = [21.42, 'foobar', 3, 4, 'bark', False, 3.14159]  # 다양한 타입의 데이터를 포함한 리스트를 생성.
```
## 🔍 인덱싱 (원하는 데이터를 꺼내오는 과정)
#### 리스트 내 특정 요소에 접근하는 방법.
```python
print('d - ', type(d), d)  # 리스트 d의 타입과 값을 출력.
print('d - ', d[1])  # 리스트 d의 두 번째 요소를 출력.
print('d - ', d[0] + d[1] + d[1])  # 리스트 d의 첫 번째와 두 번째 요소를 더한 값을 출력.
print('d - ', d[-1])  # 리스트 d의 마지막 요소를 출력.
print('e - ', e[-1][1])  # 중첩 리스트 e의 마지막 요소 내 두 번째 요소를 출력.
print('e - ', list(e[-1][1]))  # 위의 결과를 리스트로 변환하여 출력.
```
## 🍽️ 슬라이싱
#### 리스트의 부분적인 요소들을 추출하는 방법.

```python
# 리스트 슬라이싱 예제
print('d - ', d[0:3])  # 리스트 'd'의 첫 번째부터 세 번째 요소까지 출력. 여기서 0:3은 인덱스 0부터 2까지의 요소를 의미.
print('d - ', d[2:])  # 리스트 'd'의 세 번째 요소부터 끝까지 출력. 2:는 인덱스 2부터 리스트의 끝까지의 요소를 의미.
print('e - ', e[2][1:3])  # 중첩 리스트 'e'의 세 번째 요소(또 다른 리스트) 내에서 두 번째부터 세 번째 요소까지 출력. 여기서 1:3은 인덱스 1부터 2까지의 요소를 의미.
```
## ➕ 리스트 연산
#### 리스트를 이용한 연산 예시.

```python
# 리스트 결합 및 반복 예제
print('c + d - ', c + d)  # 리스트 'c'와 'd'를 결합. 두 리스트의 요소들이 순서대로 하나의 리스트로 합쳐짐.
print('c * 3 - ', c * 3)  # 리스트 'c'의 요소들을 3번 반복하여 하나의 리스트로 만듦. 'c' 리스트의 모든 요소가 3번씩 반복됨.

# 문자열과 숫자의 결합 예제
# print("c[0] + 'hi' - ", c[0] + 'hi') 'c[0]'은 숫자이므로 문자열과 직접 더할 수 없음.
print("'Test' + c[0] - ", 'Test' + str(c[0]))  # 리스트 'c'의 첫 번째 요소를 문자열로 변환하고, 'Test' 문자열과 결합. 'Test' 문자열 뒤에 'c[0]'의 값이 문자열로 변환되어 붙음.
```
### 리스트 값 비교 예제
```py
print(c == c[:3] + c[3:])  # 리스트 'c'와 'c'를 슬라이싱하여 합친 결과가 같은지 비교. 결과는 True. 이는 'c'의 전체와 전체를 나누고 다시 합친 결과가 동일하다는 것을 의미.
print(c)  # 리스트 'c'의 현재 상태를 출력합니다.
print(c[:4])  # 리스트 'c'의 첫 번째 요소부터 네 번째 요소까지 출력.
```
### 리스트 id 비교 예제
```py
temp = c  # 리스트 'c'를 'temp' 변수에 할당. 여기서 'temp'와 'c'는 같은 리스트 객체를 참조.
print(c == temp)  # 'c'와 'temp'가 같은 객체를 참조하는지 비교. 결과는 True. '==' 연산자는 리스트의 내용이 같은지 비교. 여기서는 동일한 객체를 참조하므로 True를 반환.
```
## 🔄 리스트 수정, 삭제
#### 리스트의 요소를 수정하거나 삭제하는 방법.

```python
# 리스트 수정 및 삭제 예제
print('>>>>>>')
c[0] = 4  # 리스트 'c'의 첫 번째 요소를 4로 변경.

print('c - ', c)  # 변경 후 리스트 'c'를 출력.
c[1:2] = ['a', 'b', 'c']  # 리스트 'c'의 두 번째 요소를 ['a', 'b', 'c'] 리스트로 대체. 주의할 점은 이 경우 1:2 슬라이싱으로 지정된 범위에 리스트가 할당되어 기존 요소가 대체.
print('c - ', c)  # 대체 후 리스트 'c'를 출력.
c[1] = ['a', 'b', 'c']  # 리스트 'c'의 두 번째 요소 자체를 ['a', 'b', 'c'] 리스트로 변경. 이전 예제와 다르게 하나의 요소 자체가 리스트로 대체.
print('c - ', c)  # 변경 후 리스트 'c'를 출력.
c[1:3] = []  # 리스트 'c'의 두 번째부터 세 번째 요소를 제거. 이는 해당 범위를 빈 리스트로 대체하는 것과 동일.
print('c - ', c)  # 제거 후 리스트 'c'를 출력.
del c[3]  # 리스트 'c'의 네 번째 요소를 삭제. del 키워드를 사용하면 지정된 위치의 요소를 삭제할 수 있음.
print('c - ', c)  # 삭제 후 리스트 'c'를 출력.

# 삭제 remove, pop, del
# remove는 리스트에서 첫 번째로 일치하는 값을 제거.
# pop은 리스트의 마지막 요소를 제거하고 그 값을 반환.
# del은 리스트의 특정 인덱스에 있는 요소를 제거.
```
## 🛠️ 리스트 함수
#### 리스트를 다루는 다양한 함수들.

```python
# 리스트 함수 사용 예제
a = [5, 2, 3, 1, 4]  # 초기 리스트 a 생성

print('a - ', a)  # 초기 상태의 리스트 a 출력

a.append(6)  # 리스트의 끝에 새 요소 6 추가
print('a - ', a)  # 6을 추가한 후의 리스트 a 출력. append 함수는 리스트 끝에 새 요소를 추가.

a.sort()  # 리스트의 요소들을 오름차순으로 정렬
print('a - ', a)  # 정렬 후 리스트 a 출력. sort 함수는 리스트의 요소를 오름차순으로 정렬.

a.reverse()  # 리스트의 요소 순서를 뒤집음
print('a - ', a)  # 순서를 뒤집은 후의 리스트 a 출력. reverse 함수는 리스트의 요소 순서를 반대로 뒤집음.

print('a - ', a.index(5))  # 리스트 a에서 값이 5인 요소의 위치(인덱스)를 출력. index 함수는 지정된 값의 인덱스를 반환.

a.insert(2, 7)  # 인덱스 2의 위치에 값 7을 삽입
print('a - ', a)  # 7을 삽입한 후의 리스트 a 출력. insert 함수는 지정된 인덱스에 새 요소를 삽입.

a.remove(1)  # 리스트에서 값이 1인 첫 번째 요소를 제거
print('a - ', a)  # 1을 제거한 후의 리스트 a 출력. remove 함수는 리스트에서 첫 번째로 발견된 지정된 값을 제거.

print('a - ', a.pop())  # 리스트의 마지막 요소를 제거하고 그 값을 출력
print('a - ', a.pop())  # 다시 마지막 요소를 제거하고 그 값을 출력. pop 함수는 리스트의 마지막 요소를 제거하고 그 값을 반환.

print('a - ', a)  # 두 요소를 제거한 후의 리스트 a 출력

print('a - ', a.count(4))  # 리스트 a에서 값이 4인 요소의 개수를 출력. count 함수는 리스트에서 지정된 값의 출현 횟수를 반환.

ex = [8, 9]  # 새로운 리스트 ex 생성
a.extend(ex)  # 리스트 a에 ex의 모든 요소를 추가
print('a - ', a)  # ex의 요소들을 추가한 후의 리스트 a 출력. extend 함수는 다른 리스트의 요소를 현재 리스트에 추가.
```

# 삭제 remove, pop, del 🗑️

### `remove` 메서드 사용
- #### `remove`는 리스트에서 첫 번째로 발견된 특정 값을 제거. 값이 리스트에 없으면 오류를 발생시킴.
- #### 예: 리스트에 `2`가 여러 개 있을 경우, 첫 번째 `2`만 제거.
```python
a.remove(2)  # a 리스트에서 값이 2인 첫 번째 요소를 제거.
```
#### 🔍 사용 예: a 리스트에서 값이 2인 첫 번째 요소를 제거.

### `pop` 메서드 사용
#### pop은 리스트의 마지막 요소를 제거하고, 그 값을 반환.
##### 인덱스를 지정하여 해당 위치의 요소를 제거하고 반환할 수도 있다.
```python

last_element = a.pop()  # a 리스트의 마지막 요소를 제거하고, 그 값을 `last_element` 변수에 저장.
```
##### 🔍 사용 예: a 리스트의 마지막 요소를 제거하고, 그 값을 `last_element` 변수에 저장.

### del 키워드 사용
#### del은 리스트의 특정 인덱스에 있는 요소를 제거.
##### 슬라이싱과 함께 사용하여 여러 요소를 한 번에 제거할 수도 있다.
```python
del a[0]  # a 리스트의 첫 번째 요소를 제거.
del a[2:5]  # a 리스트의 인덱스 2부터 4까지의 요소들을 제거.
```
###### 🔍 사용 예: a 리스트의 첫 번째 요소를 제거, 인덱스 2부터 4까지의 요소들을 제거.

#### `remove`는 값을 기준으로 첫 번째 일치하는 요소를 제거할 때 사용. 🎯
#### `pop`은 주로 리스트의 마지막 요소를 제거할 때 사용되며, 필요에 따라 제거된 요소의 값을 활용할 수 있다. 🔚
#### del은 인덱스를 기준으로 요소를 제거할 때 사용되며, 슬라이싱을 통해 범위를 지정하여 여러 요소를 동시에 제거할 수 있다. 🔢

## 🔁 반복문과 리스트 맛보기
#### 리스트를 반복문과 함께 사용하는 예시.

#### 리스트 `a`에서 반복문을 사용하여 모든 요소를 하나씩 제거하고, 각 요소가 특정 값(예: `2`)과 동일한지 확인하는 방법을 살펴보자.

```python
while a:  # 리스트 a가 비어있지 않는 동안 반복.
    l = a.pop()  # 리스트 a의 마지막 요소를 제거하고, 그 값을 변수 l에 저장.
        print(2 is l)  # 변수 l의 값이 2와 동일한 객체인지 확인하고, 결과를 출력.
```
## 🔍 분석:

- #### while a:: 이 조건은 리스트 a에 요소가 남아있는 동안 반복을 의미. 리스트가 비어있게 되면 조건이 False가 되어 반복문이 종료됨.
- #### l = a.pop(): pop() 메서드는 리스트의 마지막 요소를 제거하고 그 값을 반환. 이 값을 변수 l에 할당하여 사용.
- #### print(2 is l): is 연산자는 두 객체의 동일성(즉, 같은 메모리 주소를 가리키는지)을 비교. 여기서는 변수 l이 저장하고 있는 객체와 숫자 2가 같은 객체인지(동일한 메모리 주소를 가리키는지)를 확인. `Python`에서는 작은 정수들(-5부터 256까지)이 미리 할당되어 있어, 이 범위 내의 정수는 동일한 메모리 주소를 공유. 그러나 이 방식으로 숫자 값을 직접 비교하는 것은 일반적이지 않으며, 값의 동등성을 비교할 때는 == 연산자를 사용하는 것이 더 적합.
- #### 📝 주의: `is` 연산자는 주로 객체의 동일성을 비교할 때 사용됩니다. 일반적인 값의 비교에는 `==`를 사용하는 것이 바람직하다. 위 예제에서는 학습 목적으로 `is`를 사용했지만, 실제로는 `l == 2`와 같이 값을 비교할 때는 `==`를 사용해야 한다고 한다.
---

# 📘 파이썬 튜플
### 튜플은 리스트와 유사하지만 한 번 생성되면 내용을 변경할 수 없는 파이썬의 자료형. 순서가 있고 중복을 허용하지만 수정과 삭제는 할 수 없다 (리스트와 비교 중요).

## 📝 튜플 선언
```python
a = ()  # 빈 튜플
b = (1,)  # 원소가 하나일 때는 쉼표(,)를 붙여야 튜플로 인식됩니다.
c = (11, 12, 13, 14)  # 네 개의 요소를 가진 튜플
d = (100, 1000, 'Ace', 'Base', 'Captine')  # 다양한 타입의 요소를 가진 튜플
e = (100, 1000, ('Ace', 'Base', 'Captine'))  # 튜플 내에 튜플을 포함(중첩 튜플)
```
## 🔍 인덱싱
#### 튜플 내의 특정 요소에 접근.

```python
print('>>>>>')
print('d - ', type(d), d)  # 'd' 튜플의 타입과 전체 내용을 출력. 여기서 'd'는 다양한 타입의 요소를 포함한 튜플.
print('d - ', d[1])  # 'd' 튜플의 두 번째 요소에 접근하여 출력. 튜플의 인덱스는 0부터 시작.
print('d - ', d[0] + d[1] + d[1])  # 'd' 튜플의 첫 번째와 두 번째 요소를 더하는 연산을 수행. 첫 번째 요소는 숫자이므로 연산이 가능.
print('d - ', d[-1])  # 'd' 튜플의 마지막 요소에 접근하여 출력. 음수 인덱스는 튜플의 끝에서부터 역순으로 요소에 접근.
print('e - ', e[-1][1])  # 'e' 튜플의 마지막 요소(중첩된 튜플)에 접근한 후, 그 중첩된 튜플의 두 번째 요소에 접근하여 출력.
print('e - ', list(e[-1][1]))  # 중첩된 튜플의 두 번째 요소(문자열)를 리스트로 변환하여 출력. 이는 문자열을 리스트로 변환하는 방법을 보여줌.
```
### 🔍 해설:

- #### 튜플은 파이썬에서 수정할 수 없는 순서가 있는 데이터 컬렉션. 이 예시에서는 튜플의 기본적인 인덱싱 방법을 보여주며, 특정 요소에 어떻게 접근하는지를 설명.
- #### type() 함수는 주어진 객체의 타입을 반환. 여기서는 `d`가 튜플(`tuple`)임을 확인할 수 있다.
- #### 인덱싱을 통해 튜플 내의 특정 위치에 있는 요소를 추출할 수 있으며, 이는 `d[1]`과 같이 표현.
- #### 음수 인덱스 `-1`은 튜플의 끝에서 첫 번째 요소를 가리킨다. 따라서 `d[-1]`은 `d`의 마지막 요소를 의미.
- #### 중첩된 튜플에 접근하기 위해 `e``[-1][1]`과 같이 인덱싱을 연속적으로 사용할 수 있다. 첫 번째 인덱스는 바깥쪽 튜플에서의 위치를, 두 번째 인덱스는 내부 튜플에서의 위치를 나타낸다.
- #### list() 함수는 주어진 데이터를 리스트로 변환한다. 이는 특정 데이터 타입을 리스트 형태로 변경하고자 할 때 유용하다.
  
## ❌ 수정 X
#### 튜플은 생성 후 요소의 수정이 불가능.

```python
# 튜플은 생성된 후에는 그 내용을 변경할 수 없는 불변(immutable) 타입. 아래 코드는 튜플의 요소를 수정하려는 시도를 보여줌.

 d[0] = 1500   # 튜플 'd'의 첫 번째 요소를 1500으로 변경하려고 시도.
 print('d - ', d)  #  변경 시도 후 'd' 튜플의 내용을 출력하려고 시도.
```
## 🍽️ 슬라이싱
#### 튜플의 일부분을 가져옴.

```python
print('d - ', d[0:3])  # 첫 번째부터 세 번째 요소까지
print('d - ', d[2:])  # 세 번째 요소부터 끝까지
```

```python
print('e - ', e[2][1:3])  # 중첩 튜플 슬라이싱
```
#### 이 코드는 중첩된 튜플 `e`에서 슬라이싱을 사용하여 특정 요소들을 선택하는 방법을 보여줌.

- #### e는 (100, 1000, ('Ace', 'Base', 'Captine'))와 같이 정의된 튜플.
- #### e[2]는 e의 세 번째 요소를 가리킨다. 여기서 세 번째 요소는 ('Ace', 'Base', 'Captine')인 중첩된 튜플.
- #### e[2][1:3]는 중첩된 튜플에서 인덱스 1부터 2까지의 요소, 즉 'Base'와 'Captine'을 선택. 인덱스는 0부터 시작하며, 슬라이싱에서 끝 인덱스는 포함되지 않는다.
### 🔍 분석:
- #### 이 슬라이싱 연산은 중첩된 튜플 내에서 부분적인 요소를 추출할 때 유용.
- #### 슬라이싱을 통해 생성된 결과 역시 튜플 타입이며, 이는 불변의 성질을 유지.
- #### 슬라이싱을 사용함으로써 튜플의 특정 범위를 쉽게 추출할 수 있으며, 이는 데이터 처리 과정에서 매우 유용하게 사용될 수 있다.
- #### 💡 팁: 튜플의 불변성으로 인해 원본 튜플은 변경되지 않으며, 슬라이싱을 통해 새로운 튜플이 생성된다. 이 방법을 통해 원본 데이터를 안전하게 보호하면서 필요한 정보만을 추출할 수 있다.
## ➕ 튜플 연산
#### 튜플의 결합과 반복.

```python
print('c + d - ', c + d)  # 튜플 c와 d를 결합하여 새로운 튜플 생성
print('c * 3 - ', c * 3)  # 튜플 c의 요소를 3번 반복하여 새로운 튜플 생성
# print("c[0] + 'hi' - ",c[0] + 'hi')  # 이 코드는 실행되지 않음 (주석 처리됨). 숫자와 문자열을 직접 더할 수 없음을 보여줌
print("'Test' + c[0] - ", 'Test' + str(c[0]))  # 튜플 c의 첫 번째 요소(숫자)를 문자열로 변환 후 'Test' 문자열과 결합
```
## 🛠️ 튜플 함수
#### 튜플의 유용한 메서드 사용 예시.

```python
# 튜플 함수 사용 예시
a = (5, 2, 3, 1, 4)  # 숫자로 구성된 튜플 'a'를 선언.

print('a - ', a)  # 튜플 'a'의 전체 내용을 출력. 여기서는 (5, 2, 3, 1, 4)가 됨.
print('a - ', a.index(5))  # 'a.index(5)'는 튜플 'a'에서 값이 5인 요소의 인덱스를 반환. 여기서는 5가 첫 번째 요소이므로 인덱스 0을 반환.
print('a - ', a.count(4))  # 'a.count(4)'는 튜플 'a' 내에서 값이 4인 요소의 개수를 세어 반환합니다. 여기서는 4가 한 번만 나타나므로 1을 반환.
```
## 📦 팩킹 & 언팩킹
#### 튜플의 팩킹과 언팩킹을 이용한 변수 할당.

```python
# 팩킹 & 언팩킹(Packing and Unpacking) 사용 예시

# 팩킹
t = ('foo', 'bar', 'baz', 'qux')  # 여러 값을 하나의 튜플로 묶는 과정을 팩킹이라고 함.

# 출력 확인
print(t)  # 전체 튜플 출력
print(t[0])  # 튜플의 첫 번째 요소 출력
print(t[-1])  # 튜플의 마지막 요소 출력

# 언팩킹1
(x1, x2, x3, x4) = t  # 튜플의 각 요소를 별도의 변수에 할당하는 과정을 언팩킹이라고 함.

# 출력확인
print(x1)  # 언팩킹으로 할당된 첫 번째 요소 출력
print(x2)  # 언팩킹으로 할당된 두 번째 요소 출력
print(x3)  # 언팩킹으로 할당된 세 번째 요소 출력
print(x4)  # 언팩킹으로 할당된 네 번째 요소 출력

# 언팩킹2
(x1, x2, x3, x4) = ('foo', 'bar', 'baz', 'qux')  # 직접 값을 할당하며 언팩킹

# 출력 확인
print(x1)  # 직접 언팩킹으로 할당된 첫 번째 요소 출력
print(x2)  # 직접 언팩킹으로 할당된 두 번째 요소 출력
print(x3)  # 직접 언팩킹으로 할당된 세 번째 요소 출력
print(x4)  # 직접 언팩킹으로 할당된 네 번째 요소 출력

# 팩킹 & 언팩킹
t2 = 1, 2, 3  # 세 개의 요소로 튜플 팩킹, 괄호가 없어도 튜플로 인식
t3 = 4,  # 단일 요소 튜플 팩킹 시, 쉼표 필요
x1, x2, x3 = t2  # 튜플 t2 언팩킹
x4, x5, x6 = 4, 5, 6  # 직접 값을 할당하며 변수에 언팩킹

# 출력 확인
print(t2)  # 팩킹된 튜플 t2 출력
print(t3)  # 팩킹된 튜플 t3 출력, 단일 요소 튜플 확인
print(x1, x2, x3)  # 언팩킹된 요소들 출력
print(x4, x5, x6)  # 직접 언팩킹된 요소들 출력
```
### 튜플은 불변성(`immutable`)으로 인해 수정할 수 없으므로, 데이터가 변경되지 않아야 할 때 유용하게 사용된다. 예를 들어, 함수에서 여러 값을 안전하게 반환할 때 튜플을 사용할 수 있다.
---

# 📚 파이썬 딕셔너리
#### 딕셔너리는 키-값 쌍으로 데이터를 저장하는 파이썬의 자료구조입니다. 리스트와는 달리, 순서를 보장하지 않지만 키를 통해 빠르게 값을 검색할 수 있다(범용적으로 가장 많이 사용, 딕셔너리 자료형(순서X, 키 중복X, 수정O, 삭제O)


## 🗂️ 딕셔너리 선언
```python
# 딕셔너리 선언과 기본 사용법

# 기본 딕셔너리 선언
a = {'name': 'Kim', 'phone': '01012345678', 'birth': '870124'}  # 개인 정보를 저장하는 딕셔너리
b = {0: 'Hello Python!'}  # 숫자를 키로 사용한 딕셔너리
c = {'arr': [1, 2, 3, 4]}  # 리스트를 값으로 가지는 딕셔너리
d = {
	 'Name': 'Niceman',
	 'City': 'Seoul',
	 'Age': '33',
	 'Grade': 'A',
	 'Status': True
}  # 다양한 타입의 값을 포함하는 딕셔너리
e =  dict([
	 ('Name', 'Niceman'),
	 ('City', 'Seoul'),
	 ('Age', '33'),
	 ('Grade', 'A'),
	 ('Status', True)
])  # 리스트를 사용하여 딕셔너리 생성 (튜플로 구성된 리스트)
f =  dict(
	 Name='Niceman',
	 City='Seoul',
	 Age='33',
	 Grade='A',
	 Status=True
)  # 키워드 인자를 사용하여 딕셔너리 생성

# 딕셔너리 내용 출력
print('a - ', type(a), a)  # a 딕셔너리의 타입과 내용 출력
print('b - ', type(b), b)  # b 딕셔너리의 타입과 내용 출력
print('c - ', type(c), c)  # c 딕셔너리의 타입과 내용 출력
print('d - ', type(d), d)  # d 딕셔너리의 타입과 내용 출력
print('e - ', type(e), e)  # e 딕셔너리의 타입과 내용 출력
print('f - ', type(f), f)  # f 딕셔너리의 타입과 내용 출력

# 딕셔너리에서 값 접근
print('a - ', a['name'])  # 직접 접근, 키 'name'의 값 출력
print('a - ', a.get('name'))  # .get 메소드로 'name' 키의 값 안전하게 가져오기
print('b - ', b[0])  # 직접 접근, 키 0의 값 출력
print('b - ', b.get(0))  # .get 메소드로 키 0의 값 안전하게 가져오기
print('c - ', c['arr'])  # 직접 접근, 키 'arr'의 리스트 값 출력
print('c - ', c.get('arr'))  # .get 메소드로 'arr' 키의 리스트 값 안전하게 가져오기
print('d - ', d.get('Age'))  # .get 메소드로 'Age' 키의 값 안전하게 가져오기
print('e - ', e.get('Grade'))  # .get 메소드로 'Grade' 키의 값 안전하게 가져오기
print('f - ', f.get('City'))  # .get 메소드로 'City' 키의 값 안전하게 가져오기

# .get 메소드는 지정된 키가 딕셔너리에 없을 경우 None을 반환, 에러 방지에 유용
```
## 🔍 딕셔너리 접근
#### 딕셔너리 내의 값에 접근하는 방법.

```python
print('a - ', a['name'])  # 직접 접근, 키가 없으면 에러 발생
print('a - ', a.get('name'))  # get 메소드 사용, 키가 없으면 None 반환
# .get() 메소드는 키가 딕셔너리에 없을 경우 None을 반환하여 프로그램의 안정성을 높여줌.
```
## ➕ 딕셔너리 추가
```python
# 딕셔너리 추가
a['address'] = 'seoul'  # 'a' 딕셔너리에 새로운 키-값 쌍('address': 'seoul')을 추
print('a - ', a)
a['rank'] = [1, 2, 3]  # 'a' 딕셔너리에 리스트를 값으로 가지는 새로운 키-값 쌍('rank': [1, 2, 3])을 추가
```
## 📏 딕셔너리 길이
```python
# 딕셔너리 길이 
print(len(a))  # 'a' 딕셔너리에는 3개의 키-값 쌍이 있다. (key의 총 개수를 출력)
print(len(b))  # 'b' 딕셔너리에는 1개의 키-값 쌍이 있다.
print(len(d))  # 'd' 딕셔너리에는 5개의 키-값 쌍이 있다.
print(len(e))  # 'e' 딕셔너리에는 5개의 키-값 쌍이 있다.
```
## 🔑 딕셔너리의 키, 값, 키-값 쌍 접근
```python
# dict_keys, dict_values, dict_items : 반복문(iterate) 사용 가능
print('a - ', a.keys())  # 'a' 딕셔너리의 모든 키를 출력
print('b - ', b.keys())  # 'b' 딕셔너리의 모든 키를 출력
print('c - ', c.keys())  # 'c' 딕셔너리의 모든 키를 출력
print('d - ', d.keys())  # 'd' 딕셔너리의 모든 키를 출력

print('a - ', list(a.keys()))  # 'a' 딕셔너리의 모든 키를 리스트로 변환하여 출력
print('b - ', list(b.keys()))  # 'b' 딕셔너리의 모든 키를 리스트로 변환하여 출력
print('c - ', list(c.keys()))  # 'c' 딕셔너리의 모든 키를 리스트로 변환하여 출력
print('d - ', list(d.keys()))  # 'd' 딕셔너리의 모든 키를 리스트로 변환하여 출력

print('a - ', a.values())  # 'a' 딕셔너리의 모든 값을 출력
print('b - ', b.values())  # 'b' 딕셔너리의 모든 값을 출력
print('c - ', c.values())  # 'c' 딕셔너리의 모든 값을 출력
print('d - ', d.values())  # 'd' 딕셔너리의 모든 값을 출력

print('a - ', list(a.values()))  # 'a' 딕셔너리의 모든 값을 리스트로 변환하여 출력
print('b - ', list(b.values()))  # 'b' 딕셔너리의 모든 값을 리스트로 변환하여 출력
print('c - ', list(c.values()))  # 'c' 딕셔너리의 모든 값을 리스트로 변환하여 출력
print('d - ', list(d.values()))  # 'd' 딕셔너리의 모든 값을 리스트로 변환하여 출력

print('a - ', a.items())  # 'a' 딕셔너리의 모든 키-값 쌍을 출력
print('b - ', b.items())  # 'b' 딕셔너리의 모든 키-값 쌍을 출력
print('c - ', c.items())  # 'c' 딕셔너리의 모든 키-값 쌍을 출력
rint('d - ', d.items())  # 'd' 딕셔너리의 모든 키-값 쌍을 출력

print('a - ', list(a.items()))  # 'a' 딕셔너리의 모든 키-값 쌍을 리스트로 변환하여 출력
print('b - ', list(b.items()))  # 'b' 딕셔너리의 모든 키-값 쌍을 리스트로 변환하여 출력
print('c - ', list(c.items()))  # 'c' 딕셔너리의 모든 키-값 쌍을 리스트로 변환하여 출력
print('d - ', list(d.items()))  # 'd' 딕셔너리의 모든 키-값 쌍을 리스트로 변환하여 출력
```
### .keys(), .values(), .items() 메소드는 딕셔너리의 키, 값, 키-값 쌍을 반복 가능한 객체로 반환.
## 🚮 딕셔너리 요소 삭제
```python
print('a - ', a.pop('name'))  # 'a' 딕셔너리에서 'name' 키를 가진 키-값 쌍을 제거하고, 그 값을 출력
print('b - ', b.pop(0))  # 'b' 딕셔너리에서 0 키를 가진 키-값 쌍을 제거하고, 그 값을 출력
print('c - ', c.pop('arr'))  # 'c' 딕셔너리에서 'arr' 키를 가진 키-값 쌍을 제거하고, 그 값을 출력
print('d - ', d.pop('City'))  # 'd' 딕셔너리에서 'City' 키를 가진 키-값 쌍을 제거하고, 그 값을 출

print('f - ', f.popitem())  # 'f' 딕셔너리에서 마지막 키-값 쌍을 제거하고, 그 쌍을 출력
print('f - ', f.popitem())  # 반복해서 'f' 딕셔너리의 키-값 쌍을 제거하고 출력
print('f - ', f.popitem())  # 이 과정을 'f' 딕셔너리가 비워질 때까지 계속 출력
print('f - ', f.popitem())
print('f - ', f.popitem())
# 예외
# print('f - ', f.popitem())  # 'f' 딕셔너리가 비어있을 때 popitem()을 호출하면 에러가 발생
```
### .pop() 메소드는 지정된 키의 값을 반환하고, 해당 키-값 쌍을 딕셔너리에서 삭제. 키가 딕셔너리에 없으면 오류가 발생.
## 🔄 수정
#### 딕셔너리의 수정

```python

# 딕셔너리 수정하기 예제

# 초기 상태의 딕셔너리 'f' 출력
print('f - 초기 상태:', f)

# 딕셔너리 'f'에서 'Age' 키의 값을 36으로 업데이트
f.update(Age=36)
print('f - Age를 36으로 업데이트:', f)

# 임시 딕셔너리 'temp' 생성
temp = {'Age': 27}

# 딕셔너리 'f'를 'temp' 딕셔너리로 업데이트. 'Age' 키의 값이 27로 변경.
f.update(temp)
print('f - temp 딕셔너리로 업데이트 후:', f)

# 위의 코드를 통해 딕셔너리 내부의 값을 수정하는 방법을 확인할 수 있다.
# .update() 메소드를 사용하면, 하나 이상의 키-값 쌍을 딕셔너리에 추가하거나 업데이트할 수 있다.
# 만약 업데이트하려는 키가 이미 딕셔너리에 존재한다면, 해당 키의 값을 새로운 값으로 변경.
```
#### .update() 메소드는 다른 딕셔너리 객체의 키-값 쌍으로 현재 딕셔너리를 업데이트.
####  딕셔너리는 키를 통해 빠르게 데이터에 접근할 수 있어 파이썬에서 널리 사용되는 자료형.
---
# 📚 파이썬 집합(Sets) 기본
#### 집합(Sets)의 특징 🌟

- 집합(Sets) 자료형은 **순서가 없고** 중복을 허용하지 않는다. 🚫🔢
- 이로 인해 집합은 데이터의 **유일성**을 보장하는 데 유용하게 사용. ✅
- 집합은 **수학적 연산**들을 구현할 수 있어, 교집합, 합집합, 차집합 등을 쉽게 처리할 수 있다. ➕➖
- Python에서 집합은 `{}` 또는 `set()` 함수를 사용하여 생성할 수 있다. 🛠️

## 📦 집합 선언하기
```py
a = set()  # 빈 집합 🚫
b = set([1, 2, 3, 4])  # 숫자로 구성된 집합 🔢
c = set([1, 4, 5, 6])  # 중복 없는 숫자 집합 🔢✔️
d = set([1, 2, 'Pen', 'Cap', 'Plate'])  # 숫자와 문자열 혼합 집합 📝✨
e = {'foo', 'bar', 'baz', 'foo', 'qux'}  # 문자열 집합, 중복 문자 'foo'는 한 번만 저장. 📛
f = {42, 'foo', (1, 2, 3), 3.14159}  # 다양한 타입이 혼합된 집합 🎲
```

# 🔢 집합 출력하기
```py
print('a - ', type(a), a)  # 'a'는 빈 집합입니다. 아무것도 없다 🚫
print('b - ', type(b), b)  # 'b'는 숫자 1, 2, 3, 4로 구성된 집합. 숫자만 있음 🔢
print('c - ', type(c), c)  # 'c'도 숫자로 구성된 집합이지만, 조금 다른 숫자들이 들어 있다. 🔢
print('d - ', type(d), d)  # 'd'는 숫자와 문자가 섞인 집합. 다양성이 있다 🎨
print('e - ', type(e), e)  # 'e'는 문자열만 포함된 집합인데, 'foo'가 중복되어도 한 번만 나타난다. 📛
print('f - ', type(f), f)  # 'f'는 정말 다양한 타입이 혼합된 집합. 숫자, 문자열, 튜플, 실수까지 🎲
```

# 🔄 집합을 튜플과 리스트로 변환하기

# 📦 튜플 변환
```py
t = tuple(b)  # 집합 b를 튜플로 변환.
print('t - ', type(t), t)  # 변환된 튜플 t의 타입과 내용을 출력.
print('t - ', t[0], t[1:3])  # 튜플 t의 첫 번째 요소와 1부터 2까지의 요소를 출력.
```
# 📝 리스트 변환
```py
l = list(c)  # 집합 c를 리스트로 변환.
l2 = list(e)  # 집합 e를 리스트로 변환. 중복이 제거된 후 변환된다.
print('l - ', type(l), l)  # 변환된 리스트 l의 타입과 내용을 출력.
print('l - ', l[0], l[1:3])  # 리스트 l의 첫 번째 요소와 1부터 2까지의 요소를 출력.
print('l2 - ', type(l2), l2)  # 변환된 리스트 l2의 타입과 내용을 출력.
```
# 📏 길이
```py
print(len(a))  # 빈 집합 a의 길이는 0.
print(len(b))  # 요소가 4개인 집합 b의 길이.
print(len(c))  # 요소가 4개인 집합 c의 길이.
print(len(d))  # 요소가 5개인 집합 d의 길이.
print(len(e))  # 중복이 제거된 후, 요소가 4개인 집합 e의 길이.
```

## 집합 자료형 활용하기 🛠️
```py
s1 = set([1, 2, 3, 4, 5, 6])
s2 = set([4, 5, 6, 7, 8, 9])
```

### 교집합 찾기 🤝
```py
print('교집합 - ', s1 & s2)  # '&' 연산자로 s1과 s2의 교집합을 찾는다.
print('교집합 (메소드 사용) - ', s1.intersection(s2))  # intersection() 메소드로 교집합을 찾는다.
```
### 합집합 구하기 🌐
```py
print('합집합 - ', s1 | s2)  # '|' 연산자로 s1과 s2의 합집합을 구함.
print('합집합 (메소드 사용) - ', s1.union(s2))  # union() 메소드로 합집합을 구함.
```
### 차집합 계산하기 ➖
```py
print('차집합 - ', s1 - s2)  # '-' 연산자로 s1에서 s2를 뺀 차집합을 계산.
print('차집합 (메소드 사용) - ', s1.difference(s2))  # difference() 메소드로 차집합을 계산.
```
### 중복 원소 확인하기 ❓
```py
print('중복 원소 확인 - ', s1.isdisjoint(s2))  # s1과 s2가 중복 원소가 없으면 True, 있으면 False를 반환. 여기서는 공통 원소가 있으므로 False.
```
### 부분 집합 확인하기 🔍
```py
print('s1이 s2의 부분 집합인가? - ', s1.issubset(s2))  # s1이 s2의 부분 집합인지 확인.
print('s1이 s2를 포함하는가? - ', s1.issuperset(s2))  # s1이 s2를 포함하는지 확인.
```
### 집합의 추가와 제거 작업 🛠️
```py
s1 = set([1, 2, 3, 4])
s1.add(5)  # 집합 s1에 요소 5를 추가.
print('s1 추가 후 - ', s1)

s1.remove(2)  # 집합 s1에서 요소 2를 제거. 요소가 존재하지 않을 경우 KeyError가 발생.
print('s1 제거 후 - ', s1)
# s1.remove(7)  # 집합에 없는 요소를 제거하려고 하면 KeyError가 발생.

s1.discard(3)  # 집합 s1에서 요소 3을 제거. 요소가 집합에 없어도 에러가 발생하지 않는다.
print('s1 discard 후 - ', s1)

# s1.discard(7)  # 집합에 없는 요소를 discard해도 에러가 발생하지 않는다.

# 집합의 모든 요소를 제거하여 빈 집합 만들기 🗑️
s1.clear()  # 집합 s1의 모든 요소를 제거. 이 작업은 리스트에서도 동일하게 적용.
print('s1 clear 후 - ', s1)  # 결과로 빈 집합이 출력.

a = [1, 2, 3]
print(a)  # 리스트 a의 초기 상태를 출력.
a.clear()  # 리스트 a의 모든 요소를 제거.
print(a)  # 리스트 a가 비어있음을 확인할 수 있다.
```
#### 위의 코드는 집합에서 특정 요소를 추가하거나 제거하는 방법을 보여준다. 집합은 .add() 메서드로 요소를 추가할 수 있고, .remove()로 요소를 제거할 수 있으나, 제거하려는 요소가 존재하지 않으면 에러가 발생한다. 반면, .discard() 메서드는 제거하려는 요소가 없어도 에러를 발생시키지 않아, 보다 안전하게 요소를 제거할 수 있게 한다. .clear() 메서드는 집합 내 모든 요소를 제거하여 빈 집합을 만들 때 사용된다. 🌈
---
# 파이썬 제어문 - IF문 기본 형식 📘
```py
print(type(True))  # True는 bool 타입. 🟢  # 0이 아닌수 , "abc", [1, 2, 3..], (1, 2, 3...) ...
print(type(False))  # False도 bool 타입. 🔴 0, "", [], (), {}...
```

#### 참(True)와 거짓(False)을 나타내는 여러 가지 경우들:
#### 참(True)의 경우: 0이 아닌 숫자, 비어 있지 않은 문자열("abc"), 비어 있지 않은 리스트([1, 2, 3]), 비어 있지 않은 튜플((1, 2, 3)), 등
#### 거짓(False)의 경우: 0, 빈 문자열(""), 빈 리스트([]), 빈 튜플(()), 빈 딕셔너리({}), None 등

## 들여쓰기(Indent)의 중요성 🛠

#### 파이썬에서는 코드의 구조를 나타내기 위해 들여쓰기를 사용. 
####  이는 파이썬의 가독성을 높이는 중요한 요소 중 하나.

### 예제: if문 사용 시 들여쓰기
```py
if True:
    print("이 문장은 들여쓰기 되어 있습니다.")  # 들여쓰기가 적용된 부분
    print("이것도 같은 블록에 속합니다.")  # 같은 들여쓰기 레벨을 유지
```
### 들여쓰기가 없는 경우
```py
if True:
print("이 문장은 들여쓰기 되어 있지 않습니다.")  # 들여쓰기 에러(SyntaxError) 발생
```
#### 들여쓰기는 일반적으로 공백 4개 또는 탭 1개를 사용. 
#### 파이썬 개발자들 사이에서는 공백 4개를 사용하는 것이 일반적인 규칙으로 받아들여짐.

#### 들여쓰기는 블록을 나타내기 위해 사용.
```py
for i in range(3):
    print(i)  # for문의 블록을 나타내기 위해 들여쓰기
    print("반복 중입니다.")  # 같은 블록

print("반복 완료!")  # for문의 블록 외부

# 들여쓰기를 통해 코드의 실행 흐름을 제어할 수 있으며, 가독성 높은 코드를 작성할 수 있다.
# 들여쓰기를 잘못 사용하면 'IndentationError'가 발생하므로 주의.
```

### 예제 1: True는 항상 "Good"을 출력.
```py
if True:
    print("Good")  # True일 때 실행. ✅  # 들여쓰기(Indent)
```
#### False는 실행되지 않으므로 "Bad"는 출력되지 않는다.
```py
if False:
    print("Bad")  # False일 때는 실행되지 않는다. ❌
```
### 예제 2: if-else 구문 사용하기
```py
if False:
    print("Bad")  # 이 부분은 실행되지 않는다. ❌
else:
    print("Good")  # 대신 이 부분이 실행. ✅
```

## 관계연산자란? 🤔

#### 파이썬에서 관계연산자는 두 값을 비교하는 데 사용.
#### 비교의 결과는 항상 불리언 값(True 또는 False)으로 반환.

### 다음은 파이썬의 관계연산자 종류:

###### >  크다
###### >= 크거나 같다
###### <  작다
###### <= 작거나 같다
###### == 같다
###### != 다르다

### 관계연산자 사용하기
```py
x = 15
y = 10
```
```py
# == 연산자: 양쪽 값이 같으면 참(True).
print(x == y)  # False ❌

# != 연산자: 양쪽 값이 다르면 참(True).
print(x != y)  # True ✅

# > 연산자: 왼쪽 값이 크면 참(True).
print(x > y)  # True ✅

# >= 연산자: 왼쪽 값이 크거나 같으면 참(True).
print(x >= y)  # True ✅

# < 연산자: 오른쪽 값이 크면 참(True).
print(x < y)  # False ❌

# <= 연산자: 오른쪽 값이 크거나 같으면 참(True).
print(x <= y)  # False ❌
```
## 참과 거짓 판별 in Python 🤖

#### 파이썬에서는 값이 존재하거나`(True)` 또는 존재하지 않거나`(False)`를 기반으로 참과 거짓을 판별.
```markdown
# 참(True)으로 판별되는 경우들:
# - "values": 문자열이 비어있지 않을 때
# - [values]: 리스트에 하나 이상의 항목이 있을 때
# - (values): 튜플에 하나 이상의 항목이 있을 때
# - {values}: 딕셔너리에 하나 이상의 키-값 쌍이 있을 때
# - 1 (또는 0이 아닌 모든 숫자): 숫자가 0이 아닐 때

# 거짓(False)으로 판별되는 경우들:
# - "": 빈 문자열
# - []: 빈 리스트
# - (): 빈 튜플
# - {}: 빈 딕셔너리
# - 0: 숫자 0
# - None: None 값은 아무것도 없음을 의미
```
## 참과 거짓 판별하기 🕵️‍♂️
```py
city = ""
if city:
    print("You are in:", city)  # city가 참이면 실행.
else:
    print("Please enter your city")  # city가 거짓이므로 이 부분이 실행. 🔍

city = "Seoul"
if city:
    print("You are in:", city)  # city에 값이 있으므로 이 부분이 실행. ✅
```
# 논리연산자 in Python 📘

#### 논리연산자는 두 가지 이상의 조건을 비교할 때 사용. Python에서는 `and`, `or`, `not` 세 가지 논리연산자를 제공.

### and 연산자 🤝
# - 모든 조건이 True일 때 True를 반환.
# 예시:
```py
if True and True:
    print("둘 다 참이면, 여기가 실행됩니다!")  # 출력: 둘 다 참이면, 여기가 실행!
```
### or 연산자 🤷‍♂️
# - 조건 중 하나라도 True라면 True를 반환.
# 예시:
```py
if True or False:
    print("하나라도 참이면, 여기가 실행됩니다!")  # 출력: 하나라도 참이면, 여기가 실행!
```
### not 연산자 ❗
# - True를 False로, False를 True로 바꾼다.
# 예시:
```py
if not False:
    print("거짓을 부정하면, 여기가 실행됩니다!")  # 출력: 거짓을 부정하면, 여기가 실행!
```
## 논리연산자 예시:
```py
a = 10
b = 20
if a < b and b > 15:
    print("a는 b보다 작고, b는 15보다 큽니다!")  # 출력: a는 b보다 작고, b는 15보다 크다!

if a > 5 or b < 15:
    print("a가 5보다 크거나, b가 15보다 작습니다!")  # 출력: a가 5보다 크거나, b가 15보다 작다!

if not a > 15:
    print("a는 15보다 크지 않습니다!")  # 출력: a는 15보다 크지 않다!
```
##### 논리연산자는 프로그램의 조건문에서 복잡한 조건을 표현하는 데 매우 유용. 🛠️
### 논리연산자 사용하기 🧠
```py
a = 75
b = 40
c = 10

print('and : ', a > b and b > c)  # a > b 그리고 b > c 둘 다 참이므로 결과는 True. ✅
print('or : ', a > b or b > c)    # a > b 또는 b > c 중 하나만 참이어도 결과는 True. ✅
print('not : ', not a > b)        # a > b의 반대입니다. a > b는 참이므로 여기서는 False. ❌
print('not : ', not b > c)        # b > c의 반대입니다. b > c는 참이므로 여기서는 False. ❌
print(not True)  # True의 반대는 False. ❌
print(not False) # False의 반대는 True. ✅
```
### 연산자 우선순위 in Python 🚀

##### Python에서 연산자의 우선순위는 매우 중요한 개념. 
#### 연산자의 우선순위는 산술연산자 ➡️ 관계연산자 ➡️ 논리연산자 순서로 적용.

#### 예시:

### 산술연산자 ➕➖✖️➗
```py
print("산술연산자 예시: ", 2 + 3 * 5)  # 결과: 17, 곱셈이 덧셈보다 먼저 계산.
```
### 관계연산자 ➡️ 크기비교
```py
print("관계연산자 예시: ", 5 * 2 == 10)  # 결과: True, 먼저 산술연산 후 관계연산이 수행.
```
### 논리연산자 ➡️ and, or, not
```py
print("논리연산자 예시: ", 5 > 3 and 2 == 2)  # 결과: True, 관계연산 후 논리연산이 수행.
```
### 💡 팁: 복잡한 표현식에서는 괄호()를 사용하여 연산의 순서를 명확히 할 수 있다.
```py
print("괄호 사용 예시: ", (5 + 3) * (2 == 2))  # 결과: 8, 괄호 안의 연산이 우선적으로 수행.
```
### 사용 예시:
```py
print('e1 : ', 3 + 12 > 7 + 3)  # 산술 연산 후 비교 연산이 수행. 결과는 True. ✅
print('e2 : ', 5 + 10 * 3 > 7 + 3 * 20) # 산술 연산 후 비교 연산이 수행. 결과는 False. ❌
print('e3 : ', 5 + 10 > 3 and 7 + 3 == 10) # 산술 > 비교 > 논리 순으로 연산이 수행. 결과는 True. ✅
print('e4 : ', 5 + 10 > 0 and not 7 + 3 == 10) # 산술 > 비교 > 논리 순으로 연산이 수행. 결과는 False. ❌

score1 = 90
score2 = 'A'

# 복수의 조건이 모두 참일 경우에 실행.
if score1 >= 90 and score2 == 'A':
    print("Pass. ✅")  # 두 조건이 모두 참이므로 이 문장이 실행.
else:
    print("Fail. ❌")

# 예제

id1 = "vip"
id2 = "admin"
grade = 'platinum'

# 조건 1: id1이 "vip"이거나 id2가 "admin"일 경우
if id1 == "vip" or id2 == "admin":
    print("관리자 인증 ✨") # 두 조건 중 하나만 만족해도 되므로 이 문장이 실행.

# 조건 2: id2가 "admin"이고, grade가 "platinum"인 경우
if id2 == "admin" and grade == "platinum":
    print("최상위 관리자 🌟") # 두 조건 모두 만족해야 하므로 이 문장이 실행.
```
## 다중 조건문과 중첩 조건문 활용하기 🌟
#### 여러 조건을 검사하여 해당하는 조건에 맞는 동작을 실행할 수 있다.

### 다중 조건문 예시:
```py
num = 90

# 다중 조건문을 사용해 성적에 따른 등급을 출력.
if num >= 90:
    print('Grade : A 🌟')  # num이 90 이상일 때
elif num >= 80:
    print('Grade : B 📈')  # num이 80 이상 90 미만일 때
elif num >= 70:
    print('Grade : C 📊')  # num이 70 이상 80 미만일 때
else:
    print('과락 ❌')  # 그 외의 경우
```
### 중첩 조건문 예시:
```py
# 중첩 조건문 예시
grade = 'A'
total = 95

if grade == 'A':
    if total >= 90:
        print("장학금 100% 💯")  # grade가 'A'이고, total이 90 이상일 때
    elif total >= 80:
        print("장학금 80% 💰")  # grade가 'A'이지만, total이 80 이상 90 미만일 때
    else:
        print("장학금 70% 💸")  # grade가 'A'이지만, total이 80 미만일 때
else:
    print("장학금 50% 🎓")  # grade가 'A'가 아닐 때
```

## `in`, `not in` 연산자를 통해 특정 값이 컨테이너 안에 존재하는지 확인할 수 있다.
```py
q = [10, 20, 30]  # 리스트
w = {70, 80, 90, 90}  # 집합
e = {"name": 'Lee', "city": "Seoul", "grade": "A"}  # 딕셔너리
r = (10, 12, 14)  # 튜플

print(15 in q)  # 15가 리스트 q에 있는지 확인. 결과는 False. ❌
print(90 in w)  # 90이 집합 w에 있는지 확인. 결과는 True. ✅
print(12 not in r)  # 12가 튜플 r에 없는지 확인. 결과는 False. ❌(포함되어 있기 때문)
print("name" in e)  # "name"이 딕셔너리 e의 키로 있는지 확인. 결과는 True. ✅
print("seoul" in e.values())  # "Seoul"이 딕셔너리 e의 값 중 하나인지 확인. 대소문자가 맞지 않아 결과는 False. ❌
```
---
# 코딩의 핵심: for 반복문 🔄

#### for 반복문은 컬렉션(리스트, 튜플, 딕셔너리, 집합 등)의 각 요소에 대해 코드 블록을 반복 실행.

### 기본 구조:
```py
for 변수명 in 컬렉션:
  반복 실행할 코드
```
### 🔢 0부터 9까지 반복
### range() 함수는 지정된 범위의 숫자를 생성. 
#### 예를 들어, `range(10)`은 `0`부터 `9`까지의 숫자를 생성.
```py
for v1 in range(10):
    print("v1 is :", v1)  # 여기서 v1은 0부터 9까지 순차적으로 변경.
```
### 🔢 1부터 10까지 반복
### range(시작, 종료)를 사용하여 특정 범위의 숫자를 생성.
#### 예를 들어, range(1, 11)은 1부터 10까지의 숫자를 생성.
```py
for v2 in range(1, 11):
    print("v2 is :", v2)  # 여기서 v2는 1부터 10까지 순차적으로 변경.
```
### 🔢 1부터 10까지 2씩 증가시키며 반복 (홀수만 출력)
### range(시작, 종료, 단계)를 사용하여 특정 단계만큼 증가하는 숫자를 생성.
#### 예를 들어, `range(1, 11, 2)`는 `1`부터 시작해 `2`씩 증가하며 `11`이 되기 전까지의 숫자를 생성. 즉, 홀수만 생성.
```py
for v3 in range(1, 11, 2):
    print("v3 is :", v3)  # 여기서 v3는 1, 3, 5, 7, 9.
```
### ➕ 1부터 1000까지의 합 계산
```py
sum1 = 0
for v in range(1, 1001):  # 1부터 1000까지 반복
    sum1 += v  # 각 숫자를 sum1에 더함
print('1 ~ 1000 합계 : ', sum1)  # 계산된 합계 출력

# 위의 반복문을 사용하지 않고, 파이썬 내장 함수 sum을 이용해 동일한 결과를 더 간단히 출력
print('1 ~ 1000 Sum : ', sum(range(1, 1001)))
```

### 1부터 1000까지 4의 배수의 합 계산하기 🔢
#### range의 세 번째 인자로 4를 설정하여 4씩 증가시키며 4의 배수만 합계에 포함
```py
print('1 ~ 1000 안에 4의 배수의 합 : ', sum(range(4, 1001, 4)))
```
## 반복 가능한 자료형과 함수들 🔄
#### 파이썬에서는 문자열, 리스트, 튜플, 집합, 사전과 같은 다양한 자료형을 반복할 수 있으며, 이를 위한 여러 내장 함수를 제공. 각 함수는 특정 작업을 수행하며 반복(iterable) 가능한 값을 반환.

- #### range() 🎯: 지정된 범위의 숫자 시퀀스를 생성.
- #### reversed() 🔙: 시퀀스를 반대로 뒤집음.
- #### enumerate() 🔢: 컬렉션의 요소와 그 인덱스를 튜플로 묶어 반환.
- #### filter() 🔍: 함수에서 True를 반환하는 요소만 포함하는 반복자를 반환.
- #### map() 🗺️: 모든 요소에 함수를 적용한 결과를 포함하는 반복자를 반환.
- #### zip() 🤝: 여러 반복 가능한 객체들을 조합하여 튜플의 시퀀스를 만듦.

## 파이썬 for 반복문 실습 🔄
### 예제1: 리스트로 이름 출력하기 📋
#### 각 이름 앞에 "You are"를 붙여서 출력.
```python
names = ["Kim", "Park", "Cho", "Lee", "Choi", "Yoo"]
for name in names:
    print("You are", name)
```
### 예제2: 로또 번호 순회하기 🎱
#### 로또 번호를 하나씩 출력하며 행운의 숫자를 확인.
```python
lotto_numbers = [11, 19, 21, 28, 36, 37]
for number in lotto_numbers:
    print("Current number : ", number)
```
### 예제3: 문자열 순회하기 🆎
#### `'Beautiful'` 이라는 단어의 각 문자를 하나씩 출력.
```python
word = 'Beautiful'
for s in word:
    print('word : ', s)
``` 
### 예제4: 딕셔너리 키와 값 순회하기 🔑
#### 딕셔너리에 저장된 정보(이름, 나이, 도시)를 키와 함께 출력.
```python
my_info = {
    "name": "Lee",
    "Age": 33,
    "City": "Seoul"
}
for key in my_info:
    print(key, ":", my_info[key])
```    
### 예제5: 대소문자 변환하여 출력하기 🔠
#### 문자열에서 대문자는 그대로, 소문자는 대문자로 변환하여 출력.
```python
name = 'FineApplE'
for n in name:
    if n.isupper():
        print(n)
    else:
        print(n.upper())
``` 
### break 사용 예제: 숫자 34 찾기 🚫
#### 숫자 리스트를 순회하며 34를 찾으면 "Found : 34!"를 출력하고 반복을 종료.
```python
numbers = [14, 3, 4, 7, 10, 24, 17, 2, 33, 15, 34, 36, 38]
for num in numbers:
    if num == 34:
        print("Found : 34!")
        break
    else:
        print("Not found : ", num)
```

### continue 사용 예제: 타입과 값을 출력하기 🔠
#### 리스트 lt의 각 요소에 대해, 요소가 bool 타입이면 건너뛰고, 그렇지 않으면 타입과 값을 3배 한 결과를 출력.
```python
lt = ["1", 2, 5, True, 4.3, complex(4)]
for v in lt:
    if type(v) is bool:
        continue
    print("current type : ", type(v))
    print("multiply by 2:", v * 3)
```

### 🔄 else 구문과 for 반복문 예제
#### numbers 리스트 안에서 숫자 45를 찾는다. 
#### 찾지 못하면 "Not Found 45..." 메시지를 출력.
```python
numbers = [14, 3, 4, 7, 10, 24, 17, 2, 33, 15, 34, 36, 38]

for num in numbers:
    if num == 45:
        print("Found : 45! 🎉")
        break
else:
    # 'else' 구문은 'for' 루프가 break 없이 완전히 실행된 후 실행.
    print("Not Found 45... 😞")
```
### 🧮 구구단 출력하기
#### 2단부터 9단까지 구구단을 출력. 각 값을 콘솔에 깔끔하게 정렬하기 위해 {:5d}를 사용.
```python
for i in range(2, 10):  # 2단부터 9단까지
    for j in range(1, 10):  # 각 단의 1부터 9까지 곱함.
        print('{:5d}'.format(i * j), end='')  # 결과값을 5자리로 맞춰 출력
    print()  # 단이 바뀔 때 줄바꿈
```
### 🔄 문자열 'Aceman' 변환하기 (변환예제)
#### 문자열을 뒤집고, 리스트, 튜플, 집합으로 변환해 출력.
```python
# 변환 예제: 문자열 'Aceman'을 뒤집고, 리스트, 튜플, 집합으로 변환해 출력
name = 'Aceman'
print('Reversed : ', reversed(name))  # reversed 함수는 반복 가능한 객체를 뒤집음. 하지만 직접 출력하면 객체의 위치만 보여줌
print('List : ', list(reversed(name)))  # 뒤집힌 문자열을 리스트로 변환해 출력
print('Tuple : ', tuple(reversed(name)))  # 뒤집힌 문자열을 튜플로 변환해 출력
# 뒤집힌 문자열을 집합으로 변환해 출력 집합은 순서를 보장하지 않으며, 중복된 문자는 제거
print('Set : ', set(reversed(name)))  # 순서X
```
# 🔄 파이썬에서의 While문 
### 🔄 While 기본 사용
```markdown
# while 문 기본 구조
# while <조건>:
#    <실행문>
```
### 🔄 While 기본 사용
```py
n = 5  # 📌 n 변수에 5를 할당.
while n > 0:  # ⏳ n이 0보다 클 동안 반복.
    print(n)  # 🖨️ 현재 n 값을 출력.
    n = n - 1  # ➖ n 값을 1 감소시킴.
```
### 🔄 While로 리스트 처리하기
```py
a = ['foo', 'bar', 'baz']  # 📜 리스트 a에 세 개의 문자열 요소 할당.

while a:  # 🔄 a 리스트가 비어있지 않은 동안 반복.
    print(a.pop())  # 🗑️ a 리스트의 마지막 요소를 제거하고 해당 요소를 출력.
```
### 🔚 Break 사용 예
```py
n = 5  # 📌 n 변수에 5를 할당.
while n > 0:  # ⏳ n이 0보다 클 동안 반복.
    n -= 1  # ➖ n 값을 1 감소시킴.
    if n == 2:  # 🛑 n이 2일 경우
        break  # ✋ 반복문을 즉시 종료.
    print(n)  # 🖨️ 현재 n 값을 출력.
print('Loop Ended.')  # 반복문 종료 후 출력.

i = 1  # i 변수에 1을 할당

while i <= 10:  # i가 10 이하일 동안 반복
    print('i:', i)  # 현재 i 값을 출력
    if i == 6:  # i가 6일 경우
        break  # 반복문을 즉시 종료
    i += 1  # i 값을 1 증가시킴
```
### ➡️ Continue 사용 예
```py
m = 5  # 📌 m 변수에 5를 할당.
while m > 0:  # ⏳ m이 0보다 클 동안 반복.
    m -= 1  # ➖ m 값을 1 감소시킴.
    if m == 2:  # 🔄 m이 2일 경우
        continue  # ⏭️ 다음 반복으로 즉시 넘어감. 아래 print 실행 안됨 X.
    print(m)  # 🖨️ 현재 m 값을 출력.
print('Loop Ended.')  # 반복문 종료 후 출력.
```
### 🔄 While - else 구문
```py
n = 10  # 📌 n 변수에 10을 할당.
while n > 0:  # ⏳ n이 0보다 클 동안 반복.
    n -= 1  # ➖ n 값을 1 감소시킴.
    print(n)  # 🖨️ 현재 n 값을 출력.
    if n == 5:  # 🛑 n이 5일 경우
        break  # ✋ 반복문을 즉시 종료.
else:
    # 반복문이 break로 종료되지 않고 정상적으로 종료되었을 때 실행.
    print('else out.')  # 🔄 반복문이 정상 종료되었음을 출력.
```
### 🔍 리스트에서 요소 찾기
```py
a = ['foo', 'bar', 'baz', 'qux']  # 📜 리스트 a에 네 개의 문자열 요소 할당.
s = 'qux'  # 🔍 s 변수에 문자열 'qux' 할당.

i = 0  # 📏 i 변수를 0으로 초기화.

while i < len(a):  # ⏳ i가 리스트 a의 길이보다 작은 동안 반복.
    if a[i] == s:  # ✅ 현재 인덱스의 리스트 요소가 s와 동일한 경우
        break  # ✋ 반복문을 즉시 종료.
    i += 1  # ➕ i 값을 1 증가시킴.
else:
    # 반복문이 break로 종료되지 않고 정상적으로 종료되었을 때 실행.
    print(s, 'not found in list.')  # 🔍 s가 리스트 a에 없음을 출력.
```
### 🔄 무한반복과 무한반복 탈출
```markdown
# 무한반복
# while True:
#     print('Foo')
```
```py
a = ['foo', 'bar', 'baz']  # 📜 리스트 a에 세 개의 문자열 요소 할당.
while True:  # 🔄 무한 반복.
    if not a:  # 🚫 a 리스트가 비어있으면
        break  # ✋ 반복문을 즉시 종료.
    print(a.pop())  # 🗑️ a 리스트의 마지막 요소를 제거하고 해당 요소를 출력.
```
# Functions 함수 쌩 기초 이론 설명 📚

## 🛠 파이썬 함수의 기초
#### 함수는 특정 작업을 수행하는 코드의 묶음. 함수를 사용함으로써 코드의 재사용성을 높이고, 프로그램의 구조를 명확하게 할 수 있다.

#### 함수
#### 프로그래머가 이름을 통해서 정의 후 필요할 때 마다 호출
#### 반복 되는 코드를 한 번 구현 후 재사용 가능한 코드의 집합
#### 함수 구현 -> 재사용, 루틴(프로시저, 서브루틴)


## 📚 함수의 정의와 호출
- #### 정의(Definition): 함수를 만드는 과정. def 키워드를 사용해 함수의 이름과 매개변수를 지정.
- #### 호출(Call): 정의된 함수를 사용하는 과정. 함수 이름과 괄호(())를 사용해 호출.
## 📖 함수의 종류
- #### 매개변수가 필요한 함수: 함수 작업 수행 시 외부에서 값을 받아와야 할 때 사용.
- #### 매개변수가 필요하지 않은 함수: 함수 내에서 모든 정보가 자체적으로 처리될 때 사용.
- #### 결과값을 반환하는 함수: 함수의 실행 후, 그 결과를 호출한 곳으로 돌려줄 때 사용.
- #### 결과값을 반환하지 않는 함수: 단순히 작업을 수행하고 끝나는 경우에 사용.
## 🎯 예제로 함수 이해하기
### 예제 1: 매개변수 필요 없는 함수
```python
def function1():
    print('예제1 호출')  # 출력: 예제1 호출
```
### 예제 2: 매개변수 필요한 함수
```python
def function2(a, b):
    print('예제2 호출', a, b)  # 예: function2(10, 20) -> 출력: 예제2 호출 10 20
```
### 예제 3: 결과값 반환하지 않는 함수
```python
def function3(x, y):
    print('예제3 호출', x, y)  # 예: function3(30, 40) -> 출력: 예제3 호출 30 40
```
### 예제 4: 결과값을 반환하는 함수
```python
def function4(x, y):
    return x + y  # 예: r = function4(50, 50) -> r에 100 저장
```
## 🚀 함수 실행하기
### 함수를 호출하려면 함수 이름 뒤에 괄호를 붙이고, 필요한 경우 괄호 안에 매개변수의 값을 넣는다.

```python
function1()  # 매개변수가 필요 없으므로 괄호만 사용
function2(10, 20)  # 매개변수가 필요하므로 괄호 안에 값을 넣어 호출
function3(30, 40)  # 이 함수는 매개변수를 받지만, 결과값을 반환하지 않음
r = function4(50, 50)  # 이 함수는 결과값을 반환함. 반환된 값을 변수 r에 저장

print('예제4 호출 결과:', r)  # 출력: 예제4 호출 결과: 100
```
#### 함수를 통해 코드의 재사용성을 높이고, 효율적으로 프로그램을 작성해보자! 🌈
---
# 🚀 파이썬 함수 및 입력 🚀
## 📖 파이썬 함수 사용법 📖 
### 함수의 중요성 🌟🌟🌟
#### 1. 코드의 재사용성(Reusability) 🎈
#### 함수를 사용하면 특정 기능을 수행하는 코드 블록을 한 번 작성해두고, 필요할 때마다 여러 곳에서 호출하여 사용할 수 있다. 이는 프로그램 전체에서 코드의 중복을 방지하고, 개발 시간을 절약할 수 있게 해준다. 예를 들어, 데이터 유효성 검사를 여러 곳에서 수행해야 한다면, 해당 로직을 함수로 만들어 두고 필요할 때마다 재사용할 수 있다.

#### 2. 큰 프로그램의 설계와 개발 용이성 🎈
#### 큰 규모의 프로그램을 개발할 때, 함수 단위로 설계하고 개발하면 프로젝트를 더욱 체계적으로 관리할 수 있다. 함수는 프로그램의 구성 요소를 논리적으로 분리하여, 각 부분의 역할과 책임을 명확히 할 수 있게 해준다. 이는 코드의 가독성을 높이고, 팀 내에서의 협업을 용이하게 한다. 또한, 프로그램의 각 부분을 독립적으로 테스트하고 디버깅할 수 있어, 전체 프로젝트의 안정성과 품질을 향상시킬 수 있다.

#### 3. 에러 수정의 용이성 및 코드의 안전성 🎈
#### 함수는 프로그램의 다른 부분과 격리된 채로 동작하기 때문에, 오류가 발생했을 때 해당 함수 내부에서 문제를 찾아 수정하기가 더욱 쉽다. 이는 디버깅 시간을 단축시켜주고, 프로그램의 전체적인 안정성을 유지하는 데 도움을 준다. 또한, 함수는 외부에서 접근할 수 있는 인터페이스(매개변수와 반환값)만을 제공하므로, 내부 구현을 숨길 수 있다. 이는 캡슐화의 원칙을 강화하여, 프로그램의 안전성을 높이는 데 기여한다.

#####  함수를 사용하는 것은 단순히 코드를 재사용하기 위한 목적뿐만 아니라, 프로그램의 설계와 구현, 유지 보수의 효율성을 높이는 데 필수적인 요소이다. 프로그램의 복잡성을 관리하고, 팀으로 협업하는 프로젝트에서 더욱 체계적으로 작업할 수 있게 해주며, 최종적으로는 더 나은 소프트웨어를 만드는 데 기여한다. 🚀
### 함수 네이밍
### 1️⃣ 풀 네임 사용
#### 함수 이름으로 그 기능을 자세히 설명하는 방식. 예를 들어, 어떤 리스트에서 최대 값을 찾는 함수는 find_maximum_value와 같이 명명할 수 있다. 이 방식의 장점은 함수 이름만 보고도 함수의 역할을 명확하게 알 수 있다는 것이다. 코드의 가독성이 높아지며, 프로젝트가 복잡해질수록 이해하기 쉬운 코드를 유지할 수 있다.

```python
def calculate_total_sum(numbers):
    return sum(numbers)
```
### 2️⃣ 축약형 사용
#### 함수 이름을 간단하게 축약하여 사용하는 방식이다. 예를 들어, `calculate_total_sum` 함수를 `calc_sum`과 같이 축약해서 명명할 수 있습니다. 축약형은 코드를 더 간결하게 만들어 줄 수 있지만, 함수의 역할을 명확하게 파악하기 어려울 수도 있다. 따라서, 널리 알려진 축약어나 팀 내에서 이미 정의된 축약어를 사용할 때 효과적이다.

```python
def calc_sum(numbers):
    return sum(numbers)
```
### 📌 결론
#### 함수의 이름을 결정할 때는 해당 함수의 역할, 팀 내의 네이밍 규칙, 코드의 일관성 등을 고려해야 합니다. 풀 네임을 사용하면 함수의 역할을 명확히 알 수 있어 코드의 이해도가 높아지는 반면, 축약형은 코드를 간결하게 유지할 수 있는 장점이 있다. 중요한 것은 프로젝트 내에서 일관된 규칙을 정하고 따르는 것이다. 🌈
### 함수 선언 및 사용
### 1️⃣ 기본 함수 정의와 호출
#### 함수는 `def` 키워드로 정의되며, 실행할 코드 블록을 포함하고. 함수를 호출하려면 함수 이름과 괄호(())를 사용하고, 필요한 경우 괄호 안에 인자를 제공한다.

```python
def first_func(w1):
    print("Hello, ", w1)

word = "Goodboy"
first_func(word)  # Hello,  Goodboy
```
#### 이 예제에서 `first_func` 함수는 인자 `w1`을 받아, `"Hello,"`와 함께 출력.

### 2️⃣ 값 반환하기
#### 함수는 `return` 키워드를 사용하여 값을 반환할 수 있다. 반환된 값은 함수를 호출한 곳에서 사용할 수 있다.

```python
def return_func(w1):
    value = "Hello, " + str(w1)
    return value

x = return_func('Goodboy2')
print(x)  # Hello, Goodboy2
```
#### `return_func` 함수는 주어진 인자 `w1`에 `"Hello,"`를 붙여 반환.

### 3️⃣ 다중 값을 반환하기
#### 파이썬에서 함수는 여러 값을 한 번에 반환할 수 있으며, 이는 튜플의 형태로 반환.

```python
def func_mul(x):
    y1 = x * 10
    y2 = x * 20
    y3 = x * 30
    return y1, y2, y3

x, y, z = func_mul(10)
print(x, y, z)  # 100 200 300
```
#### `func_mul` 함수는 인자 `x`에 대해 세 가지 연산을 수행하고, 세 개의 결과를 한 번에 반환.

### 4️⃣ 다양한 타입 반환하기
#### 함수는 튜플, 리스트, 딕셔너리 등 다양한 타입의 값을 반환할 수 있다.

#### 튜플 반환

```python
def func_mul2(x):
    return (x * 10, x * 20, x * 30)

q = func_mul2(20)
print(type(q), q, list(q))  # <class 'tuple'> (200, 400, 600) [200, 400, 600]
```
#### 리스트 반환

```python
def func_mul2(x):
    return [x * 10, x * 20, x * 30]

p = func_mul2(30)
print(type(p), p, set(q))  # <class 'list'> [300, 600, 900] {200, 400, 600}
```
#### 딕셔너리 반환

```python
def func_mul3(x):
    return {'v1': x * 10, 'v2': x * 20, 'v3': x * 30}

d = func_mul3(30)
print(type(d), d, d.get('v2'), d.items(), d.keys())  # <class 'dict'> {'v1': 300, 'v2': 600, 'v3': 900} 
```

## 📦 *args 사용하기: 여러 위치 인자를 튜플로 처리하기
#### `*args`는 함수에 여러 개의 위치 인자를 전달할 수 있게 해주며, 이러한 인자들을 함수 내에서 튜플`(tuple)` 형태로 다룹니다. 이 기능은 특히 함수에 전달되는 인자의 개수가 가변적일 때 유용.
- #### `*args`는 "`arguments`"의 줄임말이며, 여러 인자를 의미.
- #### 함수 정의 시 사용되는 * 기호는 해당 위치의 모든 인자를 튜플로 묶어주는 역할을 합.
- #### 함수 내부에서는 이 튜플에 담긴 인자들을 순회하며 필요한 작업을 수행할 수 있다.
```python
# *args를 사용한 함수 예시
def args_func(*args):   # args는 이제 함수로 전달된 모든 위치 인자들을 포함하는 튜플.
    for i, v in enumerate(args):  # enumerate를 사용하여 인덱스와 값을 함께 순회.
        print(args)  # 현재 args 튜플의 전체 내용을 출력합니다.
        print('Result--------------- : {},{}'.format(i, v))  # 인덱스와 해당 값 출력
    print('-----')  # 구분선을 출력.

# 함수를 다양한 인자 개수로 호출하기
args_func('Lee')  # 인자 하나
args_func('Lee', 'Park')  # 인자 두 개
args_func('Lee', 'Park', 'Kim')  # 인자 세 개
```
#### 🔹 *args를 사용함으로써 함수는 다양한 개수의 위치 인자들을 유연하게 받아 처리할 수 있으며, 이 인자들은 함수 내에서 `tuple`로 관리.

## 📑 **kwargs 사용하기: 여러 키워드 인자를 딕셔너리로 처리하기
#### `**kwargs`는 함수에 이름이 지정된 키워드 인자를 임의의 개수만큼 받을 수 있게 해주며, 이 인자들을 딕셔너리(`dictionary`) 형태로 함수 내부에서 처리. 이를 통해 각 인자의 이름을 키(`key`)로, 인자의 값을 값(`value`)으로 가지는 딕셔너리가 생성.

- #### `**kwargs`는 `"keyword arguments"`의 줄임말이며, 키워드를 가진 여러 인자들을 의미.
- ####  함수 정의 시 사용되는 ** 기호는 해당 위치의 모든 키워드 인자를 딕셔너리로 묶어주는 역할을 함.
- ####  함수 내부에서는 이 딕셔너리에 담긴 키워드 인자들을 순회하며 필요한 작업을 수행할 수 있다.

```python
# **kwargs를 사용한 함수 예시
def kwargs_func(**kwargs):  # **kwargs는 함수에 전달된 키워드 인자들을 딕셔너리로 처리.
    for v in kwargs.keys():  # kwargs 딕셔너리의 모든 키(인자 이름)를 순회.
        print("{}: {}".format(v, kwargs[v]))  # 키(인자 이름)와 해당 값 출력
    print('-----')  # 구분선을 출력.

# 함수를 다양한 키워드 인자로 호출하기
kwargs_func(name1='Lee')  # 키워드 인자 하나
kwargs_func(name1='Lee', name2='Park')  # 키워드 인자 두 개
kwargs_func(name1='Lee', name2='Park', name3='Cho')  # 키워드 인자 세 개
```
#### 🔹 `**kwargs`를 사용하면, 함수는 인자의 이름을 알고 있는 상태에서, 이들을 딕셔너리 형태로 유연하게 처리할 수 있다. 함수 내에서는 이 딕셔너리를 통해 인자들에 접근하고 사용할 수 있다.

### enumerate의 기본 구조
#### `enumerate`는 파이썬의 내장 함수로, 순회 가능한`(iterable) `데이터 구조(예: 리스트, 튜플, 문자열 등)를 인덱스와 함께 순회할 수 있게 해주는 함수. 이를 통해 반복문을 사용할 때 요소의 값을 뿐만 아니라, 해당 요소의 위치`(Index)`도 함께 얻을 수 있습니다. 이는 특히 리스트 같은 시퀀스를 순회할 때 매우 유용하며, 코드를 더 읽기 쉽고, 관리하기 쉽게 만들어 준다.
```python
enumerate(iterable, start=0)
iterable: 순회 가능한 데이터 구조(리스트, 튜플, 문자열 등).
start: 인덱스의 시작 번호로, 생략할 경우 기본값은 0.
```
### 사용 예시
#### 예를 들어, 리스트의 각 요소와 해당 요소의 인덱스를 출력하고 싶을 때 `enumerate` 함수를 사용할 수 있다.

```python
fruits = ['apple', 'banana', 'cherry']

for index, fruit in enumerate(fruits):
    print(index, fruit)
# 출력 결과:

0 apple
1 banana
2 cherry
```
#### 이 코드에서 `enumerate(fruits)`는 `fruits` 리스트의 각 요소와 그 요소의 인덱스를 튜플 형태로 반환합니다. `for`반복문에서 이를 `index`와 `fruit` 변수로 받아서 사용. 이 방법을 사용하면, 리스트의 인덱스를 수동으로 관리할 필요 없이 각 요소의 값을 쉽게 접근할 수 있다.

### 시작 번호 지정하기
#### `enumerate` 함수의`start`매개변수를 사용하여 인덱스의 시작 번호를 지정할 수도 있다. 예를 들어, 인덱스를 1부터 시작하게 하고 싶은 경우 다음과 같이 작성할 수 있다.

```python
for index, fruit in enumerate(fruits, start=1):
    print(index, fruit)
# 출력 결과:

1 apple
2 banana
3 cherry
```
#### 이렇게 `enumerate` 함수는 반복문에서 요소의 인덱스를 함께 사용하고자 할 때 매우 유용한 도구다.


## 전체 혼합 사용하기 🎉
#### 이 예제에서는 Python 함수가 어떻게 고정 인자, 가변 인자(*args), 그리고 키워드 가변 인자(**kwargs)를 동시에 다룰 수 있는지 보여준다`.

```python
# 전체 혼합 사용 예제
def example(args_1, args_2, *args, **kwargs):
    # args_1, args_2: 고정 위치 인자
    # *args: 추가적인 위치 인자들, 튜플로 처리
    # **kwargs: 키워드 인자들, 딕셔너리로 처리
    print(args_1, args_2, args, kwargs)

# 함수 호출
example(10, 20, 'Lee', 'Kim', 'Park', 'Cho', age1=20, age2=30, age3=40)
```
### 각 부분 설명 📚
- #### 고정 인자: 함수 정의에서 args_1과 args_2는 고정 위치 인자. 이들은 호출 시 반드시 값을 제공해야 하는 인자들.

#### 예제에서 args_1에는 10이, args_2에는 20이 할당.
#### *args (가변 위치 인자): 함수 호출 시 정해진 위치 인자 이외의 추가적인 인자들을 받는다. 이들은 함수 내부에서 튜플(args)로 처리.

#### 예제에서 'Lee', 'Kim', 'Park', 'Cho'가 args 튜플에 할당.
#### **kwargs (키워드 가변 인자): 이름이 지정된 인자들을 함수 호출 시 추가할 수 있으며, 이들은 함수 내에서 딕셔너리(kwargs)로 처리됨.

#### 예제에서 age1=20, age2=30, age3=40이 kwargs 딕셔너리에 할당.
#### 함수 호출 결과 📢
#### 함수를 호출하면 다음과 같은 출력:

```py
10 20 ('Lee', 'Kim', 'Park', 'Cho') {'age1': 20, 'age2': 30, 'age3': 40}
```
#### 10과 20은 고정 위치 인자 args_1과 args_2에 할당된 값.
#### ('Lee', 'Kim', 'Park', 'Cho')는 *args를 통해 전달된 추가적인 위치 인자들의 튜플.
#### {'age1': 20, 'age2': 30, 'age3': 40}은 **kwargs를 통해 전달된 키워드 인자들의 딕셔너리.

## 중첩 함수란? 🤔
#### 중첩 함수(`Nested Function`)란, 하나의 함수 내부에 다른 함수가 정의되어 있는 형태. 이 구조를 사용하면, 내부 함수는 외부 함수의 변수 및 인자에 접근할 수 있으며, 코드를 모듈화하여 가독성과 재사용성을 높일 수 있다.

### 예제 설명 📖
```python
# 중첩 함수 예제
def nested_func(num):
    # 내부 함수 정의
    def func_in_func(num):
        print(num)  # 내부 함수에서 인자 출력
    print("In func")  
    func_in_func(num + 100)  # 내부 함수 호출, 인자로 num + 100을 전달

nested_func(100)  # 외부 함수 호출
```
#### 외부 함수 nested_func: 이 함수는 num이라는 인자를 받고, 내부에 func_in_func라는 또 다른 함수를 정의하고 있다. 외부 함수에서는 "In func"이라는 메시지를 출력한 후, 내부 함수를 호출하면서 인자로 num + 100을 전달.

#### 내부 함수 func_in_func: 이 함수는 외부 함수로부터 받은 인자를 출력하는 역할을 함. 내부 함수는 외부 함수의 스코프에 접근할 수 있으므로, 외부 함수에서 전달된 데이터를 사용하거나 변경할 수 있다.

#### 중첩 함수의 특징 🌈
#### 캡슐화: 내부 함수는 외부에서 직접 호출할 수 없다. 즉, func_in_func(1000)과 같은 방식으로 외부에서 호출하려고 하면 에러가 발생. 이는 내부 함수가 외부 함수의 로직을 숨기고, 필요한 기능만을 외부에 노출시켜 캡슐화를 실현.

#### 스코프: 내부 함수는 외부 함수의 변수와 인자에 접근할 수 있다. 이는 어떤 데이터를 함수 간에 공유하고 싶을 때 유용.

```markdown
# 실행불가 예시
# func_in_func(1000)  # 외부에서 내부 함수를 직접 호출할 수 없다.
```
#### 이처럼 중첩 함수는 함수 내부의 로직을 모듈화하고, 외부에서의 접근을 제한하여 코드의 안정성을 높이는 데 도움을 준다. 또한, 특정 함수 로직을 한 곳에 집중시켜 가독성과 유지보수성을 향상시킬 수 있다. 🚀


## 람다 함수란? 🤔
#### 람다 함수(`lambda function`)는 파이썬에서 간단한 함수를 한 줄로 표현할 수 있게 해주는 기능. 주로 간단한 연산이나 함수를 인자로 넘길 때 사용되며, 코드를 간결하게 만들 수 있다.

### 기본 구조 🏗️
```python
lambda 매개변수들: 표현식
lambda 키워드로 시작.
```
#### 매개변수는 콤마(,)로 구분하여 여러 개를 지정할 수 있습니다.
#### 콜론(:) 뒤에는 이 함수가 반환할 표현식을 작성합니다.
### 예제 코드 🔍
```python
# 일반 함수 정의
def mul_func(x, y):
    return x * y  # x와 y를 곱한 결과를 반환

# 람다 함수 정의
a = lambda x, y: x * y
```
#### 위 예제에서 `mul_func` 함수는 두 매개변수를 받아 곱한 결과를 반환하는 일반적인 함수.
#### a에 할당된 람다 함수는 동일하게 두 매개변수를 받아 곱한 결과를 반환하지만, 한 줄로 간결하게 표현되어 있다.
### 람다 함수 사용하기 🚀
```python
print(a(5, 6))  # 람다 함수 호출
```
#### a(5, 6)을 호출하면, 람다 함수가 실행되어 5와 6을 곱한 결과인 30이 출력됨.
### 장단점 📊
- #### 장점: 람다 함수는 간단한 기능을 가진 함수를 빠르게 정의할 수 있으며, 코드가 더 간결해진다. 특히, 고차 함수(`higher-order function`)의 인자로 전달할 때 유용.
- #### 단점: 람다 함수는 복잡한 로직을 가진 함수에는 적합하지 않으며, 남발하면 코드의 가독성이 떨어질 수 있다.
### 메모리 관리 💾
- #### 일반 함수는 함수를 정의할 때마다 객체를 생성하고 메모리를 할당.
- #### 람다 함수는 즉시 실행되고 종료되면 메모리에서 해제되는 경향이 있다. 이는 람다 함수가 일시적인 사용에 더 적합하다는 것을 의미. 하지만 파이썬에서는 일반 함수와 람다 함수 간의 메모리 사용 효율에 큰 차이가 없으며, 메모리 최적화보다는 코드의 간결성과 가독성을 목적으로 사용.
- #### 람다 함수는 간단하고 일시적인 함수의 사용이 필요할 때 매우 유용. 하지만 함수의 로직이 복잡하거나 코드의 가독성이 중요한 경우, 일반 함수 정의 방식을 사용하는 것이 더 바람직할 수 있다. 📘🚀

### 일반 함수 예제 📝
```python
# 일반적인 함수 정의 및 사용 예시
def mul_func(x, y):
    return x * y  # 두 인자를 곱한 값을 반환

print(mul_func(10, 50))  # 일반 함수 호출


# 함수를 변수에 할당
mul_func_var = mul_func
print(mul_func_var(20,50))  # 할당된 변수를 통해 함수 호출
```
### 람다 함수 예제 🚀
```python
lambda_mul_func = lambda x, y: x * y  # 두 매개변수 x, y를 받아서 곱한 결과를 반환하는 람다 함수를 lambda_mul_func 변수에 할당.
print(lambda_mul_func(50, 50))  # 할당된 람다 함수를 호출하고, 50과 50을 인자로 넣어 결과를 출력. 출력 결과는 2500.

# func_final 함수 정의
def func_final(x, y, func):
    # x와 y는 일반적인 숫자 인자, func는 함수를 인자로 받는다.
    # 여기서 func 인자에는 람다 함수 또는 일반 함수가 올 수 있다.
    print('>>>>', x * y * func(100, 100))  # x와 y를 곱한 후, func 함수의 반환값(100과 100을 인자로 받은 결과)과 다시 곱함.
    # 이 결과를 출력. func으로 람다 함수나 일반 함수가 전달될 수 있으며, 그 함수는 100과 100을 인자로 받아 처리.

# func_final 함수 호출
# 첫 번째와 두 번째 인자로 10과 20을 전달하고, 세 번째 인자로 람다 함수 lambda_mul_func를 전달.
func_final(10, 20, lambda_mul_func)
# func_final(10, 20, lamda x,y:x*y) # 바로 람다 함수 사용가능
# 여기서 lambda_mul_func(100, 100)은 10000을 반환하고, 이는 최종적으로 10 * 20 * 10000 = 2000000을 출력하게 됨.
```
### 함수와 람다의 차이점 🌟
- #### 함수 정의: 일반 함수는 def 키워드를 사용하여 정의하고, 이름을 가집니다. 람다 함수는 lambda 키워드로 정의하며 이름이 없다.
- ####  코드 간결성: 람다는 간단한 연산이나 반환 로직에 유용하며, 코드를 한 줄로 작성할 수 있어 간결하다.
- ####  메모리 사용: 람다 함수는 사용 즉시 평가되고, 필요 없어지면 메모리에서 제거되어 일반 함수에 비해 메모리를 절약할 수 있다.
- ####  가독성: 복잡한 로직의 경우, 람다 함수는 오히려 코드의 가독성을 해칠 수 있으므로 적절한 사용이 중요하다.

#### 이 코드에서 사용된 `Hint`는 파이썬의 타입 힌트(`Type Hint`) 기능을 사용한 것. 타입 힌트는 파이썬 3.5 이상부터 사용할 수 있으며, 함수의 매개변수와 반환값에 예상되는 타입을 명시적으로 선언할 수 있게 한다. 코드의 가독성을 높이고, 개발자가 의도한 데이터 타입을 명확히 전달하기 위해 사용. 📘✏️

### 타입 힌트 사용 예시 📝
```python
# 타입 힌트를 사용한 함수 정의 예제
def tot_length1(word: str, num: int) -> int:
    # word 매개변수는 문자열(str)이어야 하며, num 매개변수는 정수(int)여야 함.
    # 이 함수는 정수(int)를 반환.
    return len(word) * num  # word의 길이와 num을 곱한 결과를 반환.
```
### 함수 호출 예시
```py
print('hint exam1 : ', tot_length1("i love you", 10))  # "i love you"의 길이와 10을 곱합니다.

def tot_length2(word: str, num: int) -> None:
    # 이 함수는 반환값이 없다(None). 그러나 함수의 동작을 출력.
    print('hint exam2 : ', len(word) * num)  # word의 길이와 num을 곱한 결과를 콘솔에 직접 출력.
```
### 또 다른 함수 호출 예시
```py
tot_length2("niceman", 10)  # "niceman"의 길이와 10을 곱한 결과를 출력.
```
### Hint가 중요한 이유 🌟
- #### 가독성 향상: 다른 사람이 코드를 읽을 때, 각 변수와 함수가 어떤 타입의 데이터를 다루는지 쉽게 이해할 수 있다.
- #### 개발 도중 실수 방지: 잘못된 타입의 데이터가 전달되는 것을 방지할 수 있다. (실제로 파이썬 인터프리터가 타입을 강제하지는 않지만, `IDE`나 `Linter`에서 경고를 줄 수 있다.)
- #### 문서화: 코드 자체가 문서의 역할을 하게 되어, 별도의 문서 작성이 줄어듦.
### 주의할 점 ⚠️
#### 파이썬은 동적 타입 언어이기 때문에, 타입 힌트는 강제되지 않는다. 즉, 타입 힌트와 다른 타입의 데이터가 전달되더라도 실행 시 오류가 발생하지 않는다. 타입 힌트는 개발자의 의도를 명확히 전달하기 위한 수단이며, 코드의 가독성과 안정성을 높이는 데 도움을 준다. 🚀
---
# 📥 파이썬 사용자 입력: input 사용법 및 기본 타입(str) 📥
## 📌 예제1: 기본적인 사용자 입력 받기 🖊️
```python
# 사용자로부터 이름, 등급, 회사 이름을 입력.
name = input("Enter Your Name : ")
grade = input("Enter Your Grade : ")
company = input("Enter Your Company name : ")

print(name, grade, company)
```
#### 이 예제는 사용자에게 이름, 등급, 회사 이름을 순서대로 입력받아 화면에 출력.
## 📌 예제2: 입력된 데이터의 타입 확인하기 🔍
```python
# 숫자와 이름을 문자열로 입력받아 타입을 확인.
number = input("Enter number : ")
name = input("Enter name : ")

print("type of number", type(number), number * 3)
print("type of name", type(name))
```
#### 입력받은 number와 name이 문자열(str)임을 확인하고, number에 대해 문자열 반복을 시도.
## 📌 예제3: 문자열 입력을 숫자로 변환하여 계산하기 🔢
```python
# 사용자로부터 두 개의 숫자를 입력받아 정수로 변환한 후, 덧셈 연산을 수행.
first_number = int(input("Enter number1 : "))
second_number = int(input("Enter number2 : "))

total = first_number + second_number
print("first_number + second_number : ", total)
```
#### 사용자의 입력을 정수(int)로 변환하여 더하는 방법을 보여줌.
## 📌 예제4: 실수 입력 받기 🌊
```python
# 사용자로부터 실수를 입력받아 해당 값과 타입을 출력.
float_number = float(input("Enter a float number : "))

print("input float : ", float_number)
print("input type : ", type(float_number))
```
#### 입력받은 값을 실수(float)로 변환하고, 이를 출력하여 확인.
## 📌 예제5: format() 함수와 함께 입력받아 출력하기 🖨️
```python
# `format()`을 사용해 사용자로부터 입력받은 이름을 바로 출력 포맷에 적용.
print("FirstName - {0}, LastName - {1}".format(input("Enter first name : "), input("Enter second name : ")))
```
#### 사용자로부터 입력 받은 데이터를 바로 format() 함수에 적용해 출력하는 방법.
#### 이렇게 각 예제에 이모지를 추가하여 설명. 이를 통해 `input()` 함수의 다양한 활용 방법을 보다 쉽게 이해하실 수 있고. 사용자로부터 데이터를 입력받고, 이를 프로그램 내에서 다루는 방법은 프로그래밍에서 매우 중요한 부분이다. 🌟
---
## 🛠 Input 사용법(2023년) - 기본 타입(str)
## 예제1 -> 예외처리 🚫
#### 사용자가 숫자를 입력해야 하는 상황에서 문자열 등 숫자가 아닌 다른 타입의 데이터를 입력했을 때 오류를 방지하는 방법.

```python
    n = int(input('Enter a number: '))  # 사용자로부터 입력받은 값을 정수로 변환.
    print('OK. Your number is: ', n)  # 변환에 성공하면 입력받은 숫자를 출력.

except ValueError:  # 정수로의 변환 시도 중 ValueError가 발생하면 실행.
    print('This is not a number.')  # 변환에 실패했음을 사용자에게 알림.
```
#### `try` 블록 안에서 사용자로부터 입력 받은 값`(input())을 정수(int)`로 변환.
#### 만약 사용자가 숫자가 아닌 다른 값을 입력하면, `ValueError` 예외가 발생하고 `except` 블록이 실행.
## 예제2 -> 올바른 값 입력 완료까지 지속 🔁
#### 사용자가 올바른 형태의 숫자를 입력할 때까지 계속해서 입력을 요청하는 방법.

```python
while True:  # 무한 루프를 시작.
    try:
        n = int(input('Enter a number: '))  # 사용자로부터 입력받은 값을 정수로 변환.
        break  # 정수 변환에 성공하면 루프를 빠져나옴.
    
    except ValueError:  # 정수로의 변환 시도 중 ValueError가 발생하면 실행.
        print('This is not a number. Try again.')  # 변환에 실패했음을 사용자에게 알리고 다시 시도하도록 함.
        
print('OK. Your number is: ', n)  # 최종적으로 올바른 숫자를 입력 받으면 그 값을 출력.
```
#### `while True`를 통해 무한 루프를 시작하고, 사용자로부터 올바른 형태의 입력(여기서는 숫자)을 받을 때까지 반복.
#### try 블록에서 입력 받은 값을 정수로 변환을 시도.
#### 숫자로 정상 변환되면 `break`를 통해 루프를 종료.
#### `ValueError` 예외가 발생하면, 즉 사용자가 숫자가 아닌 값을 입력하면, 사용자에게 오류 메시지를 출력하고 다시 입력을 요청.
#### 이러한 방식으로 `try`와 `except`를 사용하여 입력 값의 유효성 검사를 할 수 있으며, 사용자로부터 올바른 형태의 데이터를 안전하게 입력받을 수 있다. 🛡️🔄
---
# 전반부 복습 🔄📖
## print 함수와 포맷팅 🖨️🎨
- ### print 함수: 화면에 데이터를 출력하는 기본적인 방법. 📢
### 3가지 Print Formatting:
- #### .format(): 변수를 중괄호 {} 위치에 대입. {0}, {1} 형태로 인덱스 사용 가능. 🎯
- #### f-string: Python 3.6+에서 사용할 수 있으며, 문자열 앞에 f를 붙이고, 중괄호 안에 직접 변수명을 넣어 사용. 🆕
- #### %: C 스타일의 포맷팅 방법으로, %s, %d 등의 형식 지정자를 사용. 🔄
- #### 출력 옵션: 자릿수 조절, 왼쪽/오른쪽/가운데 정렬, 공백 채우기 등을 설정할 수 있다. 📏
## 변수와 예약어 📦🚫
- #### 변수 선언과 재선언: 값을 저장하기 위해 변수를 선언하고, 값을 변경하여 재선언할 수 있다. 💾
- #### 객체의 고유 값: 변수는 메모리 상의 객체를 참조하며, 각 객체는 고유한 값을 가진다. 🔍
#### 참조 유형:
- #### 같은 객체 참조: 두 변수가 같은 메모리 주소의 객체를 참조. ↔️
- #### 다른 객체 참조: 각 변수가 서로 다른 객체를 참조. ↕️
- #### 예약어: 파이썬에서 미리 정의된 특별한 의미를 가진 단어들로, 변수명 등으로 사용할 수 없다. 🚫
## 파이썬 자료형과 연산자 🔢✖️
- #### 자료형: 파이썬에서 데이터를 분류하는 기준 (예: int, str, bool). 🔢
- #### 연산자: 데이터를 가공하거나 비교하는데 사용되는 기호들 (예: +, -, ==, !=). 🔗
- #### type 함수: 변수의 자료형을 확인하는 함수. 🆔
- #### 형 변환: 한 데이터 타입을 다른 타입으로 변경하는 행위 (예: int()로 문자열을 정수로 변환). 🔄
## 파이썬 문자형 사용 📝
- #### 문자형의 다양한 활용법: 문자열 데이터를 다루는 방법, 예를 들어 출력, 길이 계산, 반복 등. 🔤
- #### 이스케이프: 특수 문자를 표현하기 위한 방법, 예를 들어 \n은 줄바꿈을 의미. ⬅️
- #### 멀티라인 문자열: 여러 줄에 걸쳐 문자열을 정의할 때 사용 (""" 또는 '''). 📄
- #### 문자열 연산과 슬라이싱: 문자열을 합치거나, 특정 부분을 추출하는 기법. ✂️
## 리스트의 특징과 활용 📋
- #### 리스트: 순서가 있는 변경 가능한 항목의 집합. 리스트를 통해 데이터를 순차적으로 저장하고 관리할 수 있다. 🛒
- #### 리스트 활용: 인덱싱, 슬라이싱, 연산, 비교, 수정, 삭제 등 리스트에 저장된 데이터를 다양하게 처리. 🔄
## 튜플의 이해와 활용 📌
- #### 튜플: 변경 불가능한(immutable) 순서가 있는 데이터 집합. 한 번 생성 후 항목을 변경할 수 없다. 🚫🔄
- #### 튜플 팩킹 & 언팩킹: 여러 데이터를 튜플로 묶거나, 튜플의 각 항목을 여러 변수에 할당하는 과정. 📦➡️
## 딕셔너리의 특징과 활용 📖
### 딕셔너리 (Dictionary) 🔑
#### 딕셔너리는 키(key)와 값(value)의 쌍으로 이루어진 데이터 구조입니다. Python 3.7 이상에서는 요소들이 추가된 순서를 기억하며, 이를 통해 데이터에 빠르고 순차적으로 접근할 수 있다. 이는 코드의 예측 가능성과 읽기 쉬움을 향상.

### 딕셔너리 활용 ➕➖
- #### 데이터 조회: 딕셔너리의 키를 사용하여 해당하는 값을 빠르게 찾을 수 있다. 예: value = my_dict["key"]
- #### 데이터 추가: 새로운 키와 값을 딕셔너리에 추가할 수 있다. 예: my_dict["new_key"] = "new_value"
- #### 데이터 수정: 기존의 키에 대한 값을 새로운 값으로 변경할 수 있다. 예: my_dict["existing_key"] = "new_value"
- #### 데이터 삭제: 특정 키와 그에 해당하는 값을 딕셔너리에서 제거할 수 있다. 예: del my_dict["key_to_delete"] 또는 my_dict.pop("key_to_delete")
### 순서의 중요성 🚀
#### Python 3.7 이전에는 딕셔너리의 순서가 무작위로 보였으나, Python 3.7 이후 버전에서는 딕셔너리가 요소를 추가한 순서를 유지. 이로 인해 순서가 중요한 작업에서도 딕셔너리를 사용할 수 있게 되었다. 예를 들어, 데이터를 순차적으로 출력하거나 순서에 의존하는 작업을 할 때 유용.

- #### 순서 유지: 딕셔너리를 반복하거나 리스트로 변환할 때, 요소들이 삽입된 순서대로 처리.
- #### 읽기와 작성의 일관성: 코드를 통해 딕셔너리를 생성하고, 그 순서대로 요소들이 저장되며, 이후에 접근할 때도 같은 순서를 갖는다.
## 집합(Sets)의 특성과 변환 🎲
- #### 집합: 중복을 허용하지 않고, 순서가 없는 데이터 집합. 데이터의 유일성을 보장. 🚫🔢
- #### 집합 변환: 집합을 리스트나 튜플로 변환하여 순서를 부여하거나, 중복 제거에 활용할 수 있다. ↔️
## 파이썬 제어문 - IF문 🚦
- #### IF문: 조건에 따라 다른 코드를 실행하도록 한다. 조건이 참이면 if 블록의 코드를, 거짓이면 else 블록의 코드를 실행. 🤔➡️
## 반복문 - FOR문 🔁
- #### FOR문: 리스트, 문자열 등 Iterables 자료형을 반복하여 각 요소에 대한 코드를 실행. 🔄
- #### 반복 제어: break, continue를 사용하여 반복문의 흐름을 제어. ⏯️
## 반복문 - while문 ⏳
- #### while문: 조건이 참인 동안 코드 블록을 반복 실행합니다. 무한 루프를 만들거나, 특정 조건까지 코드를 실행할 때 사용. 🔃
## 파이썬 함수의 정의와 람다 함수 🛠️
- #### 함수: 코드의 재사용을 위해 정의된 코드 블록. 함수를 통해 코드를 모듈화하고, 가독성을 높일 수 있다. 📦
- #### 람다 함수: 간단한 함수를 한 줄의 코드로 작성하는 방법. 임시 함수를 만들 때 유용. 🎯
## 사용자 입력과 예외 처리 📥🛡️
- #### input 함수: 사용자로부터 문자열 입력을 받습니다. 기본 타입은 str. 🖊️
- #### 예외 처리: 입력 값 검증이나 변환 과정에서 발생할 수 있는 예외를 처리. 안정적인 프로그램 실행을 위해 중요. 🚫
---

# 🐍 파이썬 클래스와 OOP 🔄
#### 객체 지향 프로그래밍(OOP, Object-Oriented Programming)은 프로그램을 여러 개의 독립된 객체들의 모임으로 파악하고자 하는 프로그래밍 패러다임. 파이썬에서 클래스는 OOP의 핵심 요소로, 데이터와 기능을 함께 묶어 관리할 수 있게 한다.

## 🤝 클래스와 인스턴스 차이
- #### 클래스(Class): 특정 객체를 생성하기 위한 틀 또는 설계도. 클래스는 객체의 기본 형태와 행동 방식을 정의.
- #### 인스턴스(Instance): 클래스를 기반으로 생성된 객체. 클래스에서 정의한 대로 메모리에 할당된 실체.
## 🌌 네임스페이스
- #### 네임스페이스(Namespace): 객체를 인스턴스화할 때, 그 객체의 속성(attribute)과 메소드(method)가 저장되는 공간. 각 인스턴스는 자신만의 네임스페이스를 가지고, 여기에 변수들이 저장됨.
## 📚 클래스 변수 vs 인스턴스 변수
- #### 클래스 변수:

#### 클래스 정의 내부에서 생성되며, 클래스 자체에 속하는 변수.
#### 클래스의 모든 인스턴스들 사이에서 공유되며, 클래스명.변수명으로 접근 가능.
#### 예: 학생 클래스에서 학생들이 다니는 학교명을 클래스 변수로 설정할 수 있다.
#### 인스턴스 변수:

#### 클래스의 각 인스턴스, 즉 객체마다 별도로 존재하는 변수.
#### self.변수명을 사용하여 각 인스턴스 내에서 정의하고 접근.
#### 예: 학생 클래스의 인스턴스인 각 학생의 이름을 인스턴스 변수로 설정할 수 있다.

## self의 이해와 활용 in 파이썬 클래스 🐍🔍
### self는 클래스 내부에서 현재 인스턴스 객체를 참조하는 데 사용되는 변수. 즉, 클래스의 메소드를 호출할 때, 해당 메소드를 호출한 인스턴스 자체가 첫 번째 인자로 전달되며, 이를 self라고 표현.

## 🌱 self의 주요 사용 사례:
### 인스턴스 변수 접근 📦:

#### 클래스 내부에서 self.변수명을 통해 인스턴스 변수에 접근.
#### 객체의 상태를 저장하거나 수정할 때 사용.
### 메소드 호출 📞:

#### 같은 객체 내의 다른 메소드를 self.메소드명() 형식으로 호출.
#### 이를 통해 객체의 행동을 정의하고, 코드의 재사용성을 높일 수 있다.
### 🌟 self의 특징:
#### 첫 번째 매개변수:

#### self는 파이썬 클래스 메소드의 첫 번째 매개변수로 사용됨.
#### 메소드를 호출하는 객체 자신을 참조.
#### 관례적 이름:

#### 파이썬에서 self의 이름은 관례적으로 사용.
#### 다른 이름을 사용할 수도 있으나, self가 일반적으로 좋은 프로그래밍 관습으로 간주. 📚
### 객체의 속성과 메소드에 접근:

#### self를 통해 클래스 내부에서 객체의 속성(`attributes`)과 메소드(`methods`)에 접근할 수 있다.
#### 객체 지향 프로그래밍의 핵심적인 기능을 구현하는 데 필수적. 🛠️
#### self는 클래스 내부에서 객체의 인스턴스를 참조하며, 클래스의 인스턴스 간에 데이터와 행위를 구분 짓는 중요한 역할을 함. 객체 지향 프로그래밍에서 `self`를 이해하고 활용하는 것은 파이썬 프로그래밍의 기본이며, 효과적인 코드 구조를 만드는 데 있어 핵심적인 요소. 🌈🚀

## 예제1: 기본적인 클래스 정의와 인스턴스 생성 🏗️
```python
class Dog:  # Dog 클래스 정의
    # 클래스 속성: 모든 Dog 인스턴스가 공유하는 속성
    species = 'firstdog'
    
    # 초기화 메소드 / 인스턴스 속성 정의
    def __init__(self, name, age):
        self.name = name  # 각 인스턴스 고유의 이름
        self.age = age  # 각 인스턴스 고유의 나이

# 클래스 정보 출력
print(Dog)

# 인스턴스화: Dog 클래스로부터 개별 객체(인스턴스) 생성
a = Dog("mikky", 2)
b = Dog("baby", 3)

# 객체 비교: a와 b는 다른 객체임
print(a == b, id(a), id(b))

# 네임스페이스: 객체의 속성 저장 공간 확인
print('dog1', a.__dict__)
print('dog2', b.__dict__)    

# 인스턴스 속성 확인: 각 인스턴스의 이름과 나이 출력
print('{} is {} and {} is {}'.format(a.name, a.age, b.name, b.age))

# 클래스 속성 접근: 모든 Dog 인스턴스가 공유하는 'species' 속성 출력
if a.species == 'firstdog':
    print('{0} is a {1}'.format(a.name, a.species))

# 클래스 및 인스턴스를 통한 속성 접근
print(Dog.species)  # 클래스 이름을 통해 클래스 속성 접근
print(a.species)  # 인스턴스를 통해 클래스 속성 접근
print(b.species)  # 인스턴스를 통해 클래스 속성 접근
```
## 📖 개념 정리:
- ### 클래스(Class): 객체를 생성하기 위한 틀. Dog 클래스는 강아지 객체를 생성하기 위한 설계도 역할을 함.

- ### 인스턴스(Instance): 클래스를 기반으로 생성된 객체. 여기서 a와 b는 Dog 클래스의 인스턴스.

- ### 클래스 속성(Class Attribute): 클래스에 속한 속성으로, 클래스의 모든 인스턴스가 공유. 예를 들어, species는 모든 Dog 인스턴스가 공유하는 속성.

- ### 인스턴스 속성(Instance Attribute): __init__ 메소드 안에서 정의되며, 각 인스턴스마다 고유의 값이 있다. name과 age는 각 Dog 인스턴스마다 다를 수 있다.

- ### 메소드(Method): 클래스 내에 정의된 함수로, 해당 클래스의 인스턴스에 속한 데이터를 처리하는 데 사용된다.

- ### 네임스페이스(Namespace): 인스턴스가 속성을 저장하는 공간으로, __dict__를 통해 해당 인스턴스의 모든 속성을 확인할 수 있다.
  
## 예제2: self의 이해 🤔🔍
```python
class SelfTest:
    # 클래스 메소드 정의
    def func1():
        print('Func1 called')
    
    # 인스턴스 메소드 정의
    def func2(self):
        print(id(self))  # 현재 메소드를 호출한 인스턴스의 id 출력
        print('Func2 called')
```
## 클래스 메소드 vs 인스턴스 메소드:
- #### `func1`은 `self` 매개변수를 받지 않으므로 클래스 메소드로 정의. 🏷️
- #### `func2`는 첫 번째 매개변수로 `self`를 받으므로 인스턴스 메소드. 🆔
```python
f = SelfTest()  # SelfTest 클래스의 인스턴스 생성
```
- #### 인스턴스 생성: `SelfTest` 클래스로부터` f `인스턴스를 생성. 🐣
```python
print(id(f))  # 생성된 인스턴스 f의 id 출력
```
- #### 인스턴스 ID 확인: 인스턴스` f`의 고유 `ID`를 출력. 이 `ID`는 메모리 주소를 나타내며, func2에서 출력된 `ID`와 일치. 🔍
```python
f.func2()  # 인스턴스 메소드 호출
```
- #### 인스턴스 메소드 호출: `func2` 메소드를 인스턴스 `f`를 통해 호출하며, `self`로 `f`가 전달됨. f의 ID와 '`Func2 called`'가 출력. 📞
```python
SelfTest.func1()  # 클래스를 통한 클래스 메소드 호출
```
- #### 클래스 메소드 호출: 클래스`SelfTest`를 통해 `func1` 메소드를 직접 호출. `'Func1 called'`가 출력. 📢
```python
SelfTest.func2(f)  # 클래스를 통한 인스턴스 메소드 호출, 인스턴스 f를 명시적으로 전달
```
- #### 클래스를 통한 인스턴스 메소드 호출: 클래스 이름을 사용하여 `func2`를 호출할 때, 인스턴스 `f`를 `self` 매개변수로 전달해야 함. 이 경우에도` f`의 `ID`와 `'Func2 called'`가 출력. 🔄
## 주의사항 ⚠️:
- #### `func1` 메소드는 `self`를 매개변수로 받지 않으므로, 인스턴스 `f`를 통해 호출하려고 하면 예외가 발생.
- #### 마찬가지로, `func2` 메소드는 `self` 매개변수가 필요하기 때문에, 클래스 `SelfTest`를 통해 직접 호출하려면 인스턴스를 명시적으로 전달해야 합니다.
- #### 이 예제를 통해 `self`가 인스턴스 메소드에서 현재 인스턴스를 참조하는 역할을 한다는 것을 이해할 수 있다. `self`를 사용하여 클래스 내부에서 인스턴스 변수에 접근하고, 인스턴스의 메소드를 호출할 수 있다. 클래스와 인스턴스 메소드의 올바른 사용 방법을 알아가는 중요한 단계! 🚀

## 🏭 클래스 변수 vs 인스턴스 변수 🆚
```python
class Warehouse:
    # 클래스 변수
    stock_num = 0  # 모든 인스턴스가 공유하는 변수, 재고 수량을 나타냄.
    
    def __init__(self, name):
        # 인스턴스 변수
        self.name = name  # 각 인스턴스 고유의 이름
        Warehouse.stock_num += 1  # 인스턴스 생성 시 재고 수량 증가
    
    def __del__(self):
        Warehouse.stock_num -= 1  # 인스턴스 소멸 시 재고 수량 감소
```
### 클래스 변수 stock_num 🔄: Warehouse 클래스의 모든 인스턴스에 의해 공유됨. 클래스 단위에서 관리되며, 모든 인스턴스가 동일한 값을 보유.

### 인스턴스 변수 name 🆔: 생성된 각 Warehouse 인스턴스에 고유합니다. 인스턴스마다 독립적인 값을 가짐.

### 🚶‍♂️ 생성자(__init__)와 소멸자(__del__)
- #### 생성자 __init__ 🏗️: 객체가 생성될 때 자동으로 호출되는 메소드. 여기서 인스턴스 변수를 초기화하고, 클래스 변수를 조작할 수 있다.

- ####  소멸자 __del__ 🧨: 객체가 소멸될 때 자동으로 호출되는 메소드. 주로 리소스 정리 작업에 사용됨. 여기서는 인스턴스가 소멸할 때 stock_num을 감소시켜 재고를 조정.

### 📝 예제 사용
```python
user1 = Warehouse('Lee')  # 첫 번째 Warehouse 인스턴스 생성
user2 = Warehouse('Cho')  # 두 번째 Warehouse 인스턴스 생성

print(Warehouse.stock_num)  # 클래스 변수에 접근하여 현재 재고 수량 출력, 결과는 2
```
- ####  Warehouse 인스턴스가 두 개 생성되어, stock_num은 2가 됨.
```python
print(user1.name)  # 첫 번째 인스턴스의 이름 출력: Lee
print(user2.name)  # 두 번째 인스턴스의 이름 출력: Cho
# 각 인스턴스의 name 속성을 출력하여 인스턴스 변수가 각 인스턴스마다 독립적임을 확인.
```
```python
print(user1.__dict__)  # user1 인스턴스의 네임스페이스 출력
print(user2.__dict__)  # user2 인스턴스의 네임스페이스 출력
# __dict__를 통해 각 인스턴스의 속성과 값을 확인할 수 있습니다. 인스턴스 변수만 포함.
```
```python
print('before', Warehouse.__dict__)  # 클래스 변수를 포함한 Warehouse 클래스의 네임스페이스 출력
print('>>>', user1.stock_num)  # 인스턴스를 통해 클래스 변수에 접근, 결과는 2
# 클래스의 __dict__를 통해 클래스 변수를 확인할 수 있으며, 인스턴스를 통해서도 클래스 변수에 접근할 수 있다.
```
```python
del user1  # user1 인스턴스 삭제
print('after', Warehouse.__dict__)  # user1 삭제 후 클래스의 네임스페이스 출력
# user1을 삭제하면 __del__ 메소드가 호출되어 stock_num이 감소. 결과적으로 재고 수량이 감소하여 클래스 변수 stock_num의 값이 변경.
```
#### 이 예제는 클래스 변수와 인스턴스 변수의 개념을 명확히 이해하는 데 도움을 준다. 클래스 변수는 클래스에 속하며 모든 인스턴스에 의해 공유되는 반면, 인스턴스 변수는 각 인스턴스에 고유하며 독립적인 값을 가짐. 생성자와 소멸자는 객체의 생명주기 동안 자동으로 호출되는 특별한 메소드로, 리소스의 할당과 해제에 유용하게 사용된다. 🚀✨

## 🐕 예제4: 클래스 메소드와 인스턴스 생성 🗣️
### 📚 클래스 정의하기
```python
class Dog:  # Dog 클래스 정의, 모든 클래스는 파이썬에서 기본적으로 object 클래스를 상속받는다.
    # 클래스 속성
    species = 'firstdog'  # 🌍 모든 Dog 인스턴스가 공유하는 속성, 모든 개는 'firstdog'이라는 종을 갖는다.
    
    # 초기화 메소드 / 인스턴스 속성
    def __init__(self, name, age):
        self.name = name  # 🏷️ 각 인스턴스 고유의 이름
        self.age = age  # 📅 각 인스턴스 고유의 나이
    
    # 인스턴스 메소드: 개의 정보를 반환
    def info(self):
        return '{} is {} years old'.format(self.name, self.age)  # 📜 개의 이름과 나이를 문자열로 반환.
        
    # 인스턴스 메소드: 개가 소리를 낸다
    def speak(self, sound):
        return "{} says {}!".format(self.name, sound)  # 🗣️ 개가 내는 소리를 문자열로 반환.
```
### 🐶 인스턴스 생성
```python
c = Dog('July', 4)  # 'July'라는 이름과 4살 나이를 가진 Dog 인스턴스를 생성.
d = Dog('Marry', 10)  # 'Marry'라는 이름과 10살 나이를 가진 Dog 인스턴스를 생성.
```
### 📢 메소드 호출
```python
# 인스턴스 메소드 호출
print(c.info())  # 'July is 4 years old'를 출력.
print(d.info())  # 'Marry is 10 years old'를 출력.
```

### 📢 speak 메소드 호출
```py
print(c.speak('Wal Wal'))  # 'July says Wal Wal!'를 출력.
print(d.speak('Mung Mung'))  # 'Marry says Mung Mung!'를 출력.
```
### 💡 주석 설명
- #### 클래스와 인스턴스: Dog 클래스는 개의 이름과 나이를 저장하는 템플릿으로 작동. 각 Dog 인스턴스(예: c, d)는 이 템플릿을 사용하여 개별 개의 정보를 저장.

- ####  클래스 속성 vs 인스턴스 속성: `species`는 모든 인스턴스에서 공유하는 클래스 속성. 반면, `name`과 `age`는 각 인스턴스에 고유한 속성.

- #### 메소드: `info`와 `speak` 메소드는 인스턴스에 대한 정보를 반환하고, 개가 어떤 소리를 내는지 문자열로 표현.

#### 이 예제를 통해 클래스의 구조와 기능, 인스턴스 생성 방법, 그리고 인스턴스 메소드의 호출 방법을 배울 수 있다. 클래스를 사용함으로써 관련 데이터와 함수를 묶어서 효율적으로 관리할 수 있으며, 코드의 재사용성과 구조화를 향상시킬 수 있다. 🌈🚀
---
# 파이썬 모듈 📦🔍
## 📁 모듈이란?
#### 모듈(Module)은 함수, 변수, 클래스 등 파이썬 구성 요소들을 모아놓은 파일. 모듈을 사용함으로써 코드를 재사용하기 쉽게 만들고, 파일을 기능별로 분리하여 프로그램을 체계적으로 관리할 수 있다.

## 🧮 기본 연산 모듈 예제
```python
# 기본 연산을 수행하는 함수들을 포함하는 모듈 예제

def add(x, y):
    return x + y

def subtract(x, y):
    return x - y

def multiply(x, y):
    return x * y

def divide(x , y):
    return x / y
    
def power(x, y):
    return x ** y
```
- #### add: 두 수를 더함.
- #### subtract: 첫 번째 수에서 두 번째 수를 뺌.
- #### multiply: 두 수를 곱함.
- #### divide: 첫 번째 수를 두 번째 수로 나누기.
- #### power: 첫 번째 수의 두 번째 수 승을 계산.
### 🚀 __name__ 사용하기
#### 파이썬 파일이 `"직접 실행"`될 때와 "`모듈로 임포트되어 실행`"될 때를 구분하기 위해 __name__ 변수를 사용. 파일이 직접 실행될 때 __name__ 변수의 값은 "__main__"이 된다.

```python
if __name__ == "__main__":
    print('-' * 15)
    print('called! __main__')
    print(add(5,5))  # 10을 출력
    print(subtract(15,5))  # 10을 출력
    print(multiply(5,5))  # 25를 출력
    print(divide(10,2))  # 5를 출력
    print(power(5,3))  # 125를 출력
    print('-' * 15)
```
#### if __name__ == "__main__": 이 조건문은 현재 파일이 프로그램의 시작점인지 확인.
#### 이 구문을 사용하면, 모듈이 다른 파일에 임포트될 때는 내부 코드가 실행되지 않고, 파일이 직접 실행될 때만 코드가 실행.
## 🎯 주요 포인트
- #### 모듈: 코드의 재사용성을 높이고, 프로그램을 체계적으로 관리할 수 있게 해주는 파이썬 파일.
- #### __name__: 파이썬 스크립트가 직접 실행되었는지, 아니면 모듈로서 다른 파일에 의해 임포트되어 실행되었는지를 판별할 때 사용됨.
#### 이 설명이 모듈의 개념과 __name__의 사용 방법을 이해하고. 모듈을 통해 코드를 모듈화하고 재사용하는 방법을 배우는 것은 파이썬 프로그래밍에서 매우 중요. 🌟


# 모듈 사용 실습 🛠️
## 파이썬에서 모듈을 사용하면, 표준 라이브러리 또는 외부 라이브러리의 기능을 활용할 수 있다. 여기서는 sys 모듈을 사용하는 기본적인 예제를 다뤄보자.

## sys 모듈 🖥️
#### sys 모듈은 파이썬 인터프리터와 관련된 함수와 변수들을 제공. 예를 들어, 스크립트를 실행하기 위한 많은 설정들과 함수들에 접근할 수 있게 해준다.

```python
import sys  # sys 모듈을 임포트.

print(sys)  # sys 모듈 객체를 출력.

print(sys.path)  # 파이썬 모듈들이 저장되어 있는 위치의 리스트를 출력.

print(type(sys.path))  # sys.path의 타입을 출력. 결과는 <class 'list'>.
```
#### sys.path는 파이썬이 모듈을 찾기 위해 검색하는 디렉토리의 리스트. 이 리스트에 디렉토리 경로를 추가하면, 해당 경로에 있는 모듈도 임포트할 수 있다.
## 모듈 경로 삽입 📂
```python
# 모듈 경로 삽입
sys.path.append('C:/math')  # sys.path 리스트에 'C:/math' 경로를 추가.
```
#### 이렇게 하면, 'C:/math' 디렉토리에 있는 파이썬 파일(모듈)을 임포트할 수 있게 된다.
## 모듈 사용 📚
```python
# import test_module  # test_module.py 파일을 임포트.

# 모듈 사용
 print(test_module.power(10, 3))  # test_module 모듈의 power 함수를 사용하여 10의 3승을 계산.
```
#### 모듈이 임포트되면, 해당 모듈에 정의된 함수, 변수, 클래스 등을 사용할 수 있다.
# 모듈 임포트 📖
```python
import chapter06_02  # chapter06_02.py 파일을 임포트.
```
#### 이 부분은 `chapter06_02`라는 이름의 파이썬 파일(모듈)을 현재 스크립트에 임포트하는 예시. 임포트된 모듈의 함수나 변수, 클래스 등을 사용할 수 있게 됨.
#### 이 실습을 통해 파이썬에서 모듈을 임포트하는 방법과 sys.path를 통해 모듈 검색 경로를 관리하는 방법에 대해 알아보았다. 모듈을 사용하면 다양한 기능을 쉽게 활용할 수 있어 파이썬 프로그래밍이 더욱 효율적이고 강력해진다. 🌈
---

## 📦 패키지란 무엇인가요?
#### 패키지는 관련된 모듈들을 모아둔 폴더. 이를 통해 코드를 모듈화하여 재사용성을 높이고, 프로젝트의 구조를 체계적으로 관리할 수 있다. 간단히 말해서, 패키지는 코드를 깔끔하고 관리하기 쉽게 도와주는 폴더 시스템. 🗃️

## 🗂 __init__.py 파일
#### 파이썬에서는 특정 폴더가 패키지의 일부임을 인식하기 위해 __init__.py 파일을 사용. 이 파일은 패키지 초기화 코드를 담거나 비어 있을 수 있다. `Python 3.3` 이상에서는 이 파일 없이도 폴더를 패키지로 인식하지만, 호환성을 위해 여전히 이 파일을 포함시키는 것이 좋다. 📝

## 🛤 상대 경로 사용
#### 패키지 내부에서 다른 모듈을 임포트할 때, 상대 경로를 사용할 수 있다. 이 방식은 코드를 더욱 간결하게 만들고, 모듈 간의 의존성을 쉽게 관리할 수 있게 해준다.

- ### .: 현재 디렉토리, 즉 같은 패키지 내의 다른 모듈을 가리킵니다. 📂
- ### ..: 부모 디렉토리, 즉 한 단계 상위 패키지를 가리킵니다. 📁
### 🚀 패키지 사용 예시
#### 예제 1: 직접 임포트
```python
import package.module  # 특정 패키지의 모듈을 직접 임포트.
```
#### 이 방법을 사용하면, 패키지 안에 있는 특정 모듈을 직접 사용할 수 있다. 패키지와 모듈 이름을 명시해 주어야 한다.

#### 예제 2: 상대 경로 임포트
##### 같은 패키지 내 모듈 임포트
```python
from . import module2  # 현재 패키지 내의 module2를 임포트.
```
##### 상위 패키지에서 하위 패키지 모듈 임포트
```python
from ..subpackage import module3  # 부모 패키지 내의 subpackage의 module3를 임포트.
```
#### 이 방법들을 사용하면, 코드의 재사용성을 높이고, 프로젝트의 구조를 더욱 명확하게 만들 수 있다. 상대 경로를 사용함으로써, 패키지 구조 변경에 더 유연하게 대응할 수 있다. 🛠️

# 🧩 sys와 inspect 모듈 활용하기
## 🛠️ sys 모듈
### sys 모듈은 파이썬 인터프리터와 관련된 함수와 변수들을 포함하고 있다. 예를 들어, sys.path는 파이썬이 모듈을 검색할 때 참조하는 경로 목록.

## 🔍 inspect 모듈
#### `inspect` 모듈은 파이썬 코드의 실행 중인 객체들에 대한 정보를 얻기 위해 사용. 여기서는 현재 실행 중인 함수의 파일 경로를 얻는 데 사용.

## 📝 코드 예제
### module2.py
```python
import sys
import inspect

def mod2_test1():
    print("Module2 -> Test1")
    # 현재 함수의 파일 경로를 출력.
    print("Path : ", inspect.getfile(inspect.currentframe()))

def mod2_test2():
    print("Module2 -> Test2")
    # 현재 함수의 파일 경로를 출력.
    print("Path : ", inspect.getfile(inspect.currentframe()))
```
### module1.py
```python
import sys
import inspect

def mod1_test1():
    print("Module1 -> Test1")
    # 현재 함수의 파일 경로를 출력.
    print("Path : ", inspect.getfile(inspect.currentframe()))

def mod1_test2():
    print("Module1 -> Test2")
    # 현재 함수의 파일 경로를 출력.
    print("Path : ", inspect.getfile(inspect.currentframe()))
```
## 📌 설명
#### inspect.getfile(inspect.currentframe()): 이 코드는 현재 실행 중인 함수가 정의된 파일의 경로를 반환. `inspect.currentframe()` 함수는 현재의 스택 프레임을 가져오고, `inspect.getfile()` 함수는 주어진 프레임의 파일 경로를 찾는다.

#### `print("Module1 -> Test1")`와 같은 문장은 각 함수가 호출될 때, 해당 함수가 어느 모듈의 일부인지를 식별하는 메시지를 출력.
## 💭 주의사항
#### 상대경로를 사용한 모듈 임포트 (예: from ..sub1 import module1)는 해당 코드가 어떤 패키지 구조 안에 포함되어 있을 때만 유효. 이 문서에서는 주석 처리되어 있어, 실제 코드 구조와 패키지 구성에 따라 주석을 해제하고 사용할 수 있다.
#### 이 예제를 통해 현재 실행 중인 코드의 위치를 파악하는 방법과 sys, inspect 모듈의 기본적인 사용법에 대해 알아보았다. 이는 디버깅이나 코드 분석 시 유용하게 사용될 수 있다. 🚀🔎

## 🎯 예제들을 통한 패키지 사용법과 sys.path의 이해
### 📂 예제 1: 모듈을 전체 경로로 임포트하기
```python
import sub.sub1.module1
import sub.sub2.module2

# 모듈의 함수 사용
sub.sub1.module1.mod1_test1()
sub.sub1.module1.mod1_test2()

sub.sub2.module2.mod2_test1()
sub.sub2.module2.mod2_test2()
```
#### 이 방법은 모듈을 패키지 경로를 포함하여 전체 경로로 직접 임포트.
#### 패키지와 모듈의 구조를 명확히 알 수 있게 해주지만, 사용할 때마다 전체 경로를 지정해야 하는 번거로움이 있다. 🛣️
### 🛤 예제 2: 모듈 임포트 및 별칭 사용
```python
from sub.sub1 import module1
from sub.sub2 import module2 as m2  # 별칭 사용
# 모듈의 함수 사용
module1.mod1_test1()
module1.mod1_test2()

m2.mod2_test1()
m2.mod2_test2()
```
#### `from ... import ...`를 사용하여 모듈을 임포트하고, 필요한 경우 별칭(as)을 지정해 사용의 편의성을 높일 수 있다.
#### 코드를 더 깔끔하게 유지할 수 있으며, 함수 호출 시 모듈의 전체 경로를 지정할 필요가 없다. 📌
### 🌟 예제 3: 패키지로부터 모든 것 임포트하기
```python
from sub.sub1 import *
from sub.sub2 import *

# 모듈의 함수 사용
module1.mod1_test1()
module1.mod1_test2()

module2.mod2_test1()
module2.mod2_test2()
```
#### from ... import * 구문을 사용하여 패키지의 모든 모듈을 임포트.

### 🌟 from ... import * 구문의 사용과 주의점
#### from ... import * 구문은 특정 모듈이나 패키지로부터 모든 것을 임포트. 이 방식은 특정 모듈의 모든 정의(함수, 변수, 클래스 등)를 현재 네임스페이스로 가져오므로, 코드를 작성할 때 매우 편리할 수 있다. 그러나 이 방법은 몇 가지 주의해야 할 점이 있다:

- #### 이름 충돌: 다른 모듈에서 같은 이름의 객체를 임포트하는 경우, 예상치 못한 오류가 발생할 수 있다. 마지막으로 임포트된 객체가 이전에 임포트된 객체를 덮어쓰게 된다. ⚠️
- #### 가독성 저하: 어떤 모듈에서 어떤 객체가 정의되었는지 명확하지 않아 코드의 가독성이 떨어질 수 있다. 👀
- #### 성능 저하: 사용하지 않는 객체까지 모두 임포트하기 때문에, 불필요한 메모리 사용이 발생할 수 있다. 특히 많은 모듈을 `import *`로 가져올 경우, 이로 인한 메모리 사용량이 증가할 수 있다. 📉
#### 성능과 메모리 사용에 대한 고려
#### 비록 현대의 컴퓨터가 충분한 성능과 메모리를 제공하지만, 효율적인 프로그래밍 관습은 여전히 중요하다. 특히, 대규모 프로그램이나 메모리 사용이 중요한 응용 프로그램에서는 더욱 그렇다.

- #### 명확한 임포트: 필요한 객체만 명확하게 지정하여 임포트하는 것이 좋다. 예를 들어, `from module import specific_function`과 같이 사용하면, 프로그램의 가독성을 유지하고 메모리 사용을 최적화할 수 있다. 🚀
- #### 런타임 성능: `import *` 사용으로 인한 런타임 성능 저하는 일반적으로 미미할 수 있지만, 여러 패키지에서 대량의 불필요한 임포트가 누적되면 메모리 부담이 증가하고, 결국에는 애플리케이션의 전반적인 성능에 영향을 줄 수 있다. 💾
#### 좋은 프로그래밍 습관은 자원을 절약하고, 코드의 유지보수성을 높이며, 향후 발생할 수 있는 문제를 미연에 방지하는 데 도움이 된다. 따라서 가능한 한 명확하게 필요한 것만 임포트하여 사용하는 것이 권장된다. 🌱
- #### 이 방법은 편리하지만, 다른 모듈에서 이름이 겹칠 경우 예상치 못한 오류가 발생할 수 있으므로 주의가 필요하다. ⚠️
### 💡 sys.path와의 연관성
#### sys.path는 파이썬 인터프리터가 모듈을 검색할 때 참조하는 디렉토리 목록. 파이썬이 모듈을 임포트할 때, `sys.path`에 나열된 디렉토리들을 순서대로 검색하여 해당 모듈을 찾는다.

#### 패키지를 사용할 때, 패키지가 위치한 디렉토리가 sys.path에 포함되어 있어야 파이썬이 해당 패키지를 찾을 수 있다.
#### 만약 패키지가 `sys.path`에 나열된 경로 밖에 있다면, `sys.path.append('/path/to/package') `메소드를 사용하여 패키지 경로를 `sys.path`에 추가해야 한다. 🛠️
```python
import sys
sys.path.append('/path/to/package')
```
#### 이렇게 sys.path를 이해하고 관리하는 것은 파이썬에서 패키지를 효과적으로 사용하는 데 매우 중요🌟
## 🌟 복습 🌟
### 🚀 __pycache__와 컴파일
#### 파이썬은 코드를 실행할 때, `.py` 파일을 바이트 코드로 "컴파일"하고 이를 __pycache__ 폴더에 저장. 이 바이트 코드는 파이썬이 실행할 때 더 빠르게 로드할 수 있게 해준다. 컴파일이라는 용어는 전통적인 컴파일 언어와는 다소 다르게 사용되지만, 여기서는 파이썬 코드를 실행 가능한 바이트 코드로 변환하는 과정을 의미. 🚗💨
### 📂 __init__.py 파일과 __all__ 변수
- #### __init__.py: 이 파일은 특정 폴더가 파이썬 패키지의 일부임을 나타낸다. Python 3.3 이상에서는 __init__.py 파일 없이도 폴더를 패키지로 인식하지만, 하위 호환성을 위해 여전히 이 파일을 사용하는 것이 좋다. 🗂️

#### __all__ 변수: __init__.py 파일 안에서 __all__ 변수를 사용하여, 패키지로부터 from ... import * 할 때 어떤 모듈이 임포트될지 명시적으로 지정할 수 있다. 이는 패키지를 사용하는 다른 개발자들에게 어떤 모듈이 공개 인터페이스의 일부인지 알려주는 역할도 한다. 예를 들어, __all__ = ['module1', 'module2']라고 설정하면, module1과 module2만 from ... import *를 통해 임포트될 수 있다. 🔐

#### 🌍 패키지의 중요성
#### 파이썬에서 패키지를 사용하면 코드를 모듈화하고 재사용하기 쉽게 만들 수 있습니다. 또한, 패키지는 프로젝트의 구조를 명확하게 하고, 다양한 기능을 로직별로 분리하여 관리할 수 있게 해줍니다. 패키지는 마치 폴더처럼 동작하며, 모듈과 서브패키지를 포함할 수 있다. 🏗️
#### 🛠️ 패키지 임포트 방법
#### from ... import ... 절을 사용하는 것이 일반적으로 편리하다. 이 방법은 필요한 모듈만 명확하게 지정하여 임포트할 수 있게 해주며, 코드의 가독성을 높이고 반복을 최소화할 수 있다. 또한, 별칭(as)을 사용하여 모듈에 대한 참조를 더 간단하게 만들 수도 있다. 🖋️
#### 패키지를 효과적으로 사용함으로써, 코드의 구조를 개선하고 다른 개발자들과의 협업을 용이하게 만들 수 있다. 이러한 방법들은 파이썬 어플리케이션을 개발할 때 중요한 기본 요소다. 🌟
---
# 파이썬 예외처리의 이해 🐍🔧
## 🚨 예외(Exception)란?
### 프로그램 실행 중에 발생하는 오류로, 예상치 못한 상황에서 프로그램이 중단되지 않도록 처리해야 하는 중요한 사건.

## 📚 예외 종류
#### 파이썬에서는 다양한 종류의 예외가 있으며, 각각 다른 원인에 의해 발생.

- #### SyntaxError: 구문 오류, 잘못된 파이썬 문법 사용
- #### TypeError: 연산이나 함수가 적절하지 않은 타입의 객체에 적용됨
- #### NameError: 지역 또는 전역 이름을 찾을 수 없음
- #### IndexError: 시퀀스 인덱스가 범위 밖에 있음
- #### ValueError: 연산이나 함수가 적절한 값이 아닌 경우
- #### KeyError: 딕셔너리에서 존재하지 않는 키를 사용함
### 🛡️ 예외 처리하기
#### 예외 처리는 `try, except` 블록을 사용하여 수행. 이를 통해 예외가 발생할 가능성이 있는 코드를 `try` 블록에 넣고, 예외 발생 시 실행할 코드를 `except` 블록에 넣는다.

```python
try:
    # 예외 발생 가능성이 있는 코드
except 예외유형 as 변수:
    # 예외 처리 코드
```
### 📌 예외 처리의 기본 원칙
#### 예외는 반드시 처리해야 한다. 👍

- #### 예외를 처리함으로써 프로그램의 갑작스런 중단을 방지하고, 사용자에게 오류에 대한 정보를 제공할 수 있다.
- ####  로그는 반드시 남겨야 한다. 📝

- ####  예외가 발생했을 때, 로그를 남기면 문제의 원인을 파악하고 해결하는 데 도움이 된다.
- ####  필요한 경우 예외를 던질 수 있다. 🚀

- ####  `raise` 키워드를 사용하여 예외를 명시적으로 발생시킬 수 있다. 이는 상위 코드 블록에서 예외를 처리하도록 할 때 유.
- ####  예외를 무시할 수도 있다. 🙈

- ####  특정 예외를 무시하려면, `except` 블록을 비워두거나` pass` 문을 사용할 수 있다. 그러나 이는 권장되지 않는 방법이다.


### SyntaxError: 문법 오류 🚫📚
#### SyntaxError는 파이썬 코드가 올바른 문법에 따라 작성되지 않았을 때 발생하는 오류. 코드를 작성할 때 발생할 수 있는 몇 가지 일반적인 SyntaxError 예시와 그 해결 방법을 알아보자.

### 예시 1: 따옴표 누락
```python
# 오류 코드
##해결: 문자열을 올바르게 닫기 위해 따옴표를 추가.

# 정정 코드
print('error')
```
### 예시 2: 괄호 불일치
```python

# 오류 코드
print('error'))
#해결: 괄호의 개수를 올바르게 조정.
# 정정 코드
print('error')
```
### 예시 3: 콜론(:) 누락
```py
# 오류 코드
if True
    pass
#문제: if 문 뒤에 콜론(:)이 누락.
#해결: if 문의 조건식 끝에 콜론을 추가.

# 정정 코드
if True:
    pass
```
#### 📌 기억해야 할 사항
- #### 문법 검사: 코드를 작성할 때는 파이썬의 문법 규칙을 정확히 따르는 것이 중요. 대부분의 개발 환경`(IDE)`은 `SyntaxError`를 미리 알려주기 때문에, 오류 메시지를 주의 깊게 확인하세요. 🛠️
- #### 괄호와 따옴표 확인: 괄호와 따옴표는 항상 쌍을 이루어야 함. 하나라도 누락되거나 불일치하면 `SyntaxError`가 발생. 🖇️
- #### 콜론 사용: 파이썬에서는 조건문, 반복문, 함수 정의 등 블록을 시작하기 전에 콜론(:)을 사용. 콜론을 빠뜨리지 않도록 주의. 🔍
- #### SyntaxError는 프로그래밍 초보자가 자주 마주치는 오류 중 하나. 이 오류들을 해결하는 방법을 배움으로써, 여러분의 디버깅 능력을 향상시킬 수 있다! 🌈
## NameError: 참조 없음 🔍❌
### NameError는 프로그램에서 선언되지 않은 변수나 함수, 혹은 다른 식별자를 참조하려고 할 때 발생하는 오류. 즉, 파이썬 인터프리터가 해당 이름을 알아볼 수 없을 때 이 오류가 발생.

### 📝 오류 예시
```python
a = 10
b = 15
print(c)
```
- #### 문제: 변수 c가 선언되지 않았으나, print 함수를 통해 c의 값을 출력하려고 시도.
- #### 해결: c를 선언하거나, 기존에 선언된 변수의 이름을 올바르게 사용해야 한다.
#### 🛠️ 정정 코드
```python
a = 10
b = 15
c = 20  # c 변수 선언
print(c)  # 이제 c 변수를 안전하게 참조할 수 있다.
```
### 📌 기억해야 할 사항
- #### 변수 선언 확인: 변수를 사용하기 전에 반드시 선언되어 있어야 한다. 변수 선언이란, 변수에 값을 할당하는 과정을 의미. 📝
#### 오타 조심: 변수나 함수의 이름을 잘못 입력한 경우 `NameError`가 발생할 수 있다. 오타가 없는지 주의 깊게 확인하자. 🔍
#### 스코프 이해: 파이썬에서 변수의 스코프(변수가 접근 가능한 범위)를 이해하는 것도 중요하다. 함수 내부에서 선언된 변수는 해당 함수 외부에서는 접근할 수 없다. 스코프 문제로 `NameError`가 발생할 수도 있습니다. 🚧
##### `NameError`는 코드를 작성하면서 가장 흔히 마주치는 오류 중 하나. 이 오류를 해결하는 방법을 배움으로써, 코드를 더 정확하고 효율적으로 작성하는 데 도움이 된다! 💡

## ZeroDivisionError: 0으로 나누기 🔢🚫
#### ZeroDivisionError는 숫자를 0으로 나누려고 시도할 때 발생하는 오류. 수학에서는 어떤 수를 0으로 나누는 것이 정의되지 않으며, 파이썬에서도 마찬가지로 이를 허용하지 않는다.

### 📝 오류 예시
```python
print(100 / 0)
```
- ### 문제: 숫자 100을 0으로 나누려고 시도.
- #### 오류 메시지: `ZeroDivisionError: division by zero`
- #### 해결: 0으로 나누기 시도를 피하거나, 예외 처리를 통해 이러한 상황을 적절히 처리해야 함.
### 🛠️ 예외 처리를 통한 해결 방법
```python
try:
    print(100 / 0)
except ZeroDivisionError:
    print("0으로 나눌 수 없습니다!")
```   
#### 이 코드는 `try` 블록 안에서 0으로 나누기를 시도하고, `ZeroDivisionError`가 발생하면 `except` 블록이 실행되어 사용자에게 "0으로 나눌 수 없습니다!"라는 메시지를 출력.
### 📌 기억해야 할 사항
- #### 0으로 나누기 금지: 프로그램 내에서 0으로 나누는 연산은 항상 피해야 하고. 필요한 경우, 분모가 0인지 먼저 검사하는 로직을 추가할 수 있다. 🚨
- #### 예외 처리 사용: `try`와 `except` 구문을 사용하여 `ZeroDivisionError`를 처리하면, 프로그램이 예외 상황에서도 안정적으로 동작하도록 할 수 있다. 💪

## IndexError: 인덱스 범위 초과 📊🔍
#### `IndexError`는 리스트, 튜플, 문자열 등의 시퀀스 타입에서 범위를 벗어난 인덱스를 사용하려고 할 때 발생하는 오류. 즉, 시퀀스의 길이보다 크거나 같은 인덱스를 사용하려고 하면 이 오류가 발생.

### 📝 오류 예시
```python
x = [50, 70, 90]
print(x[1])  # 이것은 정상적으로 작동합니다. 출력: 70
print(x[4])  # IndexError 발생! 리스트 x는 인덱스 4를 가지고 있지 않다.
```

- #### 문제: 리스트 x에는 3개의 요소가 있으므로, 유효한 인덱스는 0, 1, 2입니다. x[4]는 존재하지 않는 인덱스에 접근하려고 시도.
- #### 오류 메시지: `IndexError: list index out of range`
### 🛠️ .pop() 메소드와 IndexError
#### .pop() 메소드는 리스트의 마지막 요소를 제거하고 반환. 리스트가 비어있을 때 .pop()을 호출하면 `IndexError`가 발생.

```python
print(x.pop())  # 90, 정상적으로 작동합니다.
print(x.pop())  # 70, 정상적으로 작동합니다.
print(x.pop())  # 50, 정상적으로 작동합니다.
print(x.pop())  # IndexError 발생! 더 이상 제거할 요소가 없다.
```
### 📌 예외 처리를 통한 해결 방법
```python
try:
    print(x.pop())
except IndexError:
    print("리스트에서 더 이상 제거할 요소가 없습니다!")
```
#### 위 코드는 .pop() 메소드를 사용하여 리스트에서 요소를 제거하려고 시도하고, 만약 `IndexError`가 발생하면 사용자에게 메시지를 출력.
### 기억해야 할 사항
- #### 인덱스 검사: 시퀀스에서 요소에 접근하기 전에, 해당 인덱스가 시퀀스의 범위 안에 있는지 확인하는 것이 좋다.
- #### 예외 처리 사용: `try`와 `except` 구문을 사용하여 `IndexError`를 처리하면, 프로그램이 예외 상황에서도 안정적으로 동작하도록 할 수 있다.

## KeyError: 키가 딕셔너리에 없음 🔑❌
#### KeyError는 주어진 키가 딕셔너리에 없을 때 발생하는 오류. 딕셔너리는 키-값 쌍으로 데이터를 저장하는 데이터 타입이며, 각 키는 해당 딕셔너리 내에서 유일해야 한다.

### 📝 오류 예시
```python
dic = {'name': 'Lee', 'Age': 41, 'City': 'Busan'}
print(dic['hobby'])  # KeyError 발생!
```
- #### 문제: 'hobby'라는 키가 딕셔너리 dic에 존재하지 않다. 그럼에도 불구하고 해당 키로 접근하려고 하기 때문에 KeyError가 발생.
- #### 오류 메시지: KeyError: 'hobby'
### .get() 메소드를 사용한 안전한 접근
- #### `dic.get('hobby')`는 `'hobby'` 키가 딕셔너리에 없을 경우 None을 반환. 이 메소드는 존재하지 않는 키로 접근할 때 `KeyError`를 방지하고자 할 때 유용.

```python
print(dic.get('hobby'))  # None 출력, 오류 발생하지 않음
```
#### .get() 메소드는 딕셔너리에서 키가 존재하지 않는 경우에도 프로그램이 중단되지 않도록 도와준다. 또한, `.get()`메소드는 두 번째 매개변수로 존재하지 않는 키에 대한 기본값을 설정할 수 있다.
```python
print(dic.get('hobby', 'No hobby found'))  # 'No hobby found' 출력
```
#### 📌 기억해야 할 사항
- #### 존재 확인: 딕셔너리에서 키로 접근하기 전에, 해당 키가 존재하는지 확인하는 것이 좋다.
- #### .get() 사용: 존재하지 않는 키로 안전하게 접근하고 싶을 때는 .get() 메소드를 사용하자.
- #### 예외 처리: 필요한 경우, `try-except` 블록을 사용하여 `KeyError`를 명시적으로 처리할 수도 있다.

#### EAFP(Easier to Ask for Forgiveness than Permission)는 파이썬 프로그래밍에서 권장되는 예외 처리 방식 중 하나. 🛡️ 이 접근 방식은 "허락을 구하기보다는 용서를 구하는 것이 쉽다"는 격언에서 유래했으며, 코드 실행을 시도하고 실행 중에 예외가 발생할 경우 그 예외를 처리하는 것을 의미.

### EAFP의 핵심 원칙 🌟
- #### 예외 없는 실행 가정: 코드를 작성할 때 특정 조건이 사전에 만족된다고 가정하고 진행한다. 예를 들어, 파일이 존재하거나, 딕셔너리에 특정 키가 있거나, 리스트에 충분한 요소가 있다고 가정한다.
- #### 런타임 예외 처리: 코드 실행 도중 발생할 수 있는 예외를 try-except 블록을 사용하여 처리한다. 이는 코드 실행을 먼저 시도하고, 문제가 발생할 경우 그때 예외 처리를 하는 방식이다.
### EAFP 예제 코드 📝
#### LBYL (Look Before You Leap) 방식
##### 이 방식은 "점프하기 전에 보라"는 의미로, 특정 작업을 시도하기 전에 모든 전제 조건을 검사한다. 이는 EAFP와 대비되는 개념이다.

```python
my_dict = {"a": 1, "b": 2}
key = "c"

# LBYL 접근 방식
if key in my_dict:
    print(my_dict[key])
else:
    print("Key does not exist.")

# EAFP 방식

my_dict = {"a": 1, "b": 2}
key = "c"

# EAFP 접근 방식
try:
    print(my_dict[key])
except KeyError:
    print("Key does not exist.")

```
#### EAFP 방식은 코드가 실행될 환경을 미리 검사하는 대신, 작업을 시도하고 실패할 경우에 대비하여 예외 처리를 한다.

#### EAFP의 장점 ✨
- #### 유연성과 신뢰성: EAFP 방식은 예상치 못한 상황에서 프로그램의 안정성을 높이고, 예외 상황을 명확하게 처리할 수 있게 해준다.
- #### 성능 향상: 모든 조건을 미리 검사하는 LBYL 방식에 비해, EAFP 방식은 필요한 검사를 최소화함으로써 종종 성능상의 이점을 제공한다.
- #### 파이썬스러움: 파이썬 커뮤니티에서는 EAFP 방식을 파이썬스러운 코드 작성 방식으로 권장하며, 이는 파이썬의 동적인 특성과 잘 어울린다.
#####  EAFP 방식은 코드를 더 간결하고 파이썬스럽게 만들며, 예외 상황을 효과적으로 처리할 수 있도록 도와준다. 따라서 예외 처리를 구현할 때 EAFP 방식을 고려해 보는 것이 좋다. 🚀

## AttributeError: 잘못된 속성 사용 예외 🛠️🔍
#### 예를 들어, 파이썬의 표준 라이브러리 중 하나인 `time` 모듈에서 존재하지 않는 함수를 호출하려고 할 때 `AttributeError`가 발생합니다.

### 📝 예시 코드
```python
import time
print(time.time2())  # AttributeError 발생
```
- ### 문제: time 모듈에는 time2()라는 함수가 존재하지 않습니다.
- #### 오류 메시지: `AttributeError: module 'time' has no attribute 'time2'`
### 🛡️ 해결 방법
- #### 문서 확인: 사용하려는 모듈이나 클래스의 공식 문서를 확인하여, 호출하려는 속성이나 메서드가 실제로 존재하는지 확인.
- #### 오타 확인: 속성이나 메서드의 이름을 잘못 입력했을 수도 있으니, 오타가 없는지 다시 한번 검토해 보자.
- #### 자동 완성 기능 사용: 많은 코드 편집기와 `IDE`는 자동 완성 기능을 제공. 이를 활용하면 오타를 줄이고, 사용 가능한 속성을 쉽게 확인할 수 있다.
### 📌 기억해야 할 사항
#### AttributeError는 오타나 잘못된 속성 이름으로 인해 자주 발생. 메서드나 속성 이름을 정확히 입력했는지 확인하자.
#### 만약 자주 사용하는 라이브러리나 모듈이라면, 해당 객체가 제공하는 속성이나 메서드를 기억하거나 자주 참조하는 문서를 가까이 두는 것이 좋다.

## ValueError: 잘못된 값 예외 🚫🔢
#### 리스트에서 remove() 메서드는 리스트 내에 있는 특정 값을 제거. 만약 제거하고자 하는 값이 리스트 내에 없을 경우, ValueError가 발생.

### 📝 예시 코드
```python
x = [10, 50, 90]
x.remove(50)  # 50은 리스트에 존재하므로 정상적으로 제거.
print(x)  # [10, 90] 출력
x.remove(200)  # 200은 리스트에 존재하지 않으므로 ValueError 발생
```
- #### 문제: 리스트 x에서 200을 제거하려고 하지만, 200은 리스트 x에 존재하지 않습니다.
- #### 오류 메시지: ValueError: list.remove(x): x not in list
### 🛡️ 예외 처리를 통한 해결 방법
#### `try-except` 블록을 사용하여 `ValueError`를 처리할 수 있다. 이렇게 하면 프로그램이 예외로 인해 비정상적으로 종료되는 것을 방지할 수 있다.

```python
try:
    x.remove(200)
except ValueError:
    print("리스트에 200이 존재하지 않습니다.")
```
### 📌 기억해야 할 사항
- #### 값의 존재 확인: 리스트에서 값을 제거하기 전에, 그 값이 리스트에 존재하는지 확인하려면 `if` 문을 사용할 수 있다.
- #### 예외 처리: `try-except` 블록을 사용하여 `ValueError`를 포함한 다양한 예외를 처리하는 것은 프로그램을 더 안정적으로 만들고 사용자에게 더 명확한 피드백을 제공하는 좋은 방법이다.
  
## FileNotFoundError: 파일을 찾을 수 없음 🚫📄
#### 파이썬에서 파일을 다룰 때, 해당 파일이 지정된 경로에 존재하지 않는 경우 FileNotFoundError가 발생.

### 📝 예시 코드
```python
f = open('test.txt')  # 'test.txt' 파일을 열려고 시도.
```
- #### 문제: 현재 작업 디렉토리에 test.txt 파일이 존재하지 않습니다.
- #### 오류 메시지: FileNotFoundError: [Errno 2] No such file or directory: 'test.txt'
### 🛡️ 예외 처리를 통한 해결 방법
#### try-except 블록을 사용하여 FileNotFoundError를 처리할 수 있다. 이렇게 하면 파일이 존재하지 않는 상황에서도 프로그램이 안정적으로 동작하게 할 수 있다.

```python
try:
    f = open('test.txt')
except FileNotFoundError:
    print("'test.txt' 파일을 찾을 수 없습니다.")
```
### 📌 기억해야 할 사항
- #### 경로 확인: 파일을 열기 전에 파일의 경로가 정확한지 확인. 파일 경로에 오타가 없는지, 파일이 예상한 위치에 있는지 검토해야 한다.
- #### 예외 처리: 파일 작업을 수행할 때는 항상 `FileNotFoundError`를 포함한 예외 상황을 고려해야 한다. 이를 위해 `try-except` 구문을 사용할 수 있다.
- #### 파일 생성: 특정 상황에서는 파일이 존재하지 않을 때 자동으로 파일을 생성하고 싶을 수 있다. 이 경우 open 함수에 'w'나 'a' 모드를 사용하여 파일이 없으면 새로 생성하도록 할 수 있다.
```python
f = open('new_file.txt', 'w')  # 'new_file.txt'가 없으면 새로 생성.
f.write('Hello, world!')
f.close()
```
#### FileNotFoundError는 파일 작업을 할 때 흔히 마주치는 오류 중 하나. 이러한 예외를 적절히 처리함으로써, 프로그램의 안정성을 높이고 사용자에게 보다 친절한 피드백을 제공할 수 있다. 🚀

## TypeError: 자료형에 맞지 않는 연산 📊❌
#### TypeError 예시를 살펴보면, 리스트(x), 튜플(y), 문자열(z) 간의 더하기 연산을 시도하는 코드에서 이 오류가 발생.

### 📝 예시 코드와 오류
```python
x = [1, 2]
y = (1, 2)
z = 'test'

# 리스트와 튜플의 더하기 시도 -> TypeError
print(x + y)

# 리스트와 문자열의 더하기 시도 -> TypeError
print(x + z)

# 튜플과 문자열의 더하기 시도 -> TypeError
print(y + z)
```
- #### 문제: 파이썬에서는 리스트와 튜플, 리스트와 문자열, 튜플과 문자열을 직접 더하는 연산을 지원하지 않는다.
- #### 오류 메시지: `TypeError: can only concatenate list (not "tuple") to list`와 같은 메시지로, 타입이 맞지 않아 연산을 수행할 수 없음을 나타낸다.
### 🛡️ 오류 해결 방법
### 서로 다른 타입의 객체를 연결하려면, 타입을 일치시킨 후 연산을 수행해야 한다. 예를 들어, 튜플을 리스트로 변환하거나, 문자열을 리스트로 변환하는 등의 작업이 필요하다.
```python
# 튜플을 리스트로 변환하여 리스트와 연산
print(x + list(y))

# 문자열을 리스트로 변환하려면, 문자열을 문자의 리스트로 변환해야 한다.
# 예: 'test' -> ['t', 'e', 's', 't']
print(x + list(z))
```
- #### 주의: 'test' 문자열을 list(z)로 변환하면 ['t', 'e', 's', 't']가 되므로, 이를 x 리스트와 더하면 [1, 2, 't', 'e', 's', 't']가 된다.
### 📌 기억해야 할 사항
- #### 타입 일치: 서로 다른 타입의 객체를 연산하기 전에, 타입을 일치시키는 것이 중요하다.
- #### 예외 처리: 특정 연산을 수행할 때 `TypeError`를 예상할 수 있다면, `try-except` 블록으로 이를 처리할 수 있다.
- #### 명확한 타입 변환: 연산을 수행하기 전에, 명확하게 타입 변환을 수행해야 한다. 타입 변환은 예상치 못한 결과를 초래할 수 있으므로 주의가 필요하다.


## 예외 처리의 기본 구조 🛑
### 🔄 try 블록
- #### 용도: 에러가 발생할 가능성이 있는 코드를 실행. 예외가 발생하면 try 블록은 즉시 실행을 중단하고 해당 예외를 처리할 except 블록으로 이동.
### 🛑 except 블록
- #### 용도: 특정 예외를 처리. 여러 개의 except 블록을 사용하여 다양한 예외를 처리할 수 있다.
- #### 구조: except 에러명 as 변수: 형식으로 사용하며, 예외에 대한 정보를 변수에 담을 수 있다.
### 🌈 else 블록
- #### 용도: try 블록 내의 코드에서 예외가 발생하지 않았을 경우 실행. 즉, 모든 작업이 성공적으로 완료되었을 때 실행할 코드를 여기에 넣는다.
### 🏁 finally 블록
- ### 용도: 예외 발생 여부와 상관없이 항상 실행되는 코드를 정의. 주로 자원 해제나 정리 작업에 사용된다.
### 예제 코드
```python
try:
    # 에러가 발생할 가능성이 있는 코드
    result = 10 / 0
except ZeroDivisionError as e:
    # ZeroDivisionError가 발생했을 때 실행
    print(f"에러 발생: {e}")
except ValueError as e:
    # ValueError가 발생했을 때 실행
    print(f"값 에러 발생: {e}")
else:
    # try 블록에서 에러가 없을 경우 실행
    print("에러 없이 성공적으로 실행되었습니다.")
finally:
    # 항상 실행
    print("예외 처리 완료")
```
#### 이 코드에서는 10 / 0으로 ZeroDivisionError가 발생하여, 해당 except 블록이 실행됩니다. 그 후, finally 블록의 코드가 실행.
### 📌 기억해야 할 사항
#### `try` 블록은 필수적으로 사용해야 하며, `except, else, finally` 블록은 필요에 따라 선택적으로 사용할 수 있다.
#### 여러 예외를 처리할 때는 가장 구체적인 예외부터 처리하도록 `except` 블록을 정렬하는 것이 좋다.
#### finally 블록은 프로그램이 중단되거나 함수에서`return`문을 만나도 실행된다.

### 예제 코드와 설명 📝
#### 🛠 예제1: 예외 처리를 사용한 요소 검색
```python
name = ['Kim', 'Lee', 'Park']

try:
    z = 'Kim'  # 'Cho'
    x = name.index(z)
    print('{} Found it! {} in name'.format(z, x + 1))
except ValueError:
    print('Not found it! - Occurred ValueError!')
else:
    print('Ok! else.')
```
- #### try 블록: 변수 z에 'Kim' 값을 할당하고, name 리스트에서 z의 인덱스를 찾으려고 한다. 'Kim'은 리스트에 존재하므로 index 메서드는 'Kim'의 인덱스를 반환하고, 'Kim Found it! 1 in name'이 출력된다.
- #### except ValueError 블록: 만약 z의 값으로 'Cho'를 사용했다면, name 리스트에는 'Cho'가 존재하지 않기 때문에 ValueError가 발생. 이 경우, except 블록이 실행되어 'Not found it! - Occurred ValueError!'가 출력.
- #### else 블록: try 블록 내의 코드가 예외 없이 성공적으로 실행됐을 때 실행됩니다. 위의 코드에서는 'Ok! else.'가 출력.
### 🌈 else 블록의 사용
#### else 블록은 try 블록에서 예외가 발생하지 않았을 때 실행되는 코드를 포함. 이 예제에서는 try 블록이 성공적으로 실행되면, 즉, z가 리스트 name 내에 존재하면, 'Ok! else.' 메시지를 출력.
### 📌 기억해야 할 사항
#### 예외 처리를 사용하면 프로그램의 안정성을 높일 수 있다. 예상치 못한 상황에서 프로그램이 중단되지 않도록 하고, 적절한 예외 메시지를 통해 사용자에게 유용한 피드백을 제공할 수 있다.
#### try-except 블록은 예상할 수 있는 오류를 처리하는 데 사용되며, else 블록은 예외가 발생하지 않았을 때 추가적인 작업을 수행하는 데 사용.

### 예제2: 모든 예외 잡기
```python
name = ['Kim', 'Lee', 'Park']

try:
    z = 'Cho'  # 'Cho'는 리스트 name에 없으므로 ValueError가 발생.
    x = name.index(z)
    print('{} Found it! {} in name'.format(z, x + 1))
except:
    print('Not found it! - Occurred ValueError!')
else:
    print('Ok! else.')
```
#### 작동 방식
- #### try 블록: 변수 z에 'Cho'가 할당되고, name 리스트에서 z의 인덱스를 찾으려고 한다. 하지만 'Cho'는 리스트에 존재하지 않으므로, name.index(z)는 ValueError를 발생시킨다.
- ####  except 블록: 구체적인 예외 유형을 명시하지 않았기 때문에, try 블록에서 발생하는 모든 예외를 잡아낸다. 따라서 'Not found it! - Occurred ValueError!' 메시지가 출력. 하지만 실제 메시지에서는 ValueError만 발생할 것이라 가정하고 있다.
- ####  else 블록: try 블록에서 예외가 발생하지 않았을 때 실행되어야 하지만, 이 경우에는 try 블록에서 예외가 발생했으므로 실행되지 않는다.
### 📌 주의사항
#### 가능하면 except 블록에서는 구체적인 예외 유형을 명시하는 것이 좋다. 이렇게 함으로써 예상치 못한 다른 유형의 예외가 발생했을 때, 그것을 놓치지 않고 적절하게 처리할 수 있다.
#### 'Not found it! - Occurred ValueError!' 메시지는 ValueError를 가정하고 있지만, except 블록이 모든 예외를 잡기 때문에, 실제로는 다른 종류의 예외가 발생해도 동일한 메시지가 출력된다.

### 예제3: 예외 정보 출력 및 마무리 작업
```python
name = ['Kim', 'Lee', 'Park']

try:
    z = 'Cho'  # 'Cho'는 리스트 name에 없으므로 ValueError가 발생.
    x = name.index(z)
    print('{} Found it! {} in name'.format(z, x + 1))
except Exception as e:
    print(e)  # 발생한 예외의 정보를 출력.
    print('Not found it! - Occurred ValueError!')
else:
    print('Ok! else.')
finally:
    print('Ok! finally')
```
#### 작동 방식
- #### try 블록: 'Cho'를 리스트 name에서 찾으려 시도. name 리스트에 'Cho'가 없으므로 ValueError가 발생.
- #### except Exception as e 블록: 발생한 ValueError를 잡아내고, 예외의 메시지를 출력. 그 후 "Not found it! - Occurred ValueError!" 메시지를 출력. 이때 e는 발생한 예외 객체를 참조.
- #### else 블록: try 블록 내의 코드에서 예외가 발생하지 않았을 때 실행. 이 경우에는 try 블록에서 예외가 발생했으므로, 이 블록은 실행되지 않는다.
- #### finally 블록: 예외 발생 여부와 관계없이 항상 실행. 여기서는 "Ok! finally" 메시지를 출력. 이 블록은 주로 자원을 해제하거나 필요한 마무리 작업을 수행하는 데 사용.
### 📌 주의사항
- #### except Exception as e를 사용하면 모든 예외를 잡을 수 있지만, 가능한 한 예외를 구체적으로 명시하는 것이 좋다. 예외의 종류에 따라 다른 처리를 할 수 있기 때문.
- #### finally 블록은 예외 처리 과정에서 자원을 정리하거나 필수적인 후처리를 수행해야 할 때 유용. 예외 발생 여부와 상관없이 실행되므로, 프로그램의 안정성을 높이는 데 중요한 역할을 한다.

### 예제4: raise를 이용한 예외 발생
```python
try:
    a = 'Park'
    if a == 'Park':
        print('OK! Pass!')
    else:
        raise ValueError  # 조건이 만족하지 않을 때 ValueError 예외를 직접 발생시킨다.
except ValueError:
    print('Occurred! Exception!')  # 발생한 ValueError를 처리.
else:
    print('Ok! else!')  # try 블록이 예외 없이 성공적으로 완료되었을 때 실행.
```
### 작동 방식
- #### try 블록: 변수 `a`에 `'Park'`이 할당되고, 이어지는 `if` 조건문에서 `a`가 `'Park'`인지 확인. 조건문이 참이므로 `"OK! Pass!"`가 출력되고, `else` 블록은 실행되지 않는다.
- #### raise ValueError: 이 코드는 조건이 거짓일 경우 실행될 예정이었으나, 실제로는 `if` 조건문이 참이므로 실행되지 않는다. 하지만, 만약 조건이 거짓이었다면 `ValueError` 예외가 발생했을 것이다.
- #### except ValueError 블록: 만약 `ValueError` 예외가 발생했다면, 이 블록에서 그 예외를 처리하며 `"Occurred! Exception!"` 메시지를 출력.
- #### else 블록: `try` 블록 내의 코드가 예외를 발생시키지 않고 성공적으로 완료되었기 때문에, `"Ok! else!"`가 출력.
### 📌 주의사항
- #### `raise` 키워드는 프로그램에서 예외 상황을 명시적으로 지정하고 싶을 때 유용하게 사용. 하지만, 예외를 발생시킨 후 적절히 처리하는 로직이 함께 구현되어야 한다.
- #### 예외를 발생시키는 것은 프로그램의 흐름을 제어하는 강력한 방법이 될 수 있지만, 남용하면 코드의 가독성과 유지보수성이 떨어질 수 있으므로 주의해서 사용해야 한다.


# 파이썬 내장(Built-in) 함수 실습 📘


### abs() 함수의 사용법 🛠
#### abs() 함수는 파이썬에서 제공하는 내장 함수 중 하나로, 주어진 숫자의 절대값을 반환. 📏✨
#### 구문: abs(x)
- #### 매개변수: x는 숫자입니다(정수, 실수, 복소수).
- #### 반환값: x의 절대값. x가 복소수일 경우, 그 크기(`magnitude`)를 반환.
#### 예제 코드
```python
print(abs(-3))  # 출력: 3
```
#### 이 예제에서 abs() 함수에 -3을 인자로 넣었을 때, 3을 반환합니다. -3의 절대값이 3이기 때문.
#### 추가 정보
#### abs() 함수는 음수를 양수로 변환하는 가장 간단한 방법. 이 함수는 금융, 과학 계산, 데이터 분석 등 다양한 분야에서 에러나 차이의 크기를 계산할 때 유용하게 사용.
#### 복소수에 abs()를 사용하면, 해당 복소수의 크기(복소 평면에서 원점으로부터의 거리)를 반환. 예를 들어, 복소수 3 + 4j의 크기는 5.
```python
print(abs(3 + 4j))  # 출력: 5.0
```
#### abs() 함수는 파이썬 프로그래밍에서 자주 사용되는 기본적이면서도 중요한 함수 중 하나로, 코드 내에서 수치 데이터의 절대값을 쉽게 구할 수 있게 도와줌.



### all() 함수 🔄✅
#### all()과 any() 함수는 파이썬의 내장 함수로, iterable 객체(리스트, 튜플, 딕셔너리 등) 내의 모든 요소를 검사하여 참 또는 거짓을 반환. 이들 함수는 조건문 내에서 또는 복잡한 조건을 간결하게 표현할 때 유용하게 사용. 🔄✅

- ### 구문: all(iterable)
- #### 용도: 주어진 iterable의 모든 요소가 참(True)인 경우에만 True를 반환합니다. iterable이 비어 있으면 True를 반환.
- #### 동작: '논리적 AND' 연산과 유사하며, 주어진 모든 값이 참이어야 합니다.
```python
print(all([1, 2, 3]))  # 출력: True
```
#### 이 예제에서 [1, 2, 3] 리스트의 모든 요소는 Boolean 평가 시 True로 간주되므로, all([1, 2, 3])은 True를 반환.
### any() 함수 🔄✅
- #### 구문: any(iterable)
- #### 용도: 주어진 iterable 내에서 참(True)인 요소가 하나라도 있으면 True를 반환. 모든 요소가 거짓(False)이거나, iterable이 비어 있으면 False를 반환.
- #### 동작: '논리적 OR' 연산과 유사하며, 주어진 값 중 하나라도 참이면 된다.
```python
print(any([1, 2, 0]))  # 출력: True
```
#### [1, 2, 0] 리스트에서 0을 제외한 모든 요소는 Boolean 평가 시 True. 따라서, any([1, 2, 0])은 True를 반환.
#### 📌 기억해야 할 사항
#### all() 함수는 iterable 내의 모든 요소가 참이어야 True를 반환하는 반면, any() 함수는 하나의 요소라도 참이면 True를 반환.
#### 이러한 함수들은 조건이 여러 개 있을 때 코드를 간결하게 만들어주며, 특히 데이터의 유효성 검사나 조건 충족 여부를 확인할 때 유용.
#### all()과 any() 함수를 사용함으로써 복잡한 조건문을 간결하게 표현하고, 코드의 가독성을 향상시킬 수 있다. 🚀

### hr() 함수: 아스키 코드를 문자로 변환 🔄
#### 구문: chr(i)
- #### 매개변수: i는 아스키 코드 값입니다(0에서 1,114,111까지의 정수).
- #### 반환값: 해당 아스키 코드에 해당하는 문자를 반환합니다.
```python
print(chr(67))  # 출력: C
chr(67) # 은 아스키 코드 값 67에 해당하는 문자 'C'를 반환.
ord() # 함수: 문자를 아스키 코드로 변환 🔡➡️🔢
```
#### 구문: ord(c)
- #### 매개변수: c는 아스키 코드로 변환하고자 하는 문자입니다.
- #### 반환값: 주어진 문자에 해당하는 아스키 코드 값을 반환합니다.
```python
print(ord('C'))  # 출력: 67
ord('C') #는 문자 'C'에 해당하는 아스키 코드 값 67을 반환합니다.
chr() # 함수와 ord() 함수는 문자와 아스키 코드 간의 변환을 위해 사용되며, 문자 데이터를 처리할 때 유용하게 사용.
```
 #### 이러한 함수들은 파이썬에서 문자와 관련된 다양한 작업을 할 때 기본적으로 알고 있어야 하는 함수들 중 하나. 🚀


### enumerate() 함수 사용법
 #### enumerate() 함수는 파이썬의 내장 함수로, 순회 가능한(iterable) 객체들을 인덱스와 함께 순회할 수 있게 도와준다. 이 함수는 순회하는 객체의 인덱스와 값을 튜플 형태로 반환. 🔄🔢
#### enumerate() 함수를 사용하면 반복문에서 객체의 인덱스와 값을 동시에 쉽게 얻을 수 있다. 이는 특히 리스트나 문자열 같은 순서가 있는 데이터를 다룰 때 유용.

### 예제 코드
```python
for i, name in enumerate(['abc', 'bcd', 'efg']):
    print(i, name)
enumerate(['abc', 'bcd', 'efg']):  # 리스트의 각 요소와 그 인덱스를 튜플로 묶어 반환.
```
- #### 반복 실행: 반복문을 통해 반환된 튜플의 첫 번째 요소를 i(인덱스), 두 번째 요소를 name(값)으로 받아서 출력.
##### 출력 결과
```py
0 abc
1 bcd
2 efg
```
- #### 리스트의 첫 번째 요소 'abc'는 인덱스 0에, 두 번째 요소 'bcd'는 인덱스 1에, 그리고 세 번째 요소 'efg'는 인덱스 2에 위치. 이처럼 enumerate() 함수는 각 요소를 순회하면서 인덱스와 값을 함께 처리할 수 있도록 해준다.
#### 📌 기억해야 할 사항
#### enumerate() 함수는 기본적으로 0부터 인덱싱을 시작. 시작 인덱스를 변경하고 싶다면, enumerate(iterable, start=1)과 같이 start 매개변수에 원하는 시작 인덱스를 지정할 수 있다.
#### 이 함수는 리스트, 튜플, 문자열 등 다양한 순회 가능한 객체와 함께 사용될 수 있다.


### filter() 함수 사용법
#### filter() 함수는 반복 가능한(iterable) 객체에서 특정 조건을 만족하는 요소만을 추출하여 새로운 이터레이터를 생성하는 파이썬의 내장 함수. 이 함수는 주로 데이터를 필터링할 때 사용되며, 함수와 반복 가능한 객체를 인자로 받는다. 🚿🔍
#### 구문: filter(function, iterable)
#### 매개변수:
#### function: 각 요소에 적용될 함수. 이 함수는 각 요소를 인자로 받아 True 또는 False를 반환해야 한다.
#### iterable: 필터링될 반복 가능한 객체(리스트, 튜플 등).
#### 반환값: 조건에 맞는 요소들로 이루어진 새로운 이터레이터.
### 예제 코드
```python
def conv_pos(x):
    return abs(x) > 2

print(list(filter(conv_pos, [1, -3, 2, 0, -5, 6])))
print(list(filter(lambda x: abs(x) > 2, [1, -3, 2, 0, -5, 6])))
```
#### 첫 번째 예제에서 conv_pos 함수는 절대값이 2보다 큰지를 평가하여 True 또는 False를 반환. filter() 함수는 이 평가 결과가 True인 요소만을 추출.
#### 두 번째 예제에서는 람다 함수를 사용하여 동일한 조건을 한 줄로 간결하게 표현하고 있다.
### 출력 결과
```css
[-3, -5, 6]
[-3, -5, 6]
```
#### 두 예제 모두 [1, -3, 2, 0, -5, 6] 리스트에서 절대값이 2보다 큰 요소인 [-3, -5, 6]을 추출하여 출력.
### 📌 기억해야 할 사항
- #### filter() 함수는 함수의 반환값이 True인 요소만을 추출. 따라서, 필터링 조건을 정확히 정의하는 함수를 제공해야 한다.
- ####  filter() 함수의 결과는 이터레이터(iterator)이므로, 리스트나 튜플 등으로 변환해야 요소를 확인할 수 있다. 이는 list() 또는 tuple() 함수를 사용하여 할 수 있다.
- ####  filter() 함수를 사용함으로써 데이터 집합에서 특정 조건을 만족하는 요소만을 간편하게 추출할 수 있다. 이는 데이터 처리와 분석 과정에서 매우 유용하게 사용된다. 🌟


### id() 함수의 사용
#### id() 함수는 파이썬의 내장 함수로, 주어진 객체의 "정체성(identity)"을 나타내는 고유한 정수를 반환. 이 정수는 객체의 메모리 주소를 기반으로 하며, 프로그램 실행 동안 객체에 대해 고유하게 유지. 🆔✨
- #### 구문: id(object)
- #### 매개변수: object는 아무 파이썬 객체나 될 수 있다.
- #### 반환값: 객체의 "정체성"을 나타내는 고유한 정수다.
### 예제 코드
```python
print(id(int(5)))
print(id(4))
```
- #### 첫 번째 줄에서 int(5)는 5라는 값을 가진 새로운 정수 객체를 생성하고, 그 객체의 메모리 주소를 나타내는 고유한 정수(정체성)를 반환.
- #### 두 번째 줄에서는 직접 4라는 정수의 정체성을 조회. 파이썬에서는 작은 정수들을 미리 생성해 놓고 재사용하기 때문에, 같은 값의 정수는 프로그램 실행 동안 같은 id를 갖게 된다.
### 출력 결과에 대한 이해
- #### 두 줄의 코드에서 반환된 id 값은 서로 다를 수 있다. 그 이유는 int(5)가 호출될 때마다 새로운 정수 객체가 생성되기 때문. 반면, 파이썬에서는 작은 정수(예: -5부터 256까지)에 대해 미리 생성해놓은 객체를 재사용하기 때문에, 이러한 값들은 프로그램 실행 동안 동일한 id 값을 가진다.

### 📌 기억해야 할 사항
#### id() 함수를 사용하여 두 객체가 실제로 같은 객체인지(즉, 메모리상 동일한 위치에 있는지) 확인할 수 있다.
#### 파이썬에서 변수는 단지 이름일 뿐이며, id() 함수는 변수가 참조하는 객체의 고유한 정체성을 확인하는 데 사용된다.
#### 객체의 값이 같다고 해서 id() 값이 반드시 같은 것은 아니다. 값이 같은 두 개의 독립적인 객체는 서로 다른 메모리 주소를 가질 수 있다.
#### id() 함수는 디버깅이나 객체의 정체성을 확인할 때 유용하게 사용될 수 있다. 🚀

### len() 함수 사용법
#### len() 함수는 파이썬의 내장 함수로, 주어진 컨테이너(예: 문자열, 리스트, 튜플, 딕셔너리 등)의 요소 개수를 반환. 이 함수는 컨테이너에 포함된 요소의 "길이"를 알고 싶을 때 매우 유용하게 사용. 📏✨
- #### 구문: len(s)
- #### 매개변수: s는 길이(요소의 개수)를 측정할 수 있는 컨테이너.
- #### 반환값: 컨테이너 s에 포함된 요소의 개수(길이)를 나타내는 정수.
### 예제 코드
```python
print(len('abcdefg'))
print(len([1, 2, 3, 4, 5, 6, 7]))
```
- ####  첫 번째 줄에서는 문자열 'abcdefg'의 길이를 측정. 이 문자열에는 7개의 문자가 있으므로, len('abcdefg')는 7을 반환.
- ####  두 번째 줄에서는 리스트 [1, 2, 3, 4, 5, 6, 7]의 길이를 측정. 이 리스트에는 7개의 요소가 있으므로, len([1, 2, 3, 4, 5, 6, 7]) 역시 7을 반환.
### 📌 기억해야 할 사항
- ####  len() 함수는 문자열, 리스트, 튜플, 딕셔너리, 집합 등 다양한 컨테이너 타입의 길이를 측정할 수 있다.
- ####  컨테이너가 비어있는 경우(예: '', [], {} 등), len() 함수는 0을 반환.
- ####  len() 함수는 일반적으로 컨테이너 내부의 요소 개수를 빠르게 파악하는 데 사용.
- ####  len() 함수는 파이썬 프로그래밍에서 매우 자주 사용되며, 데이터 구조의 크기를 알고 싶을 때 필수적인 함수 중 하나. 🚀


### max() 함수: 최대값 찾기
#### max()와 min() 함수는 파이썬의 내장 함수로, 주어진 컬렉션(예: 리스트, 문자열, 튜플 등) 내에서 최대값이나 최소값을 찾아 반환. 이 함수들은 데이터 분석, 알고리즘 구현 등 다양한 상황에서 유용하게 사용. 🚀✨
- #### 구문: max(iterable, *[, default=obj, key=func]) 또는 max(arg1, arg2, *args[, key=func])
- ####  매개변수: iterable은 반복 가능한 컬렉션, arg1, arg2, *args는 비교 가능한 여러 인자들을 의미.
- ####  반환값: 컬렉션 내에서 가장 큰 값을 반환.
### min() 함수: 최소값 찾기
- #### 구문: min(iterable, *[, default=obj, key=func]) 또는 min(arg1, arg2, *args[, key=func])
- #### 매개변수: iterable은 반복 가능한 컬렉션, arg1, arg2, *args는 비교 가능한 여러 인자들을 의미.
- #### 반환값: 컬렉션 내에서 가장 작은 값을 반환.
### 예제 코드
```python
print(max([1, 2, 3]))  # 출력: 3
print(max('python study'))  # 출력: y (문자열에서 알파벳 순서상 가장 뒤에 위치하는 문자)
print(min([1, 2, 3]))  # 출력: 1
print(min('python study'))  # 출력:   (공백 문자가 가장 앞에 있음)
```
- #### 리스트 [1, 2, 3]에서 max() 함수는 가장 큰 값인 3을, min() 함수는 가장 작은 값인 1을 찾아 반환.
- #### 문자열 'python study'에서 max() 함수는 알파벳 순으로 가장 뒤에 위치하는 문자인 'y'를 반환. min() 함수는 공백 문자를 반환하는데, 이는 공백 문자가 알파벳보다 알파벳 순서상 앞에 위치하기 때문.
### 📌 기억해야 할 사항
- #### max()와 min() 함수는 비교 가능한 요소들 사이에서 작동합니다. 즉, 모든 요소들이 서로 비교될 수 있어야 한다.
- #### 문자열에서는 문자의 유니코드 값에 따라 비교가 이루어지며, 이는 대소문자를 포함한 알파벳 순서와 다를 수 있다.
- #### key 매개변수를 사용하면 요소를 비교하기 전에 각 요소에 적용할 함수를 지정할 수 있습니다. 이는 정렬 기준을 커스텀할 때 유용.
- #### max()와 min() 함수를 통해, 컬렉션 내의 요소들 중에서 최대값과 최소값을 쉽고 빠르게 찾을 수 있다.

### map() 함수 사용법
#### map() 함수는 파이썬의 내장 함수로, 주어진 함수를 반복 가능한(iterable) 객체의 각 요소에 적용한 후, 그 결과를 반환. 이를 통해 원본 리스트를 변환하거나 정보를 추출하는 등의 작업을 간단히 처리할 수 있다. 🔄🔧
- #### 구문: map(function, iterable, ...)
- #### 매개변수:
- ####  function: 각 요소에 적용될 함수.
- #### iterable: 하나 이상의 반복 가능한 객체.
- #### 반환값: function을 적용한 결과를 담은 맵 객체(map object). 보통 결과를 리스트나 다른 형태로 변환하여 사용.
### 예제 코드
```python
def conv_abs(x):
    return abs(x)

# 함수를 이용한 예제
print(list(map(conv_abs, [1, -3, 2, 0, -5, 6])))

# 람다 함수를 이용한 예제
print(list(map(lambda x: abs(x), [1, -3, 2, 0, -5, 6])))
```
- #### 첫 번째 예제에서는 conv_abs 함수를 정의하여, 이 함수를 map() 함수의 첫 번째 인자로 전달. conv_abs 함수는 주어진 숫자의 절대값을 반환. [1, -3, 2, 0, -5, 6] 리스트의 각 요소에 이 함수를 적용한 결과를 리스트로 변환하여 출력.
- #### 두 번째 예제에서는 람다 함수 lambda x: abs(x)를 사용하여 동일한 작업을 더 간결하게 수행. 람다 함수 역시 각 요소의 절대값을 계산하여 결과를 리스트로 변환하여 출력.
### 출력 결과
```csharp
[1, 3, 2, 0, 5, 6]
[1, 3, 2, 0, 5, 6]
```
### 📌 기억해야 할 사항
- #### map() 함수의 반환값은 맵 객체이므로, 대부분의 경우 리스트나 튜플과 같은 형태로 변환해서 사용.
- #### 람다 함수를 사용하면 map() 함수를 더 간결하게 작성할 수 있다. 람다 함수는 간단한 함수를 한 줄로 표현할 수 있게 해주는 파이썬의 기능.
- #### map() 함수는 데이터를 변환하거나 정보를 추출하는 작업을 간편하게 할 수 있도록 도와주며, 함수형 프로그래밍 스타일을 파이썬 코드에 적용하는 데 유용.


### pow() 함수 사용법
#### pow() 함수는 파이썬의 내장 함수로, 주어진 숫자의 거듭제곱 값을 계산합니다. 이 함수는 두 개의 필수 인자를 받으며, 세 번째 인자는 선택적. 🚀✨
- #### 구문: pow(base, exp[, mod])
- #### 매개변수:
- #### base: 거듭제곱의 밑.
- #### exp: 지수.
- #### mod (선택적): 모듈로 연산의 결과를 반환.
- #### 반환값: base의 exp 거듭제곱 값을 반환. mod가 주어진 경우, base의 exp 거듭제곱에 대한 모듈로 mod의 결과를 반환.
### 예제 코드
```python
print(pow(2, 10))
```
- #### 이 예제에서 pow(2, 10)은 2의 10 거듭제곱을 계산. 즉, 2를 10번 곱한 값인 1024를 반환.
### 출력 결과
```yaml
1024
```
### 📌 기억해야 할 사항
- #### pow() 함수는 간단한 수학 연산에서부터 복잡한 과학 계산에 이르기까지 다양한 상황에서 유용하게 사용.
- #### 파이썬에서 ** 연산자를 사용하여도 같은 거듭제곱 연산을 수행할 수 있습니다. 예를 들어, 2 ** 10도 1024를 반환.
- #### pow() 함수의 mod 매개변수는 특히 암호화와 같은 분야에서 유용하게 사용. 이는 큰 숫자의 거듭제곱을 효율적으로 계산할 수 있게 해줍니다.
- #### pow() 함수는 파이썬에서 수학적 연산을 수행할 때 기본적이면서도 강력한 도구 중 하나.


### range() 함수 사용법
#### range() 함수는 주어진 시작점, 끝점, 스텝(간격)을 기반으로 일련의 숫자를 포함하는 반복 가능한 객체를 생성. 이 함수는 주로 반복문에서 숫자 시퀀스를 생성하는 데 사용. 🔄🔢
- #### 구문: range(start, stop[, step])
- #### 매개변수:
- #### start: 시퀀스의 시작 숫자입니다. 이 매개변수를 포함.
- #### stop: 시퀀스의 끝 숫자입니다. 이 매개변수는 포함하지 않는다.
- #### step (선택적): 각 숫자 사이의 간격입니다. 기본값은 1.
- #### 반환값: 지정된 범위에 따른 숫자 시퀀스를 포함하는 range 객체.
### 예제 코드
```python
print(range(1, 10, 2))
print(list(range(1, 10, 2)))
print(list(range(0, -15, -1)))
```
- #### 첫 번째 줄은 range(1, 10, 2) 객체를 그대로 출력하려고 시도. range 객체 자체는 그 범위의 숫자들을 직접적으로 보여주지 않는다.
- #### 두 번째 줄에서는 list() 함수를 사용해 range 객체를 리스트로 변환하여 출력. 이렇게 하면 1부터 시작해 2씩 증가하는 숫자들이 10에 도달하기 직전까지 나열된다.
- #### 세 번째 줄에서는 0부터 시작하여 -1씩 감소하는 숫자들을 -15보다 작아지기 직전까지 나열한다.
### 출력 결과
```scss
range(1, 10, 2)
[1, 3, 5, 7, 9]
[0, -1, -2, -3, -4, -5, -6, -7, -8, -9, -10, -11, -12, -13, -14]
```
### 📌 기억해야 할 사항
- #### range() 함수가 반환하는 객체는 필요에 따라 다른 자료형(예: 리스트)으로 변환할 수 있다.
- #### range() 객체 자체는 메모리를 효율적으로 사용하기 위해 실제 숫자 리스트를 생성하지 않고, 필요할 때 숫자를 생성.
- #### range() 함수는 주로 for 루프에서 반복할 때 지정된 범위의 숫자를 순회하는 데 사용.
- #### range() 함수는 파이썬에서 반복문을 작성할 때 매우 자주 사용되며, 코드의 유연성과 가독성을 향상시키는 데 도움을 준다.



### round() 함수 사용법
#### round() 함수는 파이썬의 내장 함수로, 숫자를 반올림하여 주어진 자릿수까지의 값을 반환. 이 함수는 금융 계산, 데이터 처리, 사용자에게 보여줄 결과의 포맷팅 등 다양한 상황에서 유용하게 사용. 🔄💲
- #### 구문: round(number[, ndigits])
- #### 매개변수:
- #### number: 반올림할 숫자.
- #### ndigits (선택적): 반올림 후 표시할 소수점 이하 자릿수. 이 매개변수를 생략하면 가장 가까운 정수로 반올림.
- #### 반환값: 반올림된 값.
### 예제 코드
```python
print(round(6.5781, 2))
print(round(5.6))
```
- #### 첫 번째 줄에서 round(6.5781, 2)는 숫자 6.5781을 소수점 이하 두 번째 자리까지 반올림. 따라서 결과는 6.58.
- #### 두 번째 줄에서 round(5.6)은 숫자 5.6을 가장 가까운 정수로 반올림합니다. 결과는 6.
### 출력 결과
```py
6.58
6
```
### 📌 기억해야 할 사항
- #### round() 함수에서 ndigits가 양수인 경우, 해당 값은 소수점 이하 자릿수를 나타낸다. 음수인 경우 정수 부분의 반올림 위치를 나타낸다. 예를 들어, round(1234.5678, -2)는 1200을 반환.
- #### round() 함수는 "은행가 반올림"을 사용. 즉, 반올림할 숫자가 "5"일 경우, 가장 가까운 짝수로 반올림. 예를 들어, round(2.5)는 2, round(3.5)는 4를 반환.
- #### 파이썬에서 부동소수점 수는 항상 완벽한 정확도를 가지고 표현될 수 없기 때문에, 매우 정밀한 계산이 필요한 경우 decimal 모듈을 사용하는 것을 고려해야 할 수도 있다.
- #### round() 함수는 데이터를 사용자에게 보다 친절하게 표시하거나, 계산 과정에서 소수점 이하의 정밀도를 조절할 필요가 있을 때 매우 유용하게 사용.


### sorted() 함수 사용법
#### sorted() 함수는 파이썬의 내장 함수로, 주어진 반복 가능한 객체(iterable)의 모든 요소를 정렬한 새로운 리스트를 반환. 이 함수는 원본 데이터를 변경하지 않고, 정렬된 새로운 리스트를 만들어내는 특징이 있다. 🔄📈
- #### 구문: sorted(iterable, key=None, reverse=False)
- #### 매개변수:
- #### iterable: 정렬할 반복 가능한 객체.
- #### key (선택적): 정렬 목적으로 각 요소에 적용할 함수를 지정.
- #### reverse (선택적): False일 경우 오름차순, True일 경우 내림차순 정렬을 수행.
- #### 반환값: 정렬된 새로운 리스트.
### 예제 코드
```python
print(sorted([6, 7, 4, 3, 1, 2]))
a = sorted([6, 7, 4, 3, 1, 2])
print(a)
print(sorted(['p', 'y', 't', 'h', 'o', 'n']))
```
- #### 첫 번째와 두 번째 예제에서는 숫자로 이루어진 리스트 [6, 7, 4, 3, 1, 2]를 오름차순으로 정렬.
- #### 세 번째 예제에서는 문자들로 이루어진 리스트 ['p', 'y', 't', 'h', 'o', 'n']를 알파벳 순으로 오름차순 정렬.
### 출력 결과
```css
[1, 2, 3, 4, 6, 7]
[1, 2, 3, 4, 6, 7]
['h', 'n', 'o', 'p', 't', 'y']
```
### 📌 기억해야 할 사항
- #### sorted() 함수는 원본 리스트를 변경하지 않고, 정렬된 새로운 리스트를 생성하여 반환. 원본 데이터를 직접 변경하고 싶다면, 리스트 타입의 sort() 메소드를 사용할 수 있다.
- #### key 매개변수를 통해 정렬 기준을 커스터마이징할 수 있다. 예를 들어, 리스트의 객체가 복잡한 데이터 구조를 가지고 있다면, key 함수를 사용하여 정렬 기준을 명확히 할 수 있다.
- #### reverse 매개변수를 사용하여 오름차순 또는 내림차순 정렬을 선택할 수 있다.
- #### sorted() 함수는 파이썬에서 데이터를 정렬할 때 매우 자주 사용되며, 간단한 숫자나 문자열 리스트부터 복잡한 사용자 정의 객체까지 다양한 데이터에 대해 유연하게 정렬을 수행할 수 있다.


### sum() 함수 사용법
#### sum() 함수는 파이썬의 내장 함수로, 반복 가능한 객체(예: 리스트, 튜플, range 객체 등) 내의 모든 요소의 합을 반환. 이 함수는 수치 데이터의 총합을 계산할 때 유용하게 사용. 💰➕
- #### 구문: sum(iterable, start=0)
- #### 매개변수:
- #### iterable: 합계를 구할 반복 가능한 객체.
- #### start (선택적): 합계 계산의 시작값. 기본값은 0이며, 이 값은 합계에 더해진다.
- #### 반환값: iterable의 모든 요소와 start 값의 합계.
### 예제 코드
```python
print(sum([6, 7, 8, 9, 10]))
print(sum(range(1, 101)))
```
- #### 첫 번째 예제에서는 리스트 [6, 7, 8, 9, 10]의 요소들의 합을 계산. 이 리스트의 요소들을 모두 더한 값은 40.
- #### 두 번째 예제에서는 1부터 100까지의 숫자(1과 100 포함)를 포함하는 range 객체의 합을 계산. 이는 1부터 100까지의 자연수의 합, 즉 5050.
### 출력 결과
```yaml
40
5050
```
### 📌 기억해야 할 사항
- #### sum() 함수는 주로 수치형 데이터의 총합을 구할 때 사용. 다른 타입의 데이터에 대해서는 적절한 합계 연산이 정의되어 있지 않기 때문에, 예를 들어 문자열 리스트에는 사용할 수 없다.
- #### start 매개변수를 활용하면, 특정 값에서부터 합계 계산을 시작할 수 있다. 예를 들어, sum([1, 2, 3], 10)은 16을 반환.
- #### sum() 함수는 파이썬에서 데이터의 합계를 간단히 계산할 수 있는 효율적인 방법을 제공. 데이터 분석, 통계 계산, 또는 일상적인 프로그래밍 작업에서 매우 유용하게 사용.


### type() 함수 사용법
### type() 함수는 파이썬의 내장 함수로, 주어진 객체의 타입(자료형)을 반환. 이 함수는 개발과 디버깅 과정에서 객체의 타입을 확인할 때 유용하게 사용. 🕵️‍♂️🔍
- #### 구문: type(object)
- #### 매개변수:
- #### object: 타입을 확인하고자 하는 객체.
- #### 반환값: object의 타입을 나타내는 타입 객체.
### 예제 코드
```python
print(type(3))
print(type({}))
print(type(()))
print(type([]))
```
- #### 첫 번째 줄에서는 정수 3의 타입을 확인.
- #### 두 번째 줄에서는 빈 딕셔너리 {}의 타입을 확인.
- #### 세 번째 줄에서는 빈 튜플 ()의 타입을 확인.
- #### 네 번째 줄에서는 빈 리스트 []의 타입을 확인.
### 출력 결과
```py
<class 'int'>
<class 'dict'>
<class 'tuple'>
<class 'list'>
```
- #### type(3)은 <class 'int'>를 반환합니다. 이는 객체가 정수형임을 나타낸다.
- #### type({})은 <class 'dict'>를 반환합니다. 이는 객체가 딕셔너리형임을 나타낸다.
- #### type(())은 <class 'tuple'>를 반환합니다. 이는 객체가 튜플형임을 나타낸다.
- #### type([])은 <class 'list'>를 반환합니다. 이는 객체가 리스트형임을 나타낸다.
### 📌 기억해야 할 사항
- #### type() 함수는 객체의 타입을 확인하는 가장 기본적인 방법. 이 정보를 통해 객체가 어떤 연산과 메서드를 지원하는지 이해할 수 있다.
- #### 객체의 타입을 확인함으로써, 프로그램의 흐름을 제어하거나 타입에 따른 다른 처리를 수행할 수 있다.
- #### type() 함수는 파이썬에서 다양한 타입의 객체를 다룰 때 매우 기본적이면서도 중요한 도구. 객체의 타입을 알고 있으면, 해당 객체를 어떻게 처리할지 더 잘 결정할 수 있다.



### zip() 함수 사용법
#### zip() 함수는 파이썬의 내장 함수로, 여러 개의 반복 가능한(iterable) 객체들을 인자로 받아, 각 객체들의 요소를 튜플로 묶어서 반환. 이 함수는 여러 데이터 그룹을 동시에 루프 돌면서 처리할 때 매우 유용. 🔄🔗
- #### 구문: zip(*iterables)
- #### 매개변수: *iterables — 묶을 반복 가능한 객체들. 리스트, 튜플, 문자열 등이 될 수 있다.
- #### 반환값: 묶인 요소들의 이터레이터.
### 예제 코드
```python
print(list(zip([10, 20, 30], [40, 50, 777])))
print(type(list(zip([10, 20, 30], [40, 50, 777]))[0]))
```
- #### 첫 번째 줄에서 zip([10, 20, 30], [40, 50, 777])는 두 리스트의 요소들을 순서대로 묶어 튜플로 만들고, 그 결과를 리스트로 변환하여 출력.
- #### 두 번째 줄에서는 zip() 함수의 결과 중 첫 번째 요소의 타입을 확인.
### 출력 결과
```py
[(10, 40), (20, 50), (30, 777)]
<class 'tuple'>
```
- #### zip() 함수는 두 리스트 [10, 20, 30]과 [40, 50, 777]의 각 요소를 튜플로 묶어 [(10, 40), (20, 50), (30, 777)]와 같이 반환.
- #### 반환된 묶인 요소들은 튜플 형태로, 이를 리스트로 변환한 결과는 리스트 내에 튜플이 들어있는 형태.
- #### 두 번째 출력에서 확인할 수 있듯이, zip() 함수의 결과는 튜플들의 집합이며, 그 타입은 <class 'tuple'>.
### 📌 기억해야 할 사항
- #### zip() 함수는 입력된 반복 가능한 객체들 중 가장 짧은 길이를 가진 객체를 기준으로 묶음을 생성. 즉, 가장 짧은 객체의 길이만큼만 요소가 묶임.
- #### 여러 개의 반복 가능한 객체를 동시에 루프 돌면서 처리해야 할 때 zip() 함수를 사용하면 코드를 간결하고 효과적으로 작성할 수 있다.
- #### zip() 함수는 다양한 데이터 구조를 동시에 처리할 필요가 있을 때 파이썬에서 제공하는 강력한 도구 중 하나.
# 파이썬 외장(External) 함수 🌐🛠
#### 파이썬 외장 함수는 표준 라이브러리의 일부로, 다양한 목적에 맞는 프로그램 개발을 지원. 실제 프로그램 개발 시 자주 사용되는 sys, pickle, os, shutil, glob, tempfile, time, random 등의 모듈을 포함. 이러한 함수들은 파일 시스템 처리, 데이터 직렬화, 시간 처리, 난수 생성 등 다양한 시스템 및 프로그램 작업에 유용하게 사용.
#### sys 모듈은 파이썬에서 시스템 관련 정보와 기능을 다룰 때 사용하는 외장 모듈. 프로그램의 실행 환경을 제어하고, 파이썬 인터프리터에 대한 정보에 접근할 수 있게 해주며, 프로그램을 직접적으로 종료시키는 등의 작업을 수행할 수 있다. 🛠️🔧

#### sys 모듈의 주요 기능
#### 명령줄 인수 접근 (sys.argv): 프로그램 실행 시 명령줄을 통해 전달된 인수들에 접근할 수 있다. 이를 통해 사용자가 프로그램을 시작할 때 옵션을 지정하거나 입력 값을 제공할 수 있다. 📋✨

### `sys.argv`를 사용하면 파이썬 스크립트를 실행할 때 명령줄에서 전달된 인수들을 캡처할 수 있다. 이를 통해 스크립트의 동작을 동적으로 제어할 수 있는 옵션을 제공하게 된다. 예를 들어, 스크립트에 파일 이름을 인수로 전달하거나, 실행에 필요한 설정 값을 명령줄에서 지정할 수 있다. 아래는 sys.argv 사용의 간단한 예제:

```python
import sys

# 예제1
print(sys.argv)
```
#### 이 스크립트를 example.py라는 이름으로 저장하고, 명령줄에서 다음과 같이 실행한다고 가정:

```sh

python example.py arg1 arg2
```
그러면 다음과 같은 출력을 볼 수 있다:

```css
['example.py', 'arg1', 'arg2']
```
#### 여기서 sys.argv는 ['example.py', 'arg1', 'arg2']라는 리스트를 담고 있으며, 이 리스트의 첫 번째 요소는 실행된 스크립트의 이름이고, 나머지 요소들은 스크립트에 전달된 인수들.

#### `sys.argv`를 사용함으로써 스크립트에 대한 유연성을 크게 높일 수 있으며, 스크립트를 더 다양한 상황에 맞게 조정할 수 있다.

## 파이썬 외장 함수: sys와 pickle 모듈 📚💾
### 파이썬의 외장 함수들은 프로그램 개발 시 필요한 다양한 기능을 제공한다. 여기서는 sys와 pickle 모듈의 기본적인 사용 방법을 살펴보자.

### sys 모듈: 실행 관련 제어 🚦
#### sys 모듈은 파이썬 인터프리터와 밀접하게 관련된 기능들을 제공.

```python
import sys
```
### 예제1: 명령줄 인수 출력 📋
####  스크립트에 전달된 인수들을 리스트로 출력.
####  첫 번째 인수는 항상 스크립트 파일의 이름.
```py
print(sys.argv)
```
### 예제2: 프로그램 강제 종료 🛑
#### 주석을 해제하고 실행하면, 이 코드가 실행되는 지점에서 프로그램이 종료(주의!)).
#### sys.exit()

### 예제3: 파이썬 패키지 위치 🔍
#### 파이썬이 모듈을 검색할 때 참조하는 경로 목록을 출력.
```py
print(sys.path)
```
### pickle 모듈: 객체 파일 쓰기 및 읽기 📁
### pickle 모듈은 파이썬 객체를 바이트 스트림으로 직렬화하고, 이를 파일에 저장하거나 파일로부터 객체를 복원하는 기능을 제공.

```python
import pickle
```

### 예제4: 객체를 파일에 쓰기 (직렬화) 📤
### pickle 모듈을 사용해서 파이썬 객체를 파일에 저장하는 과정을 직렬화라고 합니다. 이 과정에서 wb (write binary) 모드로 파일을 열어, 데이터를 바이너리 형태로 파일에 쓰게 된다.

```python
import pickle
```
### 'wb' 모드로 파일 열기: 바이너리 쓰기 모드
```py
f = open("test.obj", 'wb')
obj = {1: 'python', 2: 'study', 3: 'basic'}
pickle.dump(obj, f)  # obj 객체를 파일에 바이너리 형태로 저장(dump)
f.close()  # 파일을 닫아줌. 파일 작업이 끝났으므로 반드시 닫아줘야 한다.
```
#### pickle.dump() 함수는 파이썬 객체를 받아서 바이너리 형태로 변환(직렬화)하여 파일에 저장. 여기서 obj는 사전 객체이며, 이 객체가 파일에 바이너리 형태로 저장.
### 예제5: 파일로부터 객체 읽기 (역직렬화) 📥
#### 역직렬화는 직렬화된 데이터를 다시 파이썬 객체로 복원하는 과정. rb (read binary) 모드로 파일을 열어, 파일에 저장된 바이너리 데이터를 파이썬 객체로 로드.

```python
import pickle
```
### 'rb' 모드로 파일 열기: 바이너리 읽기 모드
```py
f = open("test.obj", 'rb')
data = pickle.load(f)  # 파일로부터 객체를 로드(load). 역직렬화 과정
print(data)  # 저장되었던 객체 출력. {'1': 'python', '2': 'study', '3': 'basic'}
f.close()  # 파일을 닫아줌.
```
#### pickle.load() 함수는 파일로부터 바이너리 데이터를 읽어 원래의 파이썬 객체로 복원(역직렬화)한다. 이 과정을 통해 파일에 저장된 데이터를 다시 파이썬에서 사용할 수 있는 객체 형태로 불러올 수 있다.
### 요약
#### pickle 모듈은 파이썬 객체를 파일에 저장하고(직렬화), 파일로부터 다시 파이썬 객체를 복원할 수 있게 해주는(역직렬화) 매우 유용한 모듈. 데이터를 영구적으로 저장하고 필요할 때 다시 불러와 사용해야 하는 경우에 이 모듈이 특히 유용.

## s 모듈: 환경 변수 및 파일 시스템 접근 🗂️🌍
#### os 모듈은 운영 체제와 상호 작용하는 다양한 기능을 제공. 환경 변수의 접근, 파일 및 디렉토리의 관리(생성, 삭제, 이름 변경) 등 운영 체제 수준의 다양한 작업을 수행할 수 있다.

```python
import os
```

###  예제6: 환경 변수 접근 🌱
#### os.environ은 현재 시스템의 환경 변수들을 담고 있는 사전(dict) 객체.
```py
print(os.environ)
```
#### 'USERNAME' 환경 변수를 통해 현재 사용자 이름을 알 수 있다.
```py
print(os.environ['USERNAME'])
```
### 예제7: 현재 작업 디렉토리 조회 📂
#### `os.getcwd()` 함수는 현재 파이썬 스크립트가 실행되고 있는 디렉토리의 경로를 반환.
```py
print(os.getcwd())
```
### 주요 기능과 사용법
- #### 환경 변수 접근: os.environ을 사용하여 프로그램 실행 환경에 대한 정보를 얻을 수 있습니다. 예를 들어, os.environ['PATH']는 시스템의 경로 변수를 반환합니다.

- #### 현재 작업 디렉토리 조회: os.getcwd() 함수를 호출하여 스크립트가 현재 실행되고 있는 디렉토리의 전체 경로를 알 수 있다. 이는 파일 경로를 지정할 때 유용하게 사용.

- #### 디렉토리 및 파일 관리: os 모듈은 디렉토리를 생성`(os.mkdir)`, 삭제`(os.rmdir)`, 이름 변경`(os.rename)` 등 파일 시스템을 관리하는 다양한 함수를 제공. 예를 들어, 새로운 디렉토리를 만들고자 할 때 `os.mkdir``('new_directory')`를 사용할 수 있다.

#### 활용 예시
- #### 환경 설정에 따른 조건부 실행: 프로그램이 특정 환경 변수의 존재 여부나 값을 기준으로 다른 동작을 수행하도록 할 수 있다.

- #### 동적 파일 경로 생성: `os.path.join(os.getcwd(), 'my_file.txt')`와 같이 현재 작업 디렉토리를 기준으로 파일 경로를 동적으로 생성할 수 있다.

- #### os 모듈은 파이썬 스크립트가 운영 체제와 더 긴밀하게 상호 작용할 수 있도록 해줌으로써, 스크립트의 활용 범위를 크게 확장시켜 준다.
  

### time 모듈: 시간 관련 처리 ⏰🔄
#### time 모듈은 시간에 관련된 다양한 기능을 제공. 현재 시간 조회, 시간 형식 변환, 지연 시간 생성 등 프로그램 내에서 시간을 다룰 때 필요한 작업을 수행할 수 있다.
```py
import time
```
### 예제8: 현재 시간을 에포크 시간으로 출력하기
#### 에포크 시간(Epoch time): 1970년 1월 1일 00:00:00부터 현재까지의 초를 나타낸다.
```py
print(time.time())  # 예: 1615962623.234607
```
### 예제9: 현재 시간을 구조화된 시간으로 변환하기
#### 구조화된 시간(tm struct): 연, 월, 일, 시, 분, 초 등으로 구성된 시간 정보.
```py
print(time.localtime(time.time()))  # 예: time.struct_time(tm_year=2021, tm_mon=3, tm_mday=17, tm_hour=10, tm_min=10, tm_sec=23, tm_wday=2, tm_yday=76, tm_isdst=0)
```
### 예제10: 현재 시간을 간단한 문자열 형태로 출력하기
#### ctime 함수는 주어진 시간(초)을 인간이 읽을 수 있는 형태로 변환.
```py
print(time.ctime())  # 예: Wed Mar 17 10:10:23 2021
```
### 예제11: 현재 시간을 지정된 형식의 문자열로 출력하기
#### strftime 함수는 사용자가 지정한 형식으로 시간을 문자열로 변환.
```py
print(time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time())))  # 예: 2021-03-17 10:10:23
```
### 예제12: 시간 간격을 두고 숫자 출력하기
#### sleep 함수는 프로그램을 지정된 시간(초) 동안 일시 정지.
```py
for i in range(5):
    print(i)  # 숫자 0부터 4까지 출력, 각 숫자 사이에는 1초의 대기 시간이 있음.
    time.sleep(1)  # 1초 동안 대기
```
### 🔎 출력값 설명:

- #### 예제8에서 `time.time()`의 출력값은 실행하는 현재 시간의 에포크 시간으로, `1970년 1월 1일 00:00:00 UTC`부터 현재까지 경과한 시간을 초 단위로 나타낸 것이다.

- #### 예제9의 `time.localtime(time.time())`는 현재 시간을 구조화된 형태로 출력합니다. 여기에는 `연(year), 월(month), 일(day), 시(hour), 분(minute), 초(second) `등의 정보가 포함.

- #### 예제10에서 `time.ctime()`는 현재 시간을 `"요일 월 일 시간 연도"` 형식의 문자열로 반환.

- #### 예제11의 `time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time()))`는 사용자가 지정한 형식으로 현재 시간을 문자열로 포맷팅하여 출력.

- #### 예제12는 `0`부터 `4`까지의 숫자를 `1초` 간격으로 하나씩 출력. time.`sleep(1)`은 각 숫자 출력 사이에 프로그램을 `1초` 동안 일시 정지시킨다.

- #### 이 `time `모듈의 예제들은 파이썬에서 시간을 다루는 다양한 방법을 보여주고. 프로그램에 따라 현재 시간을 확인하거나, 특정 시간 동안 프로그램을 대기시키는 등의 작업을 쉽게 수행할 수 있다.

```py
import random
```
### 예제13: 0과 1 사이의 실수형 난수 생성
####  random.random()은 0.0 이상 1.0 미만의 실수 난수를 반환.
```py
print(random.random())  # 예: 0.37444887175646646
```

### 예제14: 지정된 범위 내의 정수형 난수 생성
#### random.randint(a, b)는 a 이상 b 이하의 정수형 난수를 반환.
```py
print(random.randint(1, 45))  # 예: 22
```
#### random.randrange(start, stop)는 start 이상 stop 미만의 정수형 난수를 반환.
```py
print(random.randrange(1, 45))  # 예: 21
```

### 예제15: 리스트의 요소를 무작위로 섞기
#### random.shuffle(x) 함수는 리스트 x의 요소들을 무작위로 섞는다.
```py
d = [1, 2, 3, 4, 5]
random.shuffle(d)
print(d)  # 예: [2, 3, 1, 5, 4]
```

### 예제16: 리스트에서 무작위 요소 하나 선택하기
#### random.choice(seq) 함수는 주어진 시퀀스 seq에서 무작위로 요소 하나를 선택하여 반환.
```py
c = random.choice(d)
print(c)  # 예: 3 (d 리스트에서 무작위로 선택된 요소)
```
### 🔍 주요 포인트와 활용법
- #### `random()` 함수는 다양한 확률 실험과 시뮬레이션에서 기본적으로 활용.
- #### `randint()` 및 `randrange()` 함수는 게임 개발이나 테스트 데이터 생성 시 특정 범위 내에서 무작위 숫자가 필요할 때 사용.
- #### `shuffle()` 함수는 카드 게임이나 데이터의 무작위 샘플링에 필요한 셔플링 기능을 제공.
- #### `choice()` 함수는 주어진 리스트나 시퀀스에서 무작위로 항목을 선택해야 할 때 사용됩니다. 예를 들어, 랜덤 추첨 시스템에 적합.
- #### `random` 모듈은 파이썬에서 제공하는 강력하고 유연한 난수 생성 도구. 이를 통해 개발자는 프로그램에 무작위성을 쉽게 도입할 수 있으며, 다양한 상황에서 필요한 난수를 생성할 수 있다.

### 🌐 웹 브라우저 자동 실행하기: webbrowser 모듈 사용하기
#### webbrowser 모듈은 파이썬 스크립트에서 웹 브라우저를 자동으로 실행하게 해주는 간단하고 편리한 방법을 제공. 이 모듈을 사용하면 사용자의 기본 웹 브라우저를 통해 특정 URL을 열 수 있다.

```python
import webbrowser
```
### 예제17: 기본 웹 브라우저에서 URL 열기 🌍
#### webbrowser.open(url) 함수는 새 탭이나 창에서 지정된 URL을 엽니다.
```py
webbrowser.open("http://google.com")  # Google 홈페이지를 엽니다.
```
###예제18: 새 창에서 URL 열기 🆕🌐
#### webbrowser.open_new(url) 함수는 가능한 새 창에서 지정된 URL을 엽니다.
```py
webbrowser.open_new("http://google.com")  # 새 창에서 Google 홈페이지를 엽니다.
```
### 🔍 주요 포인트와 활용법
- #### webbrowser.open() 함수는 사용자의 기본 웹 브라우저에서 새 탭이나 기존 탭에서 URL을 엽니다. 이미 열려있는 브라우저가 있다면, 새 탭에서 URL을 열려고 시도할 수 있다.
- #### webbrowser.open_new() 함수는 가능하면 새 웹 브라우저 창에서 URL을 열도록 시도합니다. 하지만, 모든 웹 브라우저가 이 기능을 지원하지는 않을 수 있다.
### 활용 예시
- ####  자동화 스크립트에서 웹페이지 열기: 스크립트 실행 결과를 바로 웹에서 확인하고자 할 때 사용할 수 있다.
- #### 개발 중인 웹 애플리케이션 자동 실행: 개발 중인 웹사이트를 바로 열어보고자 할 때 편리하다.
- #### 사용자에게 도움말 페이지나 추가 정보 제공: 애플리케이션 사용 중 필요한 도움말이나 정보를 웹사이트로 제공하고자 할 때 사용할 수 있다.
- #### webbrowser 모듈은 간단하지만 매우 유용한 기능을 제공하여, 파이썬 애플리케이션에서 사용자의 웹 브라우저를 활용할 수 있게 해준다.

## 🔄 복습 중요한것 🔄

### 📦 pickle 모듈: 파이썬 객체 직렬화 🔄
- #### 핵심: 파이썬의 객체를 바이트 스트림으로 변환하여 파일에 저장하고(dump), 반대로 파일로부터 객체를 복원하는(load) 과정을 담당한다.
- #### 사용 시나리오: 사용자의 세션 데이터를 파일에 저장하거나, 프로그램 간에 객체 데이터를 교환할 때 유용.
- #### 주의할 점: pickle로 저장된 데이터는 파이썬 버전에 따라 호환성 문제가 발생할 수 있으니 주의가 필요.
### ⏰ time 모듈: 시간 관련 기능 ⌛
- #### 핵심: 현재 시간을 다루거나, 프로그램의 실행을 일정 시간 동안 지연시키는 기능(sleep)을 제공.
- #### 사용 시나리오: 로그에 시간을 기록하거나, 시간 기반의 작업 예약, 시뮬레이션의 시간 흐름 제어에 사용.
- #### 포인트: time()은 현재 시간을 에포크 시간으로 반환하고, strftime()으로 시간을 문자열로 포매팅 할 수 있다.
### 🗂 os 모듈: 운영체제와 상호작용 🖥
- #### 핵심: 파일, 디렉토리 관리, 시스템 환경 변수에 접근하고, 운영 체제의 기능을 사용할 수 있게 해준다.
- #### 사용 시나리오: 파일의 존재 여부 확인, 디렉토리 생성 및 변경, 환경 변수 접근 등 프로그램이 운영 체제와 상호작용이 필요할 때 활용.
- #### 포인트: os.getcwd()로 현재 작업 디렉토리를 얻고, os.environ으로 환경 변수에 접근할 수 있다.
### 🚦 sys 모듈: 시스템 관련 정보 접근 🛠
- #### 핵심: 파이썬 인터프리터와 밀접한 정보에 접근하고, 파이썬 스크립트에 대한 제어 기능을 제공.
- #### 사용 시나리오: 스크립트에 전달된 인수(argv) 처리, 스크립트 강제 종료(exit), 모듈 경로 접근 및 수정 등에 사용.
- #### 포인트: sys.argv를 사용하여 스크립트 실행 시 전달된 인수를 처리하고, sys.exit()으로 프로그램을 종료시킬 수 있다.
#### 각 모듈은 파이썬 프로그래밍에서 자주 사용되며, 데이터의 저장 및 복원, 시간 관련 작업, 파일 및 디렉토리 관리, 시스템과의 상호작용 등 다양한 영역에서 중요한 역할을 한다. 비전공자도 이해하기 쉽게 접근할 수 있도록 기본 개념과 주요 사용 시나리오를 중심으로 학습하는 것이 좋다.
---
# 파일 읽기 및 쓰기 📖✍️
#### 파일을 다루는 기본적인 작업은 파일을 읽고, 쓰는 것. 파이썬에서는 이러한 작업을 간단하게 할 수 있는 내장 함수를 제공. 파일을 열 때 사용할 수 있는 다양한 모드와 경로를 지정하는 방법에 대해 알아보자.

### 파일 모드와 경로 지정 📁🛠
#### 파이썬에서 파일을 다루는 기본적인 방법은 파일을 열고(open), 읽거나 쓰고`(read/write)`, 닫는`(close)` 것이다. 이 과정에서 다양한 파일 모드와 경로를 지정할 수 있다.

### 파일 모드 📑
#### 읽기 모드 (read): 파일을 읽기 전용으로 엽니다. 파일이 존재하지 않으면 FileNotFoundError 오류가 발생.
#### 쓰기 모드 (write): 파일을 쓰기 전용으로 엽니다. 파일이 이미 존재하면 해당 파일의 내용을 모두 삭제하고 처음부터 씁니다. 파일이 없으면 새로 생성.
#### 추가 모드 (append): 파일의 끝에 새로운 내용을 추가할 때 사용. 파일이 없으면 새로 생성.
#### 텍스트 모드 (text): 텍스트 파일을 처리할 때 사용. 이는 기본값.
#### 바이너리 모드 (binary): 바이너리 파일(이미지, 비디오 등)을 처리할 때 사용.
### 경로 지정 🗺️
#### 상대 경로: 현재 작업 중인 디렉토리를 기준으로 파일의 위치를 지정.
```java
'./': // 현재 디렉토리
'../': //  상위 디렉토리
```
#### 절대 경로: 루트 디렉토리부터 전체 디렉토리 경로를 지정.
```java
예: 'C:/Django/example.txt' (Windows), '/home/user/example.txt' (Linux/Mac)
```
### 파일 읽기(Read) 📖✨
#### 파일을 읽는 과정은 데이터를 처리하거나 분석하기 위해 필요한 첫 단계. 여기서는 기본적인 파일 읽기 방법과 파일 객체의 주요 속성들을 확인하는 방법에 대해 알아보자.

### 예제1: 파일 읽기 및 속성 확인
```python
# 파일 열기
f = open('./resource/it_news.txt', 'r', encoding='UTF-8')

# 파일 객체의 속성 확인
print(dir(f))  # 파일 객체가 가진 속성 및 메서드 목록 출력
print(f.encoding)  # 파일의 인코딩 확인
print(f.name)  # 파일 이름 확인
print(f.mode)  # 파일이 열린 모드 확인

# 파일 내용 읽기
cts = f.read()
print(cts)  # 파일의 전체 내용 출력

# 파일 닫기
f.close()  # 열린 파일 객체는 반드시 닫아야 한다.
```
### 핵심 포인트 및 중요 속성들 🔑
- #### 파일 열기: `open` 함수를 사용하여 파일을 엽니다. 여기서는 텍스트 파일을 읽기 모드(`'r'`)로 열고 있다. encoding='UTF-8'은 파일이 UTF-8 인코딩으로 되어 있음을 명시한다.

#### 속성 확인:

- #### dir(f): 파일 객체가 제공하는 속성과 메서드의 리스트를 보여준다.
- #### f.encoding: 파일의 인코딩 타입을 확인할 수 있다.
- #### f.name: 열린 파일의 이름을 확인할 수 있다.
- #### f.mode: 파일을 열 때 사용된 모드('`r'`은 읽기 모드)를 확인할 수 있다.
- #### 파일 읽기: `f.read()` 메서드를 사용하여 파일의 전체 내용을 읽고 출력.

- #### 파일 닫기: `f.close()`는 사용이 끝난 파일을 닫아주는 중요한 작업. 파일을 닫지 않으면 리소스 누수가 발생할 수 있다. 파이썬에서는 `with` 문을 사용하여 파일을 열면, `with` 블록을 벗어날 때 자동으로 파일을 닫아주는 관리가 가능.

### 이해하고 넘어가야 할 중요 포인트 🧐
- #### 인코딩 지정: 특히 텍스트 파일을 다룰 때, 올바른 인코딩을 지정하는 것이 중요. 잘못된 인코딩을 사용하면 파일 내용을 제대로 읽지 못할 수 있다.

- #### 자원 관리: 파일 작업 후에는 반드시 파일을 닫아주어야 한다. `with open`(파일경로, 모드) `as 파일변수`: 구문을 사용하면, 블록 내의 작업이 끝난 후 자동으로 파일을 닫아준다.

## 파일 읽기(Read)의 또 다른 방법: with 문 사용하기 📘🔍
#### 파일을 열고 작업한 후 자동으로 닫기 위해` with` 문을 사용하는 방법을 소개한다. 이 방법은 파일을 다룰 때 권장되는 방식 중 하나로, 파일을 올바르게 닫아 자원 누수를 방지하고 코드의 가독성을 높여준다.

### 예제2: with 문을 사용한 파일 읽기
```python
# 파일을 읽기 모드로 열고 내용을 읽은 후 자동으로 닫기
with open('./resource/it_news.txt', 'r', encoding='UTF-8') as f:
    c = f.read()  # 파일의 전체 내용을 읽어옴.
    print(c)  # 읽어온 내용 출력

    # iter() 함수와 list() 함수를 사용해 본 예제의 추가 설명
    print(iter(c))  # 문자열 'c'에 대한 이터레이터 객체를 생성.
    print(list(c))  # 문자열 'c'의 각 문자를 요소로 하는 리스트로 변환.
```
#### 핵심 포인트 🌟
- #### with open(파일경로, 모드) as 변수명:: 이 구문을 사용하면, 파일 작업이 끝난 후에 파일이 자동으로 닫힙니다. with 문은 파일뿐만 아니라 자원 관리가 필요한 다른 상황에서도 유용하게 사용.

- #### f.read(): 파일의 전체 내용을 한 번에 읽어온다. 큰 파일을 처리할 때는 메모리 사용에 주의해야 한다.

- #### iter()와 list() 사용: 이 부분은 파일 읽기와 직접적인 관련이 없지만, 문자열을 이터레이터로 변환하거나 문자 하나하나를 리스트의 요소로 만드는 방법을 보여준다. 문자열 c가 이미 전체 파일 내용을 담고 있기 때문에, list(c)는 파일 내용의 각 문자를 개별 요소로 가지는 리스트를 생성.

### 중요한 포인트 📌
- #### 자원 관리: with 문을 사용함으로써, 파일을 명시적으로 닫는 close() 호출 없이도 파일이 자동으로 닫히게 됩니다. 이는 코드의 안정성과 가독성을 높여준다.

- #### 인코딩 지정: 파일을 열 때 encoding 파라미터를 지정함으로써, 다양한 언어의 텍스트 파일도 올바르게 읽고 쓸 수 있다. 이는 특히 다국어를 다루는 글로벌 애플리케이션에서 중요.

#### 이러한 방법으로 파일을 읽는 작업은 파이썬 프로그래밍의 기본 중 하나. 특히 비전공자도 쉽게 이해할 수 있도록 핵심적인 개념과 사용 방법에 집중하는 것이 중요.


### 파일 읽기의 고급 기법: 부분 읽기와 커서 조작 📚🔍
#### 파일에서 데이터를 부분적으로 읽거나, 파일 내의 특정 위치로 커서를 이동시키는 방법을 살펴보자. 이는 큰 파일을 처리하거나, 파일 내 특정 데이터에 접근할 때 유용하게 사용.

### 예제3: read()와 seek() 메서드 활용하기
```python
# 파일을 읽기 모드로 열기
with open('./resource/it_news.txt', 'r', encoding='UTF-8') as f:
    # 첫 번째 read(20): 파일의 시작부터 20바이트를 읽는다.
    c = f.read(20)
    print(c)  # 읽은 내용 출력
    
    # 두 번째 read(20): 현재 커서 위치에서 다음 20바이트를 읽는다.
    c = f.read(20)
    print(c)
    
    # 세 번째 read(20): 계속해서 다음 20바이트를 읽는다.
    c = f.read(20)
    print(c)
    
    # seek(0,0): 파일의 시작 위치(0,0)으로 커서를 이동한다.
    f.seek(0,0)
    
    # 커서 위치를 초기화한 후 다시 처음부터 20바이트를 읽는다.
    c = f.read(20)
    print(c)
```
### 핵심 포인트 🌟
#### read(바이트수) 메서드: read() 메서드에 바이트 수를 지정하면, 해당 크기만큼의 데이터를 파일에서 읽어온다. 지정하지 않으면 파일의 전체 내용을 읽는다.

- #### seek(오프셋, 위치) 메서드: seek() 메서드를 사용하여 파일 내에서 커서의 위치를 조정할 수 있다. 여기서 오프셋은 이동할 바이트 수, 위치는 시작점을 의미(0은 파일의 시작, 1은 현재 위치, 2는 파일의 끝).

### 중요한 포인트 📌
- #### 파일 읽기 과정에서 커서 관리: 파일을 부분적으로 읽을 때는 현재 커서의 위치가 중요. read() 메서드는 현재 커서 위치부터 데이터를 읽기 시작하므로, 커서 위치를 잘 관리해야 한다.

- #### 커서 위치 초기화: seek(0,0)을 사용하여 언제든지 파일의 시작 지점으로 커서를 이동시킬 수 있다. 이는 파일을 처음부터 다시 읽고 싶을 때 유용하다.
  
## 파일에서 한 줄씩 읽기: readline() 메서드 📝➡️
#### 파일을 처리할 때 특히 텍스트 파일을 한 줄씩 읽어야 하는 경우가 자주 있다. 파이썬의 readline() 메서드를 사용하면 이를 간단히 할 수 있다. 이 방법은 로그 파일 분석, 설정 파일 읽기 등 다양한 상황에서 유용하게 사용.

### 예제4: readline() 사용하기
```python
# 파일을 읽기 모드로 열고 한 줄씩 읽기
with open('./resource/it_news.txt', 'r', encoding='UTF-8') as f:
    # 첫 번째 줄 읽기
    line = f.readline()
    print(line)  # 첫 번째 줄의 내용 출력
    
    # 두 번째 줄 읽기
    line = f.readline()
    print(line)  # 두 번째 줄의 내용 출력
```
### 핵심 포인트 🌟
- #### readline() 메서드: 파일에서 한 줄을 읽고, 읽은 내용을 문자열로 반환. 줄바꿈 문자(\n)도 포함. 파일의 끝에 도달하면 빈 문자열('')을 반환.

- #### 파일 커서: `readline()`을 호출할 때마다 파일 내의 커서가 다음 줄로 이동한다. 이를 통해 파일을 순차적으로 한 줄씩 읽을 수 있다.

#### 사용 시나리오 🛠
- #### 로그 파일 처리: 각 로그가 한 줄로 기록된 로그 파일을 분석할 때, 한 줄씩 읽으며 필요한 정보를 추출할 수 있다.

- #### 설정 파일 읽기: 대부분의 설정 파일은 한 줄에 하나의 설정이 기록되어 있다. `readline()` 메서드를 사용하여 이러한 설정 파일을 쉽게 읽고 처리할 수 있다.

### 추가 팁 ✨
- #### 파일 전체를 한 줄씩 읽으려면`readline()`을 `while` 루프와 함께 사용하거나, `for` 루프에서 파일 객체를 직접 반복하는 방법이 있다. 후자의 방법이 더 간단하고 파이썬스러운 코드를 작성할 수 있다.
- #### `readline()` 메서드를 활용하면 파일의 내용을 효율적으로 한 줄씩 읽어 처리할 수 있으며, 특히 큰 파일을 처리할 때 메모리를 절약할 수 있다.


## 파일을 라인 단위로 읽고 리스트에 저장하기: readlines() 메서드 📚📃
#### 파일의 내용을 한 번에 모두 읽어 각 줄을 리스트의 아이템으로 저장하고자 할 때 `readlines()` 메서드를 사용할 수 있다. 이 메서드는 특히 파일의 모든 라인을 순회하면서 처리해야 할 때 유용.

### 예제5: readlines() 사용하기
```python
# 파일을 읽기 모드로 열고 모든 라인을 리스트로 읽기
with open('./resource/it_news.txt', 'r', encoding='UTF-8') as f:
    cts = f.readlines()  # 파일의 모든 라인을 읽어 리스트에 저장
    print(cts)  # 리스트 출력

    print()  # 공백 라인 출력
    
    # 리스트의 각 요소(라인)을 순회하며 출력
    for c in cts:
        print(c, end='')  # 라인 출력 시 라인 끝의 개행문자 때문에 추가 개행을 방지하기 위해 end='' 사용
```
### 핵심 포인트 🌟
- #### readlines() 메서드: 파일의 모든 내용을 읽어서 각 줄을 리스트의 원소로 반환. 리스트의 각 원소는 파일의 한 줄을 나타내며, 줄바꿈 문자(\n)를 포함.

- #### 리스트 처리: readlines()로 얻은 리스트는 for 루프를 통해 각 줄을 순회하며 처리할 수 있다. 이 방법은 파일의 각 줄에 대해 반복 작업을 수행해야 할 때 매우 유용.

### 사용 시나리오 🛠
- #### 파일 내용 분석: 파일의 모든 줄을 리스트로 불러온 후, 특정 조건에 맞는 줄만을 선택하거나 변형하여 분석할 수 있다.

- #### 파일 내용 출력: 파일의 내용을 전체적으로 또는 조건에 따라 선택적으로 출력할 때 사용할 수 있다.

### 추가 팁 ✨
- #### 대용량 파일 처리 시에는 `readlines()` 메서드가 메모리를 많이 사용할 수 있으므로 주의가 필요. 파일의 크기가 프로그램의 메모리 용량을 초과하지 않는지 확인해야 한다.

#### 간단한 처리를 위해서는 파일 객체를 직접 순회하는 방법(`for line in f:`)을 사용하는 것이 메모리 사용 측면에서 더 효율적일 수 있다.

#### readlines() 메서드를 사용하면 파일의 모든 줄을 쉽게 리스트로 변환하여 다양한 처리를 할 수 있다. 파일을 다루는 다양한 상황에서 이 메서드를 활용하여 코드를 간결하고 효율적으로 작성할 수 있다.

## 파일 쓰기(Write) 방법들 🖋️📄
### 파이썬에서 제공하는 다양한 방법을 통해 파일에 데이터를 쓰는 과정을 자세히 알아보자. 이 과정은 데이터의 영구 저장, 설정 파일 작성, 로그 기록 등에 활용.

### 예제1: 기본 텍스트 쓰기
```python
# 'w' 모드로 파일을 열어 기존 내용을 삭제하고 새로운 텍스트를 씁니다.
with open('./resource/contents1.txt', 'w', encoding='UTF-8') as f:
    f.write('I love python\n')  # 문자열에 포함된 개행 문자(\n)로 줄바꿈
```
#### 📝 'w' 모드는 파일이 존재하지 않을 경우 새로운 파일을 생성하고, 이미 존재한다면 그 내용을 모두 지우고 처음부터 쓴다.

### 예제2: 텍스트 추가하기
```python
# 'a' 모드로 파일 끝에 새로운 내용을 추가.
with open('./resource/contents1.txt', 'a', encoding='UTF-8') as f:
    f.write('I love python2\n')  # 이전 내용을 유지하고 새 내용을 추가
```
#### 📌 'a' 모드는 기존 파일의 내용을 보존하면서 끝에 추가적인 데이터를 쓸 때 사용.

### 예제3: 리스트를 파일에 쓰기
```python
# 'w' 모드로 파일을 열어 리스트의 각 항목을 파일에 순서대로 씁니다.
with open('./resource/contents2.txt', 'w', encoding='UTF-8') as f:
    list = ['Orange\n', 'Apple\n', 'Banana\n', 'Melon\n']  # 리스트 준비
    f.writelines(list)  # 리스트의 각 항목을 파일에 쓰기
```
#### 🍊🍎 리스트의 각 원소는 파일에 그대로 쓰이며, 원소마다 이미 개행 문자(\n)가 포함되어 있어서 각 줄에 하나의 원소가 기록된다.

### 예제4: print 함수를 이용한 파일 쓰기
```python
# 'w' 모드로 파일을 열고 print 함수를 사용해 텍스트를 씁니다.
with open('./resource/contents3.txt', 'w', encoding='UTF-8') as f:
    print('Test Text Write!', file=f)  # print 함수를 사용해 파일에 직접 쓰기
    print('Test Text Write!', file=f)
    print('Test Text Write!', file=f)
```
#### 🖨️ `print` 함수의 `file` 파라미터를 사용하면 콘솔 대신 파일에 직접 출력할 수 있으며, 자동으로 개행이 추가된다.

#### 핵심 포인트 🌟
- #### 파일 모드: 'w' 모드는 파일에 쓰기를 위해 사용되며, 파일이 이미 존재할 경우 기존 내용을 지우고 새로 쓴다. 'a' 모드는 파일의 기존 내용을 유지하면서 끝에 새로운 내용을 추가.

- #### `write()`와 `writelines():` `write()` 메서드는 하나의 문자열을 파일에 쓰는 데 사용되고, `writelines()` 메서드는 문자열의 리스트를 파일에 연속적으로 쓸 때 사용된다.

- #### print 함수: `print` 함수는 콘솔 출력뿐만 아니라 `file` 파라미터를 통해 파일에도 직접 출력할 수 있습니다. 이 방법은 개행 문자를 자동으로 추가해 준다.

### 사용 시나리오 🛠
- #### 데이터 저장: 계산 결과, 사용자 입력 등 프로그램에서 생성된 데이터를 파일에 저장할 필요가 있을 때 사용한다.

- #### 로그 기록: 프로그램의 작동 상태나 오류 메시지를 로그 파일에 기록하고 싶을 때 활용할 수 있다.

### 중요 포인트와 사용 시나리오 📌
- #### 파일 작업을 할 때는 파일 모드('w', 'a')에 주의하여 적절한 모드를 선택해야 한다.
- #### 데이터를 파일에 쓸 때는 인코딩을 명시하는 것이 좋다. 이를 통해 다양한 언어의 문자가 올바르게 처리된다.
- #### `with` 문을 사용하면 파일 작업 후 자동으로 파일을 닫아주기 때문에, 파일을 명시적으로 닫는 과정을 생략할 수 있어 편리하다.

## CSV 파일 읽기 및 쓰기 📝🔀
### `CSV(Comma-Separated Values)` 파일은 간단한 텍스트 파일로, 데이터를 쉼표(,)로 구분하여 저장합니다. 이 형식은 테이블 데이터를 저장하고 공유하기 위한 가장 일반적인 방법 중 하나입니다. `MIME` 타입은 `text/csv`이다.

### 🗂️🐍CSV 파일의 특징
- #### 간단하고 범용적: 거의 모든 데이터베이스 및 스프레드시트 프로그램에서 읽고 쓸 수 있다.
- #### 읽기 쉽고 작성하기 쉬움: 텍스트 에디터로 쉽게 열어볼 수 있으며, 사람이 읽을 수 있는 형식으로 되어 있다.
- #### 프로그래밍 언어 지원: 파이썬을 포함한 대부분의 프로그래밍 언어에서 `CSV` 파일을 쉽게 처리할 수 있는 라이브러리를 제공한다.
### 🗂️🐍 파이썬에서 CSV 다루기
- #### 파이썬의 `csv` 모듈을 사용하면 CSV 파일을 쉽게 읽고 쓸 수 있다. 이 모듈은 CSV 파일의 읽기 및 쓰기를 위한 간편한 인터페이스를 제공한다.

- #### CSV 읽기: `csv.reader()` 함수를 사용하면 CSV 파일의 내용을 순회할 수 있는 리더 객체를 얻을 수 있다.
- #### CSV 쓰기: `csv.writer()` 함수를 사용하면 CSV 파일에 데이터를 쓸 수 있는 라이터 객체를 생성할 수 있다.
- #### CSV 파일 작업의 주요 사용 사례
- #### 데이터 분석: 데이터 과학 프로젝트에서 다양한 데이터셋을 `CSV` 형식으로 저장하고 분석한다.
- #### 데이터 이전: 서로 다른 데이터베이스나 애플리케이션 간에 데이터를 이전할 때 `CSV` 형식을 사용한다.
- #### 보고서 생성: 분석 결과를 `CSV` 파일로 저장하여 보고서를 생성하거나 스프레드시트 애플리케이션으로 쉽게 가져올 수 있다.

## 파이썬으로 CSV 파일 읽기: csv.reader() 사용하기 📖🐍
#### 파이썬의 csv 모듈은 `CSV` 파일을 효과적으로 처리할 수 있는 간편한 방법을 제공. 여기서는 `csv.reader()` 함수를 사용하여 CSV 파일을 읽는 기본적인 방법을 알아본다.

### 예제1: csv.reader()로 CSV 파일 읽기
```python
import csv

# CSV 파일 열기
with open('./resource/test1.csv', 'r') as f:
    reader = csv.reader(f)
    # Header Skip (첫 번째 줄을 건너뛰고 싶을 때 사용)
    # next(reader)
    
    # CSV reader 객체 확인
    print(reader)
    # 리더 객체의 타입 확인
    print(type(reader))
    # 리더 객체가 가진 속성 및 메서드 확인
    print(dir(reader))  # __iter__ 포함
    print()

    # CSV 파일의 각 줄을 순회하며 처리
    for c in reader:
        # 각 줄의 타입 확인 (리스트 타입)
        print(type(c))
        # 리스트의 요소를 문자열로 합치기
        print(''.join(c))
```
### 핵심 포인트 🌟
- #### csv.reader() 함수: `CSV` 파일을 읽어오기 위해 사용되며, 이 함수는 파일 객체를 매개변수로 받는다. 리턴되는 객체`(reader)`는 반복 가능한`(iterable)` 객체로, 파일의 각 줄을 리스트 형태로 반환.

- #### 리스트로 반환: `csv.reader()`는 파일의 각 줄을 리스트로 반환. 각 리스트의 요소는 해당 줄의 쉼표로 구분된 값이다.

- #### next(reader) 사용: 파일의 첫 번째 줄(헤더)을 건너뛰고자 할 때 사용할 수 있다. 이는 데이터 처리 시 헤더를 제외하고 데이터만 처리하고자 할 때 유용.

### 사용 시나리오 🛠
- #### 데이터 분석 및 처리: 데이터 과학이나 분석 프로젝트에서 CSV 형식으로 저장된 데이터셋을 읽고 처리하기 위해 사용.

- #### 데이터 변환: 읽어온 데이터를 가공하거나 다른 형식으로 변환하여 사용. 예를 들어, 특정 조건에 맞는 데이터만 필터링하거나, 새로운 데이터 형식으로 재구성할 수 있다.

### 중요 포인트 📌
- #### 객체의 타입과 속성 이해하기: `csv.reader()`로부터 반환된 객체는 반복 가능하며, 각 반복에서 리스트 객체를 반환. 이러한 특성을 이해하고 활용하는 것이 중요.

- #### 데이터 처리: 반환된 리스트를 사용하여 문자열 연결, 데이터 변환 등 다양한 데이터 처리 작업을 할 수 있다. 특히, `join()`메서드를 사용하여 리스트의 요소를 하나의 문자열로 합치는 방법은 `CSV` 데이터를 문자열로 변환하고자 할 때 유용.

### CSV 파일 읽기: 구분자 지정하기 📖🔧
#### CSV 파일을 읽을 때, 데이터가 쉼표(,)로 구분되지 않는 경우가 있을 수 있다. 이럴 때는 `csv.reader`에 `delimiter` 매개변수를 사용하여 적절한 구분자를 지정할 수 있다.

### 예제2: 구분자 지정하여 CSV 파일 읽기
```python
import csv

# CSV 파일 열기 및 구분자 지정
with open('./resource/test1.csv', 'r') as f:
    reader = csv.reader(f, delimiter=',')  # 구분자를 쉼표(,)로 지정
    # next(reader) # 첫 번째 줄(헤더)을 건너뛰고 싶을 때 사용

    # CSV 파일의 각 줄을 순회하며 출력
    for c in reader:
        print(''.join(c))  # 각 줄의 데이터를 하나의 문자열로 결합하여 출력
```
### 핵심 포인트 🌟
- #### 구분자(delimiter) 지정: `csv.reader` 함수의 `delimiter` 매개변수를 사용하여 CSV 파일의 구분자를 지정할 수 있다. 기본값은 쉼표(,)입니다.

- #### 헤더 스킵: 파일의 첫 번째 줄이 데이터가 아닌 헤더(열 이름 등)일 경우, next(reader)를 사용하여 첫 줄을 건너뛸 수 있다.

### 사용 시나리오 🛠
- #### 다양한 형식의 CSV 파일 처리: 데이터가 탭(\t), 세미콜론(;) 등 다른 문자로 구분되어 있는 CSV 파일을 처리할 때 유용.

- #### 데이터 전처리: 데이터 분석이나 처리를 위해 원시 데이터 파일을 읽고 전처리하는 과정에서 구분자를 정확히 지정하여 데이터를 올바르게 로드해야 한다.

### 중요 포인트 📌
- #### 구분자에 주의하기: `CSV` 파일을 다룰 때 파일의 구분자를 정확히 알고 있어야 합니다. 잘못된 구분자를 지정하면 데이터가 제대로 읽히지 않을 수 있다.

- #### 데이터 구조 이해하기: CSV 파일을 읽을 때 각 줄이 어떻게 구성되어 있는지, 어떤 형태로 데이터를 처리할 것인지를 미리 파악하는 것이 중요.

### CSV 파일을 딕셔너리로 변환하기: csv.DictReader() 사용 🗂️➡️📖
#### 파이썬의 `csv` 모듈에서는 `csv.DictReader()` 함수를 사용하여 `CSV` 파일의 각 줄을 딕셔너리로 쉽게 변환할 수 있다. 이 방법은 `CSV `파일의 컬럼 헤더를 키로, 각 줄의 데이터를 값으로 사용하여 작업을 진행할 때 특히 유용.

### 예제3: csv.DictReader()로 CSV 파일 읽기
```python
import csv

# CSV 파일 열기
with open('./resource/test1.csv', 'r') as f:
    reader = csv.DictReader(f)  # DictReader 사용

    # DictReader 객체 확인
    print(reader)
    print(type(reader))  # <class 'csv.DictReader'>
    print(dir(reader))  # __iter__ 확인
    print()

    # CSV 파일의 각 줄을 딕셔너리로 순회
    for c in reader:
        for k, v in c.items():
            print(k, v)  # 키와 값 출력
        print('-----')
```
### 핵심 포인트 🌟
- #### 딕셔너리로 변환: `csv.DictReader()`는 파일의 각 줄을 딕셔너리로 변환하여 반환. 파일의 첫 번째 줄(헤더)은 딕셔너리의 키로 사용된다.

- #### 데이터 접근 용이성: 변환된 딕셔너리를 사용하면, 컬럼명을 키로 하여 각 데이터에 쉽게 접근할 수 있다. 이는 데이터 처리 시 명확한 컬럼명을 사용하여 코드의 가독성을 높이는 데 도움을 준다.

### 사용 시나리오 🛠
- #### 데이터 분석 및 처리: `CSV` 파일에서 읽어온 데이터를 컬럼명을 기준으로 분석하거나 처리할 때 사용된다. 각 데이터 항목에 이름을 사용하여 접근할 수 있어 편리하다.

- #### 데이터 변환 및 저장: 읽어온 데이터를 다른 형식으로 변환하거나 데이터베이스에 저장할 때, 딕셔너리 형태로 데이터를 다루면 작업이 용이해진다.

### 중요 포인트 📌
- #### 헤더의 중요성: `csv.DictReader()`를 사용할 때는 `CSV` 파일의 첫 번째 줄이 헤더(컬럼명)로 사용된다. 파일에 헤더가 없는 경우, 딕셔너리의 키로 사용할 컬럼명 리스트를 `fieldnames`매개변수로 직접 제공할 수 있다.

- #### 데이터 처리의 유연성: 딕셔너리 형태로 데이터를 처리하면, 키-값 쌍을 이용하여 보다 유연하고 직관적인 데이터 처리가 가능해진다. 데이터의 추출, 수정, 추가 등 다양한 작업을 쉽게 수행할 수 있다.

- #### `sv.DictReader()`를 사용하는 것은 CSV 파일 데이터를 효과적으로 처리할 수 있는 방법 중 하나이다. 데이터를 딕셔너리 형태로 다루면서 파이썬의 강력한 데이터 처리 능력을 최대한 활용할 수 있다.

### CSV 파일 쓰기: csv.writer() 사용하기 ✍️📁
#### 파이썬의 csv 모듈을 사용하여 리스트 데이터를 CSV 파일로 쉽게 쓸 수 있다. 여기서는 `csv.writer()` 함수를 활용하여 다차원 리스트의 데이터를 `CSV` 파일에 쓰는 방법을 알아보자.

### 예제4: csv.writer()로 데이터 쓰기
```python
import csv

# 데이터 준비
w = [
    [1, 2, 3], 
    [4, 5, 6], 
    [7, 8, 9], 
    [10, 11, 12], 
    [13, 14, 15], 
    [16, 17, 18], 
    [19, 20, 21]
]

# CSV 파일 열기 및 쓰기
with open('./resource/write1.csv', 'w', newline='', encoding='utf-8') as f:
    wt = csv.writer(f)  # csv.writer 객체 생성

    # csv.writer 객체의 메서드 확인
    print(dir(csv))
    print(dir(wt))
    # writer 객체의 타입 확인
    print(type(wt))

    # 리스트의 각 항목(하위 리스트)을 CSV 파일에 한 줄씩 쓰기
    for v in w:
        wt.writerow(v)
```
### 핵심 포인트 🌟
- #### csv.writer() 함수: `CSV` 파일에 데이터를 쓰기 위한 `writer` 객체를 생성합니다. 이 객체는 `writerow()` 메서드를 통해 리스트 데이터를 한 줄씩 파일에 쓸 수 있게 해준다.

- #### 데이터 구조: 이 예제에서는 2차원 리스트(w)의 각 원소(하위 리스트)가 `CSV` 파일의 한 줄을 나타낸다. `writerow()` 메서드는 이러한 리스트를 받아 `CSV` 파일의 한 줄로 쓰게 된다.

- #### newline='' 매개변수: 파일을 열 때 newline=''을 지정해야 하는데, 이는 파일 쓰기 작업 시 줄바꿈이 올바르게 처리되도록 한다. (newline 매개변수가 없다면, 윈도우 환경에서는 불필요한 줄바꿈이 발생할 수 있다.)

### 사용 시나리오 🛠
- #### 데이터 저장: 분석 결과나 프로그램에서 생성된 데이터를 `CSV` 형식으로 저장할 때 사용한다.

- #### 보고서 작성: 데이터를 정리하여 보고서를 작성하거나, 스프레드시트 프로그램에서 사용할 수 있는 데이터 파일을 생성할 때 활용된다.

### 중요 포인트 📌
- #### 데이터의 형태와 구조: 데이터를 `CSV` 파일에 쓸 때는 데이터의 형태와 구조를 사전에 정확히 파악하는 것이 중요합니다. 데이터를 어떤 형식(예: 한 줄에 하나의 레코드)으로 파일에 쓸 것인지 결정해야 합니다.

- #### 인코딩 지정: 특히 다국어 문자가 포함된 데이터를 다룰 때는 `encoding='utf-8'` 같은 적절한 인코딩을 지정하여 문자가 올바르게 파일에 쓰이도록 해야 한다.

- #### `csv.writer()`를 활용하는 방법은 파이썬에서 데이터를 `CSV` 파일로 쉽고 효율적으로 쓸 수 있는 기본적인 방법 중 하나이다. 데이터 작업에 있어 필수적인 기술로, 이를 통해 다양한 데이터 관리 작업을 수행할 수 있다.


### CSV 파일에 딕셔너리 데이터 쓰기: csv.DictWriter() 활용하기 ✍️🗂️
#### 파이썬의 `csv` 모듈에서는 `DictWriter` 클래스를 통해 딕셔너리 데이터를 `CSV` 파일로 쉽게 쓸 수 있습니다. 이 방법은 데이터의 각 필드(컬럼)를 명시적으로 정의하고 싶을 때 특히 유용.

### 예제5: csv.DictWriter()로 딕셔너리 데이터 쓰기
```python
import csv

# 쓸 데이터 준비
w = [
    [1, 2, 3], 
    [4, 5, 6], 
    [7, 8, 9], 
    [10, 11, 12], 
    [13, 14, 15], 
    [16, 17, 18], 
    [19, 20, 21]
]

# CSV 파일 열기
with open('./resource/write2.csv', 'w', newline='') as f:
    # 필드명 정의
    fields = ['one', 'two', 'three']
    # DictWriter 객체 생성
    wt = csv.DictWriter(f, fieldnames=fields)
    # 헤더(필드명) 쓰기
    wt.writeheader()

    # 데이터를 딕셔너리 형태로 변환하여 쓰기
    for v in w:
        wt.writerow({'one': v[0], 'two': v[1], 'three': v[2]})
```
### 핵심 포인트 🌟
- #### csv.DictWriter(): `CSV` 파일에 데이터를 딕셔너리 형태로 쓰기 위해 사용된다. `fieldnames` 매개변수에는 파일의 컬럼명을 리스트로 전달한다.

- #### 헤더 쓰기: `writeheader()` 메서드를 호출하여 `CSV` 파일의 첫 번째 줄에 컬럼명(필드명)을 쓴다.

- #### 딕셔너리로 데이터 쓰기: writerow() 메서드에 딕셔너리 객체를 전달하여 파일에 한 줄의 데이터를 쓴다. 딕셔너리의 키는 `fieldnames`에 정의한 컬럼명과 일치해야 한다.

### 사용 시나리오 🛠
- #### 명시적인 컬럼명을 가진 데이터 작업: 데이터의 각 필드가 무엇을 의미하는지 명확히 해야 할 때 사용된다. 이 방법은 데이터의 구조를 파일에 명시적으로 반영할 수 있게 해준다.

- #### 데이터베이스와의 작업: 데이터베이스에서 추출한 데이터를 `CSV` 파일로 저장하거나, 반대로 `CSV` 파일을 데이터베이스에 적용해야 할 때 유용하다.

### 중요 포인트 📌
- #### 필드명의 중요성: DictWriter를 사용할 때는 각 데이터의 필드(컬럼)명을 정확히 지정해야 한다. 이는 데이터의 구조를 명확하게 표현하는 데 중요한 역할을 한다.

- #### 데이터 일관성 유지: 전달하는 딕셔너리의 키가 `fieldnames` 매개변수에서 정의한 필드명과 일치해야 한다. 데이터의 일관성을 유지하는 것이 중요하다.

- #### `csv.DictWriter()`를 사용하는 것은 데이터의 구조를 명확하게 CSV 파일에 반영하고 싶을 때 특히 유용한 방법. 이를 통해 생성된 CSV 파일은 데이터의 구조를 명확하게 이해할 수 있으며, 데이터 처리 작업을 보다 효과적으로 수행할 수 있다.

## 행맨(Hangman) 미니게임 제작 가이드  (1)🎮👨‍💻
#### 행맨 게임은 플레이어가 제한된 횟수 내에 숨겨진 단어를 맞추는 간단하지만 재미있는 게임입니다. 여기서는 게임의 기본 구조와 필요한 파이썬 코드, 사용되는 함수와 메서드에 대해 자세히 설명한다.

### 1. 게임 시작: 사용자 인터랙션 및 초기 설정 🚀
```python
import time

# 플레이어에게 인사하고 이름을 물어본다.
name = input("What is your name? ")
print(f"Hi! {name}, Time to play hangman game!")
time.sleep(1)  # 게임 시작 전, 잠시 대기.

print("Start loading...")
time.sleep(0.5)  # 로딩 시간을 표현하기 위해 대기.

# 정답이 될 단어를 설정.
word = "secret"
# 플레이어가 지금까지 추측한 글자들을 저장할 문자열.
guesses = ''
# 플레이어가 가진 추측 기회의 수.
turns = 10
time.sleep(초):# 프로그램을 일시적으로 대기시키는 함수입니다. 사용자에게 시간적 여유를 준다.
input("메시지"): # 사용자로부터 입력을 받습니다. 여기서는 플레이어의 이름을 입력받습니다.
```
### 2. 핵심 게임 로직: 단어 추측하기 🔍
```python
while turns > 0:
    failed = 0  # 플레이어가 아직 맞추지 못한 글자의 수.
    
    # 숨겨진 단어를 한 글자씩 확인.
    for char in word:
        if char in guesses:
            print(char, end=' ')
        else:
            print("_", end=' ')
            failed += 1
    
    if failed == 0:
        print("\nCongratulations! The Guesses is correct.")
        break  # 모든 글자를 맞췄다면 게임을 종료.

    # 플레이어로부터 새로운 글자를 입력받는다.
    guess = input("\nguess a character: ")
    guesses += guess  # 입력받은 글자를 추측한 글자 목록에 추가.

    if guess not in word:
        turns -= 1  # 틀렸다면 남은 기회를 하나 줄인다.
        print("Oops! Wrong")
        print(f"You have {turns} more guesses!")

        if turns == 0:
            print("You hangman game failed. Bye!")
```
- #### while: 게임이 진행되는 동안 계속해서 실행될 조건을 설정.
- #### for와 if: 숨겨진 단어의 각 글자가 사용자의 추측에 포함되어 있는지 확인.
- #### input(): 사용자가 글자를 추측하여 입력하도록 요청.
- #### if not in: 사용자가 추측한 글자가 숨겨진 단어에 없을 경우, 실행될 조건을 설정.
### 게임의 흐름 🌊
- #### 사용자는 게임 시작 시 인사말과 함께 이름을 입력.
- #### 게임은 사용자에게 숨겨진 단어의 글자를 하나씩 추측하도록 요청.
- #### 사용자가 글자를 정확히 맞추면 해당 글자가 공개되고, 틀리면 남은 기회가 줄어든다.
- #### 모든 글자를 맞추거나 기회를 모두 사용하면 게임이 종료.
- #### 이 가이드를 통해 기본적인 행맨 게임의 구조와 작동 원리를 이해하고, 파이썬을 사용한 간단한 게임 제작의 기초를 배울 수 있다. 게임 제작에 필요한 기본적인 조건문, 반복문, 함수 사용법을 익힐 수 있으며, 프로그래밍 능력을 향상시킬 좋은 기회가 되는거같다!.
---

## 행맨(Hangman) 미니게임 제작 가이드  (2)🎮👨‍💻 
```python
# 필요한 라이브러리들을 임포트. 각각 시간 지연, 랜덤 처리, CSV 파일 처리, 사운드 재생 기능을 담당.
import time
import random
import csv
import winsound

# 사용자로부터 게임을 진행할 사용자의 이름을 입력 받는다.
name = input("What is your name? ")
# 사용자에게 환영 메시지를 출력. 사용자의 이름을 포함시켜 개인화한다.
print("Hi!", name, "Time to play hangman game!")
# 게임 설명 후, 짧은 대기 시간을 두어 사용자에게 준비 시간을 제공.
time.sleep(1)

# 게임 데이터를 로딩하는 척 하는 메시지를 출력.
print("Start loading...")
# 실제 로딩 시간과 같은 효과를 내기 위해 잠시 대기.
time.sleep(0.5)

# 단어 목록을 저장할 리스트를 초기화함.
words = []
# 단어 목록이 저장된 CSV 파일을 연다.
with open('./resource/word_list.csv', 'r') as f:
    reader = csv.reader(f)
    next(reader)  # 첫 번째 줄(헤더)는 건너뛴다.
    for c in reader:
        words.append(c)  # 단어 목록을 words 리스트에 추가.

# 단어 목록을 무작위로 섞음.
random.shuffle(words)
# 섞인 단어 목록 중 하나를 무작위로 선택.
q = random.choice(words)
# 선택된 단어를 사용하기 쉽도록 변수에 저장하고 공백을 제거.
word = q[0].strip()

# 사용자가 지금까지 추측한 글자들을 저장할 문자열.
guesses = ''
# 사용자가 단어를 맞출 수 있는 남은 시도 횟수.
turns = 10

# 사용자가 단어를 맞출 기회가 남아 있는 동안 실행되는 메인 게임 루프.
while turns > 0:
    failed = 0  # 맞추지 못한 글자 수를 세는 변수.

    # 선택된 단어의 각 글자에 대해 반복하면서 사용자가 맞췄는지 검사.
    for char in word:
        if char in guesses:
            print(char, end=' ')  # 맞춘 글자는 그대로 출력.
        else:
            print("_", end=' ')  # 맞추지 못한 글자는 _로 표시.
            failed += 1  # 맞추지 못한 글자가 있다면 failed를 증가시킴.

    # 만약 모든 글자를 맞췄다면, 게임 승리 메시지를 출력하고 사운드를 재생.
    if failed == 0:
        winsound.PlaySound('./sound/good.wav', winsound.SND_FILENAME)
        print("\n\nCongratulations! The Guesses is correct.")
        break  # 승리했으므로 메인 게임 루프를 종료.

    # 사용자로부터 새로운 글자를 추측 받는다.
    print("\n\nHint : {}".format(q[1].strip()))  # 힌트 출력
    guess = input("Guess a character: ")  # 새 글자 입력 받음

    # 입력 받은 글자를 guesses에 추가.
    guesses += guess

    # 입력 받은 글자가 정답 단어에 없는 경우, 오류 메시지를 출력하고 남은 기회를 줄임.
    if guess not in word:
        turns -= 1
        print("Oops! Wrong")
        print("You have", turns, 'more guesses!')

        # 만약 모든 기회를 사용했다면, 게임 패배 메시지와 사운드를 재생.
        if turns == 0:
            winsound.PlaySound('./sound/bad.wav', winsound.SND_FILENAME)
            print("You hangman game failed. Bye!")
```
### 🚀 시작 단계
#### 라이브러리 import 📚: 게임 개발에 필요한 time, random, csv, winsound 라이브러리를 임포트.

#### `time`은 대기 시간 생성에,
#### `random`은 단어 선택에,
#### `csv`는 단어 목록 load에,
#### `winsound`는 소리 재생에 사용.
- #### 사용자 인사 👋: 사용자의 이름을 묻고 게임 시작 메시지를 출력. 이는 게임에 친근감을 더하고 사용자 경험을 향상시킨다.

### 📖 데이터 로드 단계
- #### 단어 목록 로드 📄: `CSV` 파일로부터 게임에 사용될 단어와 힌트를 `load`. `csv.reader`를 사용해 파일을 읽고, `next(reader)`로 헤더를 건너뛴다.

- #### 단어 선택 🎲: 로드된 단어 목록에서 `random.shuffle`로 순서를 섞은 후, `random.choice`로 게임에 사용할 단어 하나를 랜덤으로 선택합니다.

### 🕹 게임 진행 단계
- #### 게임 루프 🔁: 사용자가 단어를 맞출 기회가 남아있는 동안 (while turns > 0) 게임이 계속 진행된다.

- #### 글자 출력 ✏️: 선택된 단어의 각 글자를 검사하여 사용자가 이미 추측한 글자는 그대로 출력하고, 아직 맞추지 못한 글자는 _로 표시.

- #### 승리 조건 검사 🏆: 모든 글자를 맞췄는지 `(failed == 0)` 확인. 맞췄다면 성공 사운드를 재생하고 축하 메시지를 출력한 후 게임을 종료.

- #### 글자 추측 받기 🅰: 사용자로부터 글자 하나를 입력받아, 이전에 추측한 글자들에 추가하고. 힌트도 함께 제공한다.

- #### 추측 검사 및 결과 처리 ❌: 사용자가 추측한 글자가 단어에 포함되지 않은 경우, 남은 기회`(turns)`를 하나 줄이고, 남은 기회가 없다면 실패 사운드를 재생하고 게임을 종료한다.

### 🎉 종료 조건
- #### 승리 또는 패배 🏁: 모든 글자를 맞추면 승리, 남은 기회를 모두 사용하면 패배. 각 상황에 맞는 메시지와 사운드를 재생한다.
### 🛠 핵심 포인트
- #### 사용자 인터랙션 👥: 게임의 재미와 몰입감을 높이기 위해 사용자와의 상호작용을 중요시한다.
- #### 데이터 처리 📊: csv 파일로부터 게임 데이터를 로드하고 관리하는 방법을 학습.
- #### 조건 로직 🧠: `if`문과 `while`루프를 사용하여 게임의 핵심 로직을 구현.
- #### 사운드 효과 🔊: 게임의 결과에 따라 다른 사운드를 재생하여 사용자 경험을 향상시킴.
- #### 이 설명을 통해 행맨 게임의 전체적인 구조와 진행 흐름, 각 단계에서 중요한 포인트를 이해할 수 있다. 프로그래밍 기초부터 시작하여 실제 게임을 만드는 과정까지, 다양한 개념과 기술을 익힐 수 있는 좋은 실습이 되는거같다.

###### 이렇게 해서 파이썬 기초문법을 알아보았다. 🎉🐍 이 과정을 통해 변수, 조건문, 반복문, 함수, 모듈 사용법 등 파이썬 프로그래밍의 기본적인 요소들을 배웠다. 프로그래밍은 이론뿐만 아니라 실습을 통해 배우는 것이 중요한거같다. 앞으로도 이글을 보고 배우신 분들이 있다면 이 내용을 다양한 프로젝트에 적용해보면서 더 깊이 있는 지식을 쌓아가시길 바랍니당 🚀💻

 ###### 인프런 파이썬 입문 강의 보고 작성한 글입니다 기초 문법 다지기도 작성할 예정입니다. 📚💡






































